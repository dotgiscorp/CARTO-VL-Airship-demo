{"ast":null,"code":"/*!\n * CARTO VL js https://carto.com/\n * Version: 1.4.2\n * \n */\n!function webpackUniversalModuleDefinition(e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.carto = t() : e.carto = t();\n}(window, function () {\n  return function (e) {\n    var t = {};\n\n    function __webpack_require__(r) {\n      if (t[r]) return t[r].exports;\n      var n = t[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return e[r].call(n.exports, n, n.exports, __webpack_require__), n.l = !0, n.exports;\n    }\n\n    return __webpack_require__.m = e, __webpack_require__.c = t, __webpack_require__.d = function (e, t, r) {\n      __webpack_require__.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: r\n      });\n    }, __webpack_require__.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, __webpack_require__.t = function (e, t) {\n      if (1 & t && (e = __webpack_require__(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var r = Object.create(null);\n      if (__webpack_require__.r(r), Object.defineProperty(r, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var n in e) __webpack_require__.d(r, n, function (t) {\n        return e[t];\n      }.bind(null, n));\n      return r;\n    }, __webpack_require__.n = function (e) {\n      var t = e && e.__esModule ? function getDefault() {\n        return e.default;\n      } : function getModuleExports() {\n        return e;\n      };\n      return __webpack_require__.d(t, \"a\", t), t;\n    }, __webpack_require__.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, __webpack_require__.p = \"\", __webpack_require__(__webpack_require__.s = 71);\n  }([function (e, t) {\n    function _getPrototypeOf(t) {\n      return e.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      }, _getPrototypeOf(t);\n    }\n\n    e.exports = _getPrototypeOf;\n  }, function (e, t) {\n    e.exports = function _classCallCheck(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    };\n  }, function (e, t, r) {\n    var n = r(13),\n        a = r(12);\n\n    e.exports = function _possibleConstructorReturn(e, t) {\n      return !t || \"object\" !== n(t) && \"function\" != typeof t ? a(e) : t;\n    };\n  }, function (e, t, r) {\n    var n = r(21);\n\n    e.exports = function _inherits(e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && n(e, t);\n    };\n  }, function (e, t) {\n    function _defineProperties(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var n = t[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n      }\n    }\n\n    e.exports = function _createClass(e, t, r) {\n      return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;\n    };\n  }, function (e, t, r) {\n    r(0);\n    var n = r(26);\n\n    function _get(t, r, a) {\n      return \"undefined\" != typeof Reflect && Reflect.get ? e.exports = _get = Reflect.get : e.exports = _get = function _get(e, t, r) {\n        var a = n(e, t);\n\n        if (a) {\n          var i = Object.getOwnPropertyDescriptor(a, t);\n          return i.get ? i.get.call(r) : i.value;\n        }\n      }, _get(t, r, a || t);\n    }\n\n    e.exports = _get;\n  }, function (e, t, r) {\n    var n = r(21);\n\n    function _construct(t, r, a) {\n      return !function isNativeReflectConstruct() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n\n        try {\n          return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }() ? e.exports = _construct = function _construct(e, t, r) {\n        var a = [null];\n        a.push.apply(a, t);\n        var i = new (Function.bind.apply(e, a))();\n        return r && n(i, r.prototype), i;\n      } : e.exports = _construct = Reflect.construct, _construct.apply(null, arguments);\n    }\n\n    e.exports = _construct;\n  }, function (e, t, r) {\n    var n = r(53),\n        a = r(23),\n        i = r(54);\n\n    e.exports = function _toConsumableArray(e) {\n      return n(e) || a(e) || i();\n    };\n  }, function (e, t, r) {\n    e.exports = r(58);\n  }, function (e, t, r) {\n    var n = r(24),\n        a = r(56),\n        i = r(25);\n\n    e.exports = function _slicedToArray(e, t) {\n      return n(e) || a(e, t) || i();\n    };\n  }, function (e, t, r) {\n    !function (r) {\n      \"use strict\";\n\n      var n = function (e, t) {\n        var r = new Error(e + \" at character \" + t);\n        throw r.index = t, r.description = e, r;\n      },\n          a = !0,\n          i = {\n        \"-\": a,\n        \"!\": a,\n        \"~\": a,\n        \"+\": a\n      },\n          o = {\n        \"||\": 1,\n        \"&&\": 2,\n        \"|\": 3,\n        \"^\": 4,\n        \"&\": 5,\n        \"==\": 6,\n        \"!=\": 6,\n        \"===\": 6,\n        \"!==\": 6,\n        \"<\": 7,\n        \">\": 7,\n        \"<=\": 7,\n        \">=\": 7,\n        \"<<\": 8,\n        \">>\": 8,\n        \">>>\": 8,\n        \"+\": 9,\n        \"-\": 9,\n        \"*\": 10,\n        \"/\": 10,\n        \"%\": 10\n      },\n          u = {\n        $: a,\n        _: a\n      },\n          s = function (e) {\n        var t,\n            r = 0;\n\n        for (var n in e) (t = n.length) > r && e.hasOwnProperty(n) && (r = t);\n\n        return r;\n      },\n          c = s(i),\n          l = s(o),\n          f = {\n        true: !0,\n        false: !1,\n        null: null\n      },\n          h = function (e) {\n        return o[e] || 0;\n      },\n          d = function (e, t, r) {\n        return {\n          type: \"||\" === e || \"&&\" === e ? \"LogicalExpression\" : \"BinaryExpression\",\n          operator: e,\n          left: t,\n          right: r\n        };\n      },\n          p = function (e) {\n        return e >= 48 && e <= 57;\n      },\n          m = function (e) {\n        return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 128 && !o[String.fromCharCode(e)] || u.hasOwnProperty(String.fromCharCode(e));\n      },\n          v = function (e) {\n        return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e >= 128 && !o[String.fromCharCode(e)] || u.hasOwnProperty(String.fromCharCode(e));\n      },\n          y = function (e) {\n        for (var t, r, a = 0, u = e.charAt, s = e.charCodeAt, y = function (t) {\n          return u.call(e, t);\n        }, g = function (t) {\n          return s.call(e, t);\n        }, _ = e.length, b = function () {\n          for (var e = g(a); 32 === e || 9 === e || 10 === e || 13 === e;) e = g(++a);\n        }, x = function () {\n          var e,\n              t,\n              r = T();\n          return b(), 63 !== g(a) ? r : (a++, (e = x()) || n(\"Expected expression\", a), b(), 58 === g(a) ? (a++, (t = x()) || n(\"Expected expression\", a), {\n            type: \"ConditionalExpression\",\n            test: r,\n            consequent: e,\n            alternate: t\n          }) : void n(\"Expected :\", a));\n        }, k = function () {\n          b();\n\n          for (var t = e.substr(a, l), r = t.length; r > 0;) {\n            if (o.hasOwnProperty(t) && (!m(g(a)) || a + t.length < e.length && !v(g(a + t.length)))) return a += r, t;\n            t = t.substr(0, --r);\n          }\n\n          return !1;\n        }, T = function () {\n          var e, t, r, i, o, u, s, c, l;\n          if (u = w(), !(t = k())) return u;\n\n          for (o = {\n            value: t,\n            prec: h(t)\n          }, (s = w()) || n(\"Expected expression after \" + t, a), i = [u, o, s]; (t = k()) && 0 !== (r = h(t));) {\n            for (o = {\n              value: t,\n              prec: r\n            }, l = t; i.length > 2 && r <= i[i.length - 2].prec;) s = i.pop(), t = i.pop().value, u = i.pop(), e = d(t, u, s), i.push(e);\n\n            (e = w()) || n(\"Expected expression after \" + l, a), i.push(o, e);\n          }\n\n          for (e = i[c = i.length - 1]; c > 1;) e = d(i[c - 1].value, i[c - 2], e), c -= 2;\n\n          return e;\n        }, w = function () {\n          var t, r, n;\n          if (b(), t = g(a), p(t) || 46 === t) return C();\n          if (39 === t || 34 === t) return E();\n          if (91 === t) return I();\n\n          for (n = (r = e.substr(a, c)).length; n > 0;) {\n            if (i.hasOwnProperty(r) && (!m(g(a)) || a + r.length < e.length && !v(g(a + r.length)))) return a += n, {\n              type: \"UnaryExpression\",\n              operator: r,\n              argument: w(),\n              prefix: !0\n            };\n            r = r.substr(0, --n);\n          }\n\n          return !(!m(t) && 40 !== t) && S();\n        }, C = function () {\n          for (var e, t, r = \"\"; p(g(a));) r += y(a++);\n\n          if (46 === g(a)) for (r += y(a++); p(g(a));) r += y(a++);\n\n          if (\"e\" === (e = y(a)) || \"E\" === e) {\n            for (r += y(a++), \"+\" !== (e = y(a)) && \"-\" !== e || (r += y(a++)); p(g(a));) r += y(a++);\n\n            p(g(a - 1)) || n(\"Expected exponent (\" + r + y(a) + \")\", a);\n          }\n\n          return t = g(a), m(t) ? n(\"Variable names cannot start with a number (\" + r + y(a) + \")\", a) : 46 === t && n(\"Unexpected period\", a), {\n            type: \"Literal\",\n            value: parseFloat(r),\n            raw: r\n          };\n        }, E = function () {\n          for (var e, t = \"\", r = y(a++), i = !1; a < _;) {\n            if ((e = y(a++)) === r) {\n              i = !0;\n              break;\n            }\n\n            if (\"\\\\\" === e) switch (e = y(a++)) {\n              case \"n\":\n                t += \"\\n\";\n                break;\n\n              case \"r\":\n                t += \"\\r\";\n                break;\n\n              case \"t\":\n                t += \"\\t\";\n                break;\n\n              case \"b\":\n                t += \"\\b\";\n                break;\n\n              case \"f\":\n                t += \"\\f\";\n                break;\n\n              case \"v\":\n                t += \"\\v\";\n                break;\n\n              default:\n                t += e;\n            } else t += e;\n          }\n\n          return i || n('Unclosed quote after \"' + t + '\"', a), {\n            type: \"Literal\",\n            value: t,\n            raw: r + t + r\n          };\n        }, M = function () {\n          var t,\n              r = g(a),\n              i = a;\n\n          for (m(r) ? a++ : n(\"Unexpected \" + y(a), a); a < _ && (r = g(a), v(r));) a++;\n\n          return t = e.slice(i, a), f.hasOwnProperty(t) ? {\n            type: \"Literal\",\n            value: f[t],\n            raw: t\n          } : \"this\" === t ? {\n            type: \"ThisExpression\"\n          } : {\n            type: \"Identifier\",\n            name: t\n          };\n        }, A = function (e) {\n          for (var t, r, i = [], o = !1, u = 0; a < _;) {\n            if (b(), (t = g(a)) === e) {\n              o = !0, a++, 41 === e && u && u >= i.length && n(\"Unexpected token \" + String.fromCharCode(e), a);\n              break;\n            }\n\n            if (44 === t) {\n              if (a++, ++u !== i.length) if (41 === e) n(\"Unexpected token ,\", a);else if (93 === e) for (var s = i.length; s < u; s++) i.push(null);\n            } else (r = x()) && \"Compound\" !== r.type || n(\"Expected comma\", a), i.push(r);\n          }\n\n          return o || n(\"Expected \" + String.fromCharCode(e), a), i;\n        }, S = function () {\n          var e, t;\n\n          for (t = 40 === (e = g(a)) ? P() : M(), b(), e = g(a); 46 === e || 91 === e || 40 === e;) a++, 46 === e ? (b(), t = {\n            type: \"MemberExpression\",\n            computed: !1,\n            object: t,\n            property: M()\n          }) : 91 === e ? (t = {\n            type: \"MemberExpression\",\n            computed: !0,\n            object: t,\n            property: x()\n          }, b(), 93 !== (e = g(a)) && n(\"Unclosed [\", a), a++) : 40 === e && (t = {\n            type: \"CallExpression\",\n            arguments: A(41),\n            callee: t\n          }), b(), e = g(a);\n\n          return t;\n        }, P = function () {\n          a++;\n          var e = x();\n          if (b(), 41 === g(a)) return a++, e;\n          n(\"Unclosed (\", a);\n        }, I = function () {\n          return a++, {\n            type: \"ArrayExpression\",\n            elements: A(93)\n          };\n        }, N = []; a < _;) 59 === (t = g(a)) || 44 === t ? a++ : (r = x()) ? N.push(r) : a < _ && n('Unexpected \"' + y(a) + '\"', a);\n\n        return 1 === N.length ? N[0] : {\n          type: \"Compound\",\n          body: N\n        };\n      };\n\n      y.version = \"0.3.4\", y.toString = function () {\n        return \"JavaScript Expression Parser (JSEP) v\" + y.version;\n      }, y.addUnaryOp = function (e) {\n        return c = Math.max(e.length, c), i[e] = a, this;\n      }, y.addBinaryOp = function (e, t) {\n        return l = Math.max(e.length, l), o[e] = t, this;\n      }, y.addIdentifierChar = function (e) {\n        return u[e] = a, this;\n      }, y.addLiteral = function (e, t) {\n        return f[e] = t, this;\n      }, y.removeUnaryOp = function (e) {\n        return delete i[e], e.length === c && (c = s(i)), this;\n      }, y.removeAllUnaryOps = function () {\n        return i = {}, c = 0, this;\n      }, y.removeIdentifierChar = function (e) {\n        return delete u[e], this;\n      }, y.removeBinaryOp = function (e) {\n        return delete o[e], e.length === l && (l = s(o)), this;\n      }, y.removeAllBinaryOps = function () {\n        return o = {}, l = 0, this;\n      }, y.removeLiteral = function (e) {\n        return delete f[e], this;\n      }, y.removeAllLiterals = function () {\n        return f = {}, this;\n      }, void 0 !== e && e.exports ? t = e.exports = y : t.parse = y;\n    }();\n  }, function (e, t) {\n    function asyncGeneratorStep(e, t, r, n, a, i, o) {\n      try {\n        var u = e[i](o),\n            s = u.value;\n      } catch (e) {\n        return void r(e);\n      }\n\n      u.done ? t(s) : Promise.resolve(s).then(n, a);\n    }\n\n    e.exports = function _asyncToGenerator(e) {\n      return function () {\n        var t = this,\n            r = arguments;\n        return new Promise(function (n, a) {\n          var i = e.apply(t, r);\n\n          function _next(e) {\n            asyncGeneratorStep(i, n, a, _next, _throw, \"next\", e);\n          }\n\n          function _throw(e) {\n            asyncGeneratorStep(i, n, a, _next, _throw, \"throw\", e);\n          }\n\n          _next(void 0);\n        });\n      };\n    };\n  }, function (e, t) {\n    e.exports = function _assertThisInitialized(e) {\n      if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return e;\n    };\n  }, function (e, t) {\n    function _typeof2(e) {\n      return (_typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function _typeof2(e) {\n        return typeof e;\n      } : function _typeof2(e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function _typeof(t) {\n      return \"function\" == typeof Symbol && \"symbol\" === _typeof2(Symbol.iterator) ? e.exports = _typeof = function _typeof(e) {\n        return _typeof2(e);\n      } : e.exports = _typeof = function _typeof(e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : _typeof2(e);\n      }, _typeof(t);\n    }\n\n    e.exports = _typeof;\n  }, function (e, t, r) {\n    var n = r(15);\n\n    e.exports = function _objectSpread(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var r = null != arguments[t] ? arguments[t] : {},\n            a = Object.keys(r);\n        \"function\" == typeof Object.getOwnPropertySymbols && (a = a.concat(Object.getOwnPropertySymbols(r).filter(function (e) {\n          return Object.getOwnPropertyDescriptor(r, e).enumerable;\n        }))), a.forEach(function (t) {\n          n(e, t, r[t]);\n        });\n      }\n\n      return e;\n    };\n  }, function (e, t) {\n    e.exports = function _defineProperty(e, t, r) {\n      return t in e ? Object.defineProperty(e, t, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = r, e;\n    };\n  }, function (e, t, r) {\n    r(0);\n    var n = r(26),\n        a = r(15);\n\n    function set(e, t, r, i) {\n      return (set = \"undefined\" != typeof Reflect && Reflect.set ? Reflect.set : function set(e, t, r, i) {\n        var o,\n            u = n(e, t);\n\n        if (u) {\n          if ((o = Object.getOwnPropertyDescriptor(u, t)).set) return o.set.call(i, r), !0;\n          if (!o.writable) return !1;\n        }\n\n        if (o = Object.getOwnPropertyDescriptor(i, t)) {\n          if (!o.writable) return !1;\n          o.value = r, Object.defineProperty(i, t, o);\n        } else a(i, t, r);\n\n        return !0;\n      })(e, t, r, i);\n    }\n\n    e.exports = function _set(e, t, r, n, a) {\n      if (!set(e, t, r, n || e) && a) throw new Error(\"failed to set property\");\n      return r;\n    };\n  }, function (e) {\n    e.exports = {\n      a: \"1.4.2\"\n    };\n  }, function (e, t) {\n    e.exports = '#ifndef CIELAB_TO_SRGBA\\n#define CIELAB_TO_SRGBA\\n\\nconst mat3 XYZ_2_RGB = (mat3(\\n    3.2404542,-1.5371385,-0.4985314,\\n    -0.9692660, 1.8760108, 0.0415560,\\n    0.0556434,-0.2040259, 1.0572252\\n));\\nconst float SRGB_GAMMA = 1.0 / 2.2;\\n\\nvec3 rgb_to_srgb_approx(vec3 rgb) {\\n    return pow(rgb, vec3(SRGB_GAMMA));\\n}\\n\\nfloat f1(float t){\\n    const float sigma = 6./29.;\\n    if (t>sigma){\\n        return t*t*t;\\n    }else{\\n        return 3.*sigma*sigma*(t-4./29.);\\n    }\\n}\\n\\nvec3 cielabtoxyz(vec3 c) {\\n    const float xn = 95.047/100.;\\n    const float yn = 100./100.;\\n    const float zn = 108.883/100.;\\n    return vec3(xn*f1((c.x+16.)/116.  + c.y/500. ),\\n                yn*f1((c.x+16.)/116.),\\n                zn*f1((c.x+16.)/116.  - c.z/200. )\\n            );\\n}\\n\\nvec3 xyztorgb(vec3 c){\\n    return c * XYZ_2_RGB;\\n}\\n\\nvec3 xyztosrgb(vec3 c) { // FIXME naming\\n    return rgb_to_srgb_approx(xyztorgb(c));\\n}\\n\\nvec4 cielabToSRGBA(vec4 cielab){\\n    return vec4(xyztosrgb(cielabtoxyz(\\n        vec3(\\n            clamp(cielab.r, 0., 100.),\\n            clamp(cielab.g, -128., 128.),\\n            clamp(cielab.b, -128., 128.)\\n        )\\n    )), cielab.a);\\n}\\n#endif\\n\\n\\n#ifndef SRGBA_TO_CIELAB\\n#define SRGBA_TO_CIELAB\\nvec4 sRGBToXYZ (vec4 srgba);\\nvec4 sRGBToLinearRGB (vec4 srgba);\\nfloat inverseGammaCorrection(float t);\\nvec4 XYZToCieLab (vec4 xyza);\\nfloat XYZToCieLabAux(float t);\\n\\nvec4 sRGBAToCieLAB(vec4 srgba){\\n    return XYZToCieLab(sRGBToXYZ(srgba));\\n}\\n\\n// Convert sRGB to CIE XYZ with the D65 white point\\nvec4 sRGBToXYZ (vec4 srgba) {\\n    // Poynton, \"Frequently Asked Questions About Color,\" page 10\\n    // Wikipedia: http://en.wikipedia.org/wiki/SRGB\\n    // Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space\\n    vec4 rgba = sRGBToLinearRGB(srgba);\\n    return vec4(\\n        (0.4123955889674142161 * rgba.r + 0.3575834307637148171 * rgba.g + 0.1804926473817015735 * rgba.b),\\n        (0.2125862307855955516 * rgba.r + 0.7151703037034108499 * rgba.g + 0.07220049864333622685 * rgba.b),\\n        (0.01929721549174694484 * rgba.r + 0.1191838645808485318 * rgba.g + 0.9504971251315797660 * rgba.b),\\n        rgba.a\\n    );\\n}\\n\\nvec4 sRGBToLinearRGB (vec4 srgba) {\\n    // http://en.wikipedia.org/wiki/SRGB\\n    return vec4(\\n        inverseGammaCorrection(srgba.r),\\n        inverseGammaCorrection(srgba.g),\\n        inverseGammaCorrection(srgba.b),\\n        srgba.a\\n    );\\n}\\n\\nfloat inverseGammaCorrection(float t) {\\n    return t <= 0.0404482362771076 ? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\\n}\\n\\n\\nfloat WHITEPOINT_D65_X = 0.950456;\\nfloat WHITEPOINT_D65_Y = 1.0;\\nfloat WHITEPOINT_D65_Z = 1.088754;\\n\\n// Convert CIE XYZ to CIE L*a*b* (CIELAB) with the D65 white point\\nvec4 XYZToCieLab (vec4 xyza) {\\n    // Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space\\n\\n    float xn = WHITEPOINT_D65_X;\\n    float yn = WHITEPOINT_D65_Y;\\n    float zn = WHITEPOINT_D65_Z;\\n\\n    return vec4(\\n        116. * XYZToCieLabAux(xyza.y / yn) - 16.,\\n        500. * (XYZToCieLabAux(xyza.x / xn) - XYZToCieLabAux(xyza.y / yn)),\\n        200. * (XYZToCieLabAux(xyza.y / yn) - XYZToCieLabAux(xyza.z / zn)),\\n        xyza.a\\n    );\\n}\\n\\nfloat XYZToCieLabAux(float t) {\\n    return t >= 8.85645167903563082e-3\\n            ? pow(t, 0.333333333333333) : (841.0 / 108.0) * t + 4.0 / 29.0;\\n}\\n\\n#endif\\n';\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\nattribute vec2 vertex;\\n\\nvarying  vec2 uv;\\n\\nvoid main(void) {\\n    uv = vertex*0.5+vec2(0.5);\\n    gl_Position = vec4(vertex, 0.5, 1.);\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nvarying vec2 uv;\\n\\nvec2 featureID;\\n\\n$propertyPreface\\n$style_preface\\n\\nvoid main(void) {\\n    featureID = abs(uv);\\n    gl_FragColor = $style_inline;\\n}\\n\";\n  }, function (e, t) {\n    function _setPrototypeOf(t, r) {\n      return e.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(e, t) {\n        return e.__proto__ = t, e;\n      }, _setPrototypeOf(t, r);\n    }\n\n    e.exports = _setPrototypeOf;\n  }, function (e, t, r) {\n    e.exports = r(60);\n  }, function (e, t) {\n    e.exports = function _iterableToArray(e) {\n      if (Symbol.iterator in Object(e) || \"[object Arguments]\" === Object.prototype.toString.call(e)) return Array.from(e);\n    };\n  }, function (e, t) {\n    e.exports = function _arrayWithHoles(e) {\n      if (Array.isArray(e)) return e;\n    };\n  }, function (e, t) {\n    e.exports = function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    };\n  }, function (e, t, r) {\n    var n = r(0);\n\n    e.exports = function _superPropBase(e, t) {\n      for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = n(e)););\n\n      return e;\n    };\n  }, function (e, t) {\n    var r,\n        n,\n        a = e.exports = {};\n\n    function defaultSetTimout() {\n      throw new Error(\"setTimeout has not been defined\");\n    }\n\n    function defaultClearTimeout() {\n      throw new Error(\"clearTimeout has not been defined\");\n    }\n\n    function runTimeout(e) {\n      if (r === setTimeout) return setTimeout(e, 0);\n      if ((r === defaultSetTimout || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0);\n\n      try {\n        return r(e, 0);\n      } catch (t) {\n        try {\n          return r.call(null, e, 0);\n        } catch (t) {\n          return r.call(this, e, 0);\n        }\n      }\n    }\n\n    !function () {\n      try {\n        r = \"function\" == typeof setTimeout ? setTimeout : defaultSetTimout;\n      } catch (e) {\n        r = defaultSetTimout;\n      }\n\n      try {\n        n = \"function\" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;\n      } catch (e) {\n        n = defaultClearTimeout;\n      }\n    }();\n    var i,\n        o = [],\n        u = !1,\n        s = -1;\n\n    function cleanUpNextTick() {\n      u && i && (u = !1, i.length ? o = i.concat(o) : s = -1, o.length && drainQueue());\n    }\n\n    function drainQueue() {\n      if (!u) {\n        var e = runTimeout(cleanUpNextTick);\n        u = !0;\n\n        for (var t = o.length; t;) {\n          for (i = o, o = []; ++s < t;) i && i[s].run();\n\n          s = -1, t = o.length;\n        }\n\n        i = null, u = !1, function runClearTimeout(e) {\n          if (n === clearTimeout) return clearTimeout(e);\n          if ((n === defaultClearTimeout || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e);\n\n          try {\n            return n(e);\n          } catch (t) {\n            try {\n              return n.call(null, e);\n            } catch (t) {\n              return n.call(this, e);\n            }\n          }\n        }(e);\n      }\n    }\n\n    function Item(e, t) {\n      this.fun = e, this.array = t;\n    }\n\n    function noop() {}\n\n    a.nextTick = function (e) {\n      var t = new Array(arguments.length - 1);\n      if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];\n      o.push(new Item(e, t)), 1 !== o.length || u || runTimeout(drainQueue);\n    }, Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    }, a.title = \"browser\", a.browser = !0, a.env = {}, a.argv = [], a.version = \"\", a.versions = {}, a.on = noop, a.addListener = noop, a.once = noop, a.off = noop, a.removeListener = noop, a.removeAllListeners = noop, a.emit = noop, a.prependListener = noop, a.prependOnceListener = noop, a.listeners = function (e) {\n      return [];\n    }, a.binding = function (e) {\n      throw new Error(\"process.binding is not supported\");\n    }, a.cwd = function () {\n      return \"/\";\n    }, a.chdir = function (e) {\n      throw new Error(\"process.chdir is not supported\");\n    }, a.umask = function () {\n      return 0;\n    };\n  }, function (e, t, r) {\n    var n = r(0),\n        a = r(21),\n        i = r(55),\n        o = r(6);\n\n    function _wrapNativeSuper(t) {\n      var r = \"function\" == typeof Map ? new Map() : void 0;\n      return e.exports = _wrapNativeSuper = function _wrapNativeSuper(e) {\n        if (null === e || !i(e)) return e;\n        if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (void 0 !== r) {\n          if (r.has(e)) return r.get(e);\n          r.set(e, Wrapper);\n        }\n\n        function Wrapper() {\n          return o(e, arguments, n(this).constructor);\n        }\n\n        return Wrapper.prototype = Object.create(e.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), a(Wrapper, e);\n      }, _wrapNativeSuper(t);\n    }\n\n    e.exports = _wrapNativeSuper;\n  }, function (e, t, r) {\n    var n = r(57);\n\n    e.exports = function _objectWithoutProperties(e, t) {\n      if (null == e) return {};\n      var r,\n          a,\n          i = n(e, t);\n\n      if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n\n        for (a = 0; a < o.length; a++) r = o[a], t.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]);\n      }\n\n      return i;\n    };\n  }, function (e, t, r) {\n    var n = r(24),\n        a = r(23),\n        i = r(25);\n\n    e.exports = function _toArray(e) {\n      return n(e) || a(e) || i();\n    };\n  }, function (e, t, r) {\n    \"use strict\";\n\n    e.exports = LRUCache;\n    var n,\n        a = r(63),\n        i = r(65),\n        o = r(69),\n        u = (n = \"function\" == typeof Symbol ? function (e) {\n      return Symbol(e);\n    } : function (e) {\n      return \"_\" + e;\n    })(\"max\"),\n        s = n(\"length\"),\n        c = n(\"lengthCalculator\"),\n        l = n(\"allowStale\"),\n        f = n(\"maxAge\"),\n        h = n(\"dispose\"),\n        d = n(\"noDisposeOnSet\"),\n        p = n(\"lruList\"),\n        m = n(\"cache\");\n\n    function naiveLength() {\n      return 1;\n    }\n\n    function LRUCache(e) {\n      if (!(this instanceof LRUCache)) return new LRUCache(e);\n      \"number\" == typeof e && (e = {\n        max: e\n      }), e || (e = {});\n      var t = this[u] = e.max;\n      (!t || \"number\" != typeof t || t <= 0) && (this[u] = 1 / 0);\n      var r = e.length || naiveLength;\n      \"function\" != typeof r && (r = naiveLength), this[c] = r, this[l] = e.stale || !1, this[f] = e.maxAge || 0, this[h] = e.dispose, this[d] = e.noDisposeOnSet || !1, this.reset();\n    }\n\n    function forEachStep(e, t, r, n) {\n      var a = r.value;\n      isStale(e, a) && (del(e, r), e[l] || (a = void 0)), a && t.call(n, a.value, a.key, e);\n    }\n\n    function get(e, t, r) {\n      var n = e[m].get(t);\n\n      if (n) {\n        var a = n.value;\n        isStale(e, a) ? (del(e, n), e[l] || (a = void 0)) : r && e[p].unshiftNode(n), a && (a = a.value);\n      }\n\n      return a;\n    }\n\n    function isStale(e, t) {\n      if (!t || !t.maxAge && !e[f]) return !1;\n      var r = Date.now() - t.now;\n      return t.maxAge ? r > t.maxAge : e[f] && r > e[f];\n    }\n\n    function trim(e) {\n      if (e[s] > e[u]) for (var t = e[p].tail; e[s] > e[u] && null !== t;) {\n        var r = t.prev;\n        del(e, t), t = r;\n      }\n    }\n\n    function del(e, t) {\n      if (t) {\n        var r = t.value;\n        e[h] && e[h](r.key, r.value), e[s] -= r.length, e[m].delete(r.key), e[p].removeNode(t);\n      }\n    }\n\n    Object.defineProperty(LRUCache.prototype, \"max\", {\n      set: function (e) {\n        (!e || \"number\" != typeof e || e <= 0) && (e = 1 / 0), this[u] = e, trim(this);\n      },\n      get: function () {\n        return this[u];\n      },\n      enumerable: !0\n    }), Object.defineProperty(LRUCache.prototype, \"allowStale\", {\n      set: function (e) {\n        this[l] = !!e;\n      },\n      get: function () {\n        return this[l];\n      },\n      enumerable: !0\n    }), Object.defineProperty(LRUCache.prototype, \"maxAge\", {\n      set: function (e) {\n        (!e || \"number\" != typeof e || e < 0) && (e = 0), this[f] = e, trim(this);\n      },\n      get: function () {\n        return this[f];\n      },\n      enumerable: !0\n    }), Object.defineProperty(LRUCache.prototype, \"lengthCalculator\", {\n      set: function (e) {\n        \"function\" != typeof e && (e = naiveLength), e !== this[c] && (this[c] = e, this[s] = 0, this[p].forEach(function (e) {\n          e.length = this[c](e.value, e.key), this[s] += e.length;\n        }, this)), trim(this);\n      },\n      get: function () {\n        return this[c];\n      },\n      enumerable: !0\n    }), Object.defineProperty(LRUCache.prototype, \"length\", {\n      get: function () {\n        return this[s];\n      },\n      enumerable: !0\n    }), Object.defineProperty(LRUCache.prototype, \"itemCount\", {\n      get: function () {\n        return this[p].length;\n      },\n      enumerable: !0\n    }), LRUCache.prototype.rforEach = function (e, t) {\n      t = t || this;\n\n      for (var r = this[p].tail; null !== r;) {\n        var n = r.prev;\n        forEachStep(this, e, r, t), r = n;\n      }\n    }, LRUCache.prototype.forEach = function (e, t) {\n      t = t || this;\n\n      for (var r = this[p].head; null !== r;) {\n        var n = r.next;\n        forEachStep(this, e, r, t), r = n;\n      }\n    }, LRUCache.prototype.keys = function () {\n      return this[p].toArray().map(function (e) {\n        return e.key;\n      }, this);\n    }, LRUCache.prototype.values = function () {\n      return this[p].toArray().map(function (e) {\n        return e.value;\n      }, this);\n    }, LRUCache.prototype.reset = function () {\n      this[h] && this[p] && this[p].length && this[p].forEach(function (e) {\n        this[h](e.key, e.value);\n      }, this), this[m] = new a(), this[p] = new o(), this[s] = 0;\n    }, LRUCache.prototype.dump = function () {\n      return this[p].map(function (e) {\n        if (!isStale(this, e)) return {\n          k: e.key,\n          v: e.value,\n          e: e.now + (e.maxAge || 0)\n        };\n      }, this).toArray().filter(function (e) {\n        return e;\n      });\n    }, LRUCache.prototype.dumpLru = function () {\n      return this[p];\n    }, LRUCache.prototype.inspect = function (e, t) {\n      var r = \"LRUCache {\",\n          n = !1;\n      this[l] && (r += \"\\n  allowStale: true\", n = !0);\n      var a = this[u];\n      a && a !== 1 / 0 && (n && (r += \",\"), r += \"\\n  max: \" + i.inspect(a, t), n = !0);\n      var o = this[f];\n      o && (n && (r += \",\"), r += \"\\n  maxAge: \" + i.inspect(o, t), n = !0);\n      var h = this[c];\n      h && h !== naiveLength && (n && (r += \",\"), r += \"\\n  length: \" + i.inspect(this[s], t), n = !0);\n      var d = !1;\n      return this[p].forEach(function (e) {\n        d ? r += \",\\n  \" : (n && (r += \",\\n\"), d = !0, r += \"\\n  \");\n        var a = i.inspect(e.key).split(\"\\n\").join(\"\\n  \"),\n            u = {\n          value: e.value\n        };\n        e.maxAge !== o && (u.maxAge = e.maxAge), h !== naiveLength && (u.length = e.length), isStale(this, e) && (u.stale = !0), u = i.inspect(u, t).split(\"\\n\").join(\"\\n  \"), r += a + \" => \" + u;\n      }), (d || n) && (r += \"\\n\"), r += \"}\";\n    }, LRUCache.prototype.set = function (e, t, r) {\n      var n = (r = r || this[f]) ? Date.now() : 0,\n          a = this[c](t, e);\n\n      if (this[m].has(e)) {\n        if (a > this[u]) return del(this, this[m].get(e)), !1;\n        var i = this[m].get(e).value;\n        return this[h] && (this[d] || this[h](e, i.value)), i.now = n, i.maxAge = r, i.value = t, this[s] += a - i.length, i.length = a, this.get(e), trim(this), !0;\n      }\n\n      var o = new function Entry(e, t, r, n, a) {\n        this.key = e, this.value = t, this.length = r, this.now = n, this.maxAge = a || 0;\n      }(e, t, a, n, r);\n      return o.length > this[u] ? (this[h] && this[h](e, t), !1) : (this[s] += o.length, this[p].unshift(o), this[m].set(e, this[p].head), trim(this), !0);\n    }, LRUCache.prototype.has = function (e) {\n      return !!this[m].has(e) && !isStale(this, this[m].get(e).value);\n    }, LRUCache.prototype.get = function (e) {\n      return get(this, e, !0);\n    }, LRUCache.prototype.peek = function (e) {\n      return get(this, e, !1);\n    }, LRUCache.prototype.pop = function () {\n      var e = this[p].tail;\n      return e ? (del(this, e), e.value) : null;\n    }, LRUCache.prototype.del = function (e) {\n      del(this, this[m].get(e));\n    }, LRUCache.prototype.load = function (e) {\n      this.reset();\n\n      for (var t = Date.now(), r = e.length - 1; r >= 0; r--) {\n        var n = e[r],\n            a = n.e || 0;\n        if (0 === a) this.set(n.k, n.v);else {\n          var i = a - t;\n          i > 0 && this.set(n.k, n.v, i);\n        }\n      }\n    }, LRUCache.prototype.prune = function () {\n      var e = this;\n      this[m].forEach(function (t, r) {\n        get(e, r, !1);\n      });\n    };\n  }, function (e, t, r) {\n    \"use strict\";\n\n    function lineclip(e, t, r) {\n      var n,\n          a,\n          i,\n          o,\n          u,\n          s = e.length,\n          c = bitCode(e[0], t),\n          l = [];\n\n      for (r || (r = []), n = 1; n < s; n++) {\n        for (a = e[n - 1], o = u = bitCode(i = e[n], t);;) {\n          if (!(c | o)) {\n            l.push(a), o !== u ? (l.push(i), n < s - 1 && (r.push(l), l = [])) : n === s - 1 && l.push(i);\n            break;\n          }\n\n          if (c & o) break;\n          c ? c = bitCode(a = intersect(a, i, c, t), t) : o = bitCode(i = intersect(a, i, o, t), t);\n        }\n\n        c = u;\n      }\n\n      return l.length && r.push(l), r;\n    }\n\n    function intersect(e, t, r, n) {\n      return 8 & r ? [e[0] + (t[0] - e[0]) * (n[3] - e[1]) / (t[1] - e[1]), n[3]] : 4 & r ? [e[0] + (t[0] - e[0]) * (n[1] - e[1]) / (t[1] - e[1]), n[1]] : 2 & r ? [n[2], e[1] + (t[1] - e[1]) * (n[2] - e[0]) / (t[0] - e[0])] : 1 & r ? [n[0], e[1] + (t[1] - e[1]) * (n[0] - e[0]) / (t[0] - e[0])] : null;\n    }\n\n    function bitCode(e, t) {\n      var r = 0;\n      return e[0] < t[0] ? r |= 1 : e[0] > t[2] && (r |= 2), e[1] < t[1] ? r |= 4 : e[1] > t[3] && (r |= 8), r;\n    }\n\n    e.exports = lineclip, lineclip.polyline = lineclip, lineclip.polygon = function polygonclip(e, t) {\n      var r, n, a, i, o, u, s;\n\n      for (n = 1; n <= 8; n *= 2) {\n        for (r = [], a = e[e.length - 1], i = !(bitCode(a, t) & n), o = 0; o < e.length; o++) u = e[o], (s = !(bitCode(u, t) & n)) !== i && r.push(intersect(a, u, n, t)), s && r.push(u), a = u, i = s;\n\n        if (!(e = r).length) break;\n      }\n\n      return r;\n    };\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\nattribute vec2 vertex;\\n\\nvarying  vec2 uv;\\n\\nvoid main(void) {\\n    uv = vertex*0.5+vec2(0.5);\\n    gl_Position = vec4(vertex, 0.5, 1.);\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nvarying  vec2 uv;\\n\\nuniform sampler2D aaTex;\\n\\nvoid main(void) {\\n    vec4 aa = texture2D(aaTex, uv);\\n    gl_FragColor = aa;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"vec2 encodeWidth(float x) {\\n    if (!(x<=0. || x>=0.) ){\\n        // Convert NaN widths to `0`\\n        // Do not remove this, some GPUs will convert NaN floats to 1. when\\n        // packing the shader output to a RGBA UNSIGNED BYTE textures\\n        x = 0.;\\n    }\\n    float high, low;\\n    x = clamp(x, 0., 1023.);\\n    high = floor(x/4.);\\n    low = (x-high*4.)/4.;\\n    return vec2(high/255., low);\\n}\\n\\n$width_preface\\n\";\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\n\\nuniform float orderMinWidth;\\nuniform float orderMaxWidth;\\nuniform float devicePixelRatio;\\nuniform vec2 resolution;\\nuniform mat4 matrix;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D widthTex;\\nuniform sampler2D filterTex;\\n\\nvarying highp vec2 featureIDVar;\\nvarying highp vec4 color;\\nvarying highp vec2 pointCoord;\\nvarying highp float filtering;\\n\\nfloat decodeWidth(vec2 enc) {\\n  return enc.x*(255.*4.) + 4.*enc.y;\\n}\\n\\n$symbolPlacement_preface\\n$propertyPreface\\n$transform_preface\\n\\nvec2 transform(vec2 p){\\n    return $transform_inline(2.*p)/resolution;\\n}\\n\\n// We'll need a square inscribed in a triangle\\n// The triangle will be equilateral\\n// The square side length will be equal to 1\\n// Each triangle edge length will be equal to 1+2*A (by definition of A)\\n// The triangle height will be equal to H by definition\\n// The square inscription will generate 3 smaller triangles\\n// Each one of these will have an hypotenuse equal to Y\\n//\\n// Therefore:\\n// Y*sin(60) = 1  =>  Y = 2 / sqrt(3)\\n// A=Y*cos(60)    =>  A = 1 / sqrt(3)\\n// tan(60) = H / (0.5 + A)   =>  H = sqrt(3)*(0.5 + 1 / sqrt(3))\\n#define A (0.577350269189625)\\n#define H (1.86603)\\n\\nvoid main(void) {\\n    featureIDVar = abs(featureID);\\n    color = texture2D(colorTex, abs(featureID));\\n    filtering = texture2D(filterTex, abs(featureID)).a;\\n\\n    float size = decodeWidth(texture2D(widthTex, abs(featureID)).rg);\\n\\n    vec4 p =  matrix*vec4(vertexPosition, 0., 1.);\\n    p/=p.w;\\n\\n    if (featureID.y<0.){\\n        pointCoord = vec2((0.5+A)/(0.5), 0.);\\n        p.xy += transform(size*vec2(0.5+A, -H/2. + (H/2. - 0.5) ));\\n    }else if (featureID.x<0.){\\n        pointCoord = vec2(-(0.5+A)/(0.5), 0.);\\n        p.xy += transform(size*vec2(-(0.5+A), -H/2. + (H/2. - 0.5)));\\n    }else{\\n        pointCoord = vec2(0., H);\\n        p.xy += transform(size*vec2(0., H/2. + (H/2. - 0.5)));\\n    }\\n    pointCoord.y = 1.-pointCoord.y;\\n\\n\\n    p.xy += ($symbolPlacement_inline)*size/resolution;\\n\\n\\n    vec4 noOverrideColor = vec4(1., 1., 1., 0.);\\n    bool alphaButNotOverrideColor = (color.a==0. && color != noOverrideColor);\\n\\n    if (size==0. || alphaButNotOverrideColor || size<orderMinWidth || size>=orderMaxWidth){\\n        p.x=10000.;\\n    }\\n\\n    gl_Position  = p;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nvarying highp vec2 featureIDVar;\\nvarying highp vec4 color;\\nvarying highp vec2 pointCoord;\\nvarying highp float filtering;\\n\\n$symbol_preface\\n$propertyPreface\\n\\nvoid main(void) {\\n    vec2 featureID = abs(featureIDVar);\\n    vec2 imageUV = pointCoord;\\n    imageUV.x = imageUV.x * 0.5 + 0.5;\\n    vec4 symbolColor = $symbol_inline;\\n    vec4 noOverrideColor = vec4(1., 1., 1., 0.);\\n\\n    vec4 c;\\n    if (color != noOverrideColor){\\n        c = color * vec4(vec3(1), symbolColor.a);\\n    }else{\\n        c = symbolColor;\\n    }\\n    c.a *= filtering;\\n    if (imageUV!=clamp(imageUV, 0.,1.)){\\n        c.a = 0.;\\n    }\\n\\n    gl_FragColor = vec4(c.rgb*c.a, c.a);\\n}\\n\";\n  }, function (e, t, r) {\n    \"use strict\";\n\n    function earcut(e, t, r) {\n      r = r || 2;\n      var n,\n          a,\n          i,\n          o,\n          u,\n          s,\n          c,\n          l = t && t.length,\n          f = l ? t[0] * r : e.length,\n          h = linkedList(e, 0, f, r, !0),\n          d = [];\n      if (!h) return d;\n\n      if (l && (h = function eliminateHoles(e, t, r, n) {\n        var a,\n            i,\n            o,\n            u,\n            s,\n            c = [];\n\n        for (a = 0, i = t.length; a < i; a++) o = t[a] * n, u = a < i - 1 ? t[a + 1] * n : e.length, (s = linkedList(e, o, u, n, !1)) === s.next && (s.steiner = !0), c.push(getLeftmost(s));\n\n        for (c.sort(compareX), a = 0; a < c.length; a++) eliminateHole(c[a], r), r = filterPoints(r, r.next);\n\n        return r;\n      }(e, t, h, r)), e.length > 80 * r) {\n        n = i = e[0], a = o = e[1];\n\n        for (var p = r; p < f; p += r) u = e[p], s = e[p + 1], u < n && (n = u), s < a && (a = s), u > i && (i = u), s > o && (o = s);\n\n        c = 0 !== (c = Math.max(i - n, o - a)) ? 1 / c : 0;\n      }\n\n      return earcutLinked(h, d, r, n, a, c), d;\n    }\n\n    function linkedList(e, t, r, n, a) {\n      var i, o;\n      if (a === signedArea(e, t, r, n) > 0) for (i = t; i < r; i += n) o = insertNode(i, e[i], e[i + 1], o);else for (i = r - n; i >= t; i -= n) o = insertNode(i, e[i], e[i + 1], o);\n      return o && equals(o, o.next) && (removeNode(o), o = o.next), o;\n    }\n\n    function filterPoints(e, t) {\n      if (!e) return e;\n      t || (t = e);\n      var r,\n          n = e;\n\n      do {\n        if (r = !1, n.steiner || !equals(n, n.next) && 0 !== area(n.prev, n, n.next)) n = n.next;else {\n          if (removeNode(n), (n = t = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== t);\n\n      return t;\n    }\n\n    function earcutLinked(e, t, r, n, a, i, o) {\n      if (e) {\n        !o && i && function indexCurve(e, t, r, n) {\n          var a = e;\n\n          do {\n            null === a.z && (a.z = zOrder(a.x, a.y, t, r, n)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next;\n          } while (a !== e);\n\n          a.prevZ.nextZ = null, a.prevZ = null, function sortLinked(e) {\n            var t,\n                r,\n                n,\n                a,\n                i,\n                o,\n                u,\n                s,\n                c = 1;\n\n            do {\n              for (r = e, e = null, i = null, o = 0; r;) {\n                for (o++, n = r, u = 0, t = 0; t < c && (u++, n = n.nextZ); t++);\n\n                for (s = c; u > 0 || s > 0 && n;) 0 !== u && (0 === s || !n || r.z <= n.z) ? (a = r, r = r.nextZ, u--) : (a = n, n = n.nextZ, s--), i ? i.nextZ = a : e = a, a.prevZ = i, i = a;\n\n                r = n;\n              }\n\n              i.nextZ = null, c *= 2;\n            } while (o > 1);\n\n            return e;\n          }(a);\n        }(e, n, a, i);\n\n        for (var u, s, c = e; e.prev !== e.next;) if (u = e.prev, s = e.next, i ? isEarHashed(e, n, a, i) : isEar(e)) t.push(u.i / r), t.push(e.i / r), t.push(s.i / r), removeNode(e), e = s.next, c = s.next;else if ((e = s) === c) {\n          o ? 1 === o ? earcutLinked(e = cureLocalIntersections(e, t, r), t, r, n, a, i, 2) : 2 === o && splitEarcut(e, t, r, n, a, i) : earcutLinked(filterPoints(e), t, r, n, a, i, 1);\n          break;\n        }\n      }\n    }\n\n    function isEar(e) {\n      var t = e.prev,\n          r = e,\n          n = e.next;\n      if (area(t, r, n) >= 0) return !1;\n\n      for (var a = e.next.next; a !== e.prev;) {\n        if (pointInTriangle(t.x, t.y, r.x, r.y, n.x, n.y, a.x, a.y) && area(a.prev, a, a.next) >= 0) return !1;\n        a = a.next;\n      }\n\n      return !0;\n    }\n\n    function isEarHashed(e, t, r, n) {\n      var a = e.prev,\n          i = e,\n          o = e.next;\n      if (area(a, i, o) >= 0) return !1;\n\n      for (var u = a.x < i.x ? a.x < o.x ? a.x : o.x : i.x < o.x ? i.x : o.x, s = a.y < i.y ? a.y < o.y ? a.y : o.y : i.y < o.y ? i.y : o.y, c = a.x > i.x ? a.x > o.x ? a.x : o.x : i.x > o.x ? i.x : o.x, l = a.y > i.y ? a.y > o.y ? a.y : o.y : i.y > o.y ? i.y : o.y, f = zOrder(u, s, t, r, n), h = zOrder(c, l, t, r, n), d = e.prevZ, p = e.nextZ; d && d.z >= f && p && p.z <= h;) {\n        if (d !== e.prev && d !== e.next && pointInTriangle(a.x, a.y, i.x, i.y, o.x, o.y, d.x, d.y) && area(d.prev, d, d.next) >= 0) return !1;\n        if (d = d.prevZ, p !== e.prev && p !== e.next && pointInTriangle(a.x, a.y, i.x, i.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;\n        p = p.nextZ;\n      }\n\n      for (; d && d.z >= f;) {\n        if (d !== e.prev && d !== e.next && pointInTriangle(a.x, a.y, i.x, i.y, o.x, o.y, d.x, d.y) && area(d.prev, d, d.next) >= 0) return !1;\n        d = d.prevZ;\n      }\n\n      for (; p && p.z <= h;) {\n        if (p !== e.prev && p !== e.next && pointInTriangle(a.x, a.y, i.x, i.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;\n        p = p.nextZ;\n      }\n\n      return !0;\n    }\n\n    function cureLocalIntersections(e, t, r) {\n      var n = e;\n\n      do {\n        var a = n.prev,\n            i = n.next.next;\n        !equals(a, i) && intersects(a, n, n.next, i) && locallyInside(a, i) && locallyInside(i, a) && (t.push(a.i / r), t.push(n.i / r), t.push(i.i / r), removeNode(n), removeNode(n.next), n = e = i), n = n.next;\n      } while (n !== e);\n\n      return n;\n    }\n\n    function splitEarcut(e, t, r, n, a, i) {\n      var o = e;\n\n      do {\n        for (var u = o.next.next; u !== o.prev;) {\n          if (o.i !== u.i && isValidDiagonal(o, u)) {\n            var s = splitPolygon(o, u);\n            return o = filterPoints(o, o.next), s = filterPoints(s, s.next), earcutLinked(o, t, r, n, a, i), void earcutLinked(s, t, r, n, a, i);\n          }\n\n          u = u.next;\n        }\n\n        o = o.next;\n      } while (o !== e);\n    }\n\n    function compareX(e, t) {\n      return e.x - t.x;\n    }\n\n    function eliminateHole(e, t) {\n      if (t = function findHoleBridge(e, t) {\n        var r,\n            n = t,\n            a = e.x,\n            i = e.y,\n            o = -1 / 0;\n\n        do {\n          if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {\n            var u = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n\n            if (u <= a && u > o) {\n              if (o = u, u === a) {\n                if (i === n.y) return n;\n                if (i === n.next.y) return n.next;\n              }\n\n              r = n.x < n.next.x ? n : n.next;\n            }\n          }\n\n          n = n.next;\n        } while (n !== t);\n\n        if (!r) return null;\n        if (a === o) return r.prev;\n        var s,\n            c = r,\n            l = r.x,\n            f = r.y,\n            h = 1 / 0;\n        n = r.next;\n\n        for (; n !== c;) a >= n.x && n.x >= l && a !== n.x && pointInTriangle(i < f ? a : o, i, l, f, i < f ? o : a, i, n.x, n.y) && ((s = Math.abs(i - n.y) / (a - n.x)) < h || s === h && n.x > r.x) && locallyInside(n, e) && (r = n, h = s), n = n.next;\n\n        return r;\n      }(e, t)) {\n        var r = splitPolygon(t, e);\n        filterPoints(r, r.next);\n      }\n    }\n\n    function zOrder(e, t, r, n, a) {\n      return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * a) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * a) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;\n    }\n\n    function getLeftmost(e) {\n      var t = e,\n          r = e;\n\n      do {\n        t.x < r.x && (r = t), t = t.next;\n      } while (t !== e);\n\n      return r;\n    }\n\n    function pointInTriangle(e, t, r, n, a, i, o, u) {\n      return (a - o) * (t - u) - (e - o) * (i - u) >= 0 && (e - o) * (n - u) - (r - o) * (t - u) >= 0 && (r - o) * (i - u) - (a - o) * (n - u) >= 0;\n    }\n\n    function isValidDiagonal(e, t) {\n      return e.next.i !== t.i && e.prev.i !== t.i && !function intersectsPolygon(e, t) {\n        var r = e;\n\n        do {\n          if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && intersects(r, r.next, e, t)) return !0;\n          r = r.next;\n        } while (r !== e);\n\n        return !1;\n      }(e, t) && locallyInside(e, t) && locallyInside(t, e) && function middleInside(e, t) {\n        var r = e,\n            n = !1,\n            a = (e.x + t.x) / 2,\n            i = (e.y + t.y) / 2;\n\n        do {\n          r.y > i != r.next.y > i && r.next.y !== r.y && a < (r.next.x - r.x) * (i - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== e);\n\n        return n;\n      }(e, t);\n    }\n\n    function area(e, t, r) {\n      return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y);\n    }\n\n    function equals(e, t) {\n      return e.x === t.x && e.y === t.y;\n    }\n\n    function intersects(e, t, r, n) {\n      return !!(equals(e, t) && equals(r, n) || equals(e, n) && equals(r, t)) || area(e, t, r) > 0 != area(e, t, n) > 0 && area(r, n, e) > 0 != area(r, n, t) > 0;\n    }\n\n    function locallyInside(e, t) {\n      return area(e.prev, e, e.next) < 0 ? area(e, t, e.next) >= 0 && area(e, e.prev, t) >= 0 : area(e, t, e.prev) < 0 || area(e, e.next, t) < 0;\n    }\n\n    function splitPolygon(e, t) {\n      var r = new Node(e.i, e.x, e.y),\n          n = new Node(t.i, t.x, t.y),\n          a = e.next,\n          i = t.prev;\n      return e.next = t, t.prev = e, r.next = a, a.prev = r, n.next = r, r.prev = n, i.next = n, n.prev = i, n;\n    }\n\n    function insertNode(e, t, r, n) {\n      var a = new Node(e, t, r);\n      return n ? (a.next = n.next, a.prev = n, n.next.prev = a, n.next = a) : (a.prev = a, a.next = a), a;\n    }\n\n    function removeNode(e) {\n      e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);\n    }\n\n    function Node(e, t, r) {\n      this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n\n    function signedArea(e, t, r, n) {\n      for (var a = 0, i = t, o = r - n; i < r; i += n) a += (e[o] - e[i]) * (e[i + 1] + e[o + 1]), o = i;\n\n      return a;\n    }\n\n    e.exports = earcut, e.exports.default = earcut, earcut.deviation = function (e, t, r, n) {\n      var a = t && t.length,\n          i = a ? t[0] * r : e.length,\n          o = Math.abs(signedArea(e, 0, i, r));\n      if (a) for (var u = 0, s = t.length; u < s; u++) {\n        var c = t[u] * r,\n            l = u < s - 1 ? t[u + 1] * r : e.length;\n        o -= Math.abs(signedArea(e, c, l, r));\n      }\n      var f = 0;\n\n      for (u = 0; u < n.length; u += 3) {\n        var h = n[u] * r,\n            d = n[u + 1] * r,\n            p = n[u + 2] * r;\n        f += Math.abs((e[h] - e[p]) * (e[d + 1] - e[h + 1]) - (e[h] - e[d]) * (e[p + 1] - e[h + 1]));\n      }\n\n      return 0 === o && 0 === f ? 0 : Math.abs((f - o) / o);\n    }, earcut.flatten = function (e) {\n      for (var t = e[0][0].length, r = {\n        vertices: [],\n        holes: [],\n        dimensions: t\n      }, n = 0, a = 0; a < e.length; a++) {\n        for (var i = 0; i < e[a].length; i++) for (var o = 0; o < t; o++) r.vertices.push(e[a][i][o]);\n\n        a > 0 && (n += e[a - 1].length, r.holes.push(n));\n      }\n\n      return r;\n    };\n  }, function (e, t, r) {\n    e.exports = function () {\n      return r(70)('/*!\\n * CARTO VL js https://carto.com/\\n * Version: 1.4.2\\n * \\n */!function(t){var e={};function __webpack_require__(r){if(e[r])return e[r].exports;var n=e[r]={i:r,l:!1,exports:{}};return t[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}__webpack_require__.m=t,__webpack_require__.c=e,__webpack_require__.d=function(t,e,r){__webpack_require__.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},__webpack_require__.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},__webpack_require__.t=function(t,e){if(1&e&&(t=__webpack_require__(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var n in t)__webpack_require__.d(r,n,function(e){return t[e]}.bind(null,n));return r},__webpack_require__.n=function(t){var e=t&&t.__esModule?function getDefault(){return t.default}:function getModuleExports(){return t};return __webpack_require__.d(e,\"a\",e),e},__webpack_require__.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},__webpack_require__.p=\"\",__webpack_require__(__webpack_require__.s=40)}([function(t,e){t.exports=function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}},function(t,e){function _getPrototypeOf(e){return t.exports=_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(e)}t.exports=_getPrototypeOf},function(t,e){function _defineProperties(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}t.exports=function _createClass(t,e,r){return e&&_defineProperties(t.prototype,e),r&&_defineProperties(t,r),t}},function(t,e,r){var n=r(7),a=r(33);t.exports=function _possibleConstructorReturn(t,e){return!e||\"object\"!==n(e)&&\"function\"!=typeof e?a(t):e}},function(t,e,r){var n=r(11);t.exports=function _inherits(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&n(t,e)}},function(t,e,r){var n=r(25),a=r(26),o=r(27);t.exports=function _slicedToArray(t,e){return n(t)||a(t,e)||o()}},function(t,e,r){var n=r(37),a=r(38),o=r(39);t.exports=function _toConsumableArray(t){return n(t)||a(t)||o()}},function(t,e){function _typeof2(t){return(_typeof2=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function _typeof2(t){return typeof t}:function _typeof2(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function _typeof(e){return\"function\"==typeof Symbol&&\"symbol\"===_typeof2(Symbol.iterator)?t.exports=_typeof=function _typeof(t){return _typeof2(t)}:t.exports=_typeof=function _typeof(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":_typeof2(t)},_typeof(e)}t.exports=_typeof},function(t,e,r){r(1);var n=r(36);function _get(e,r,a){return\"undefined\"!=typeof Reflect&&Reflect.get?t.exports=_get=Reflect.get:t.exports=_get=function _get(t,e,r){var a=n(t,e);if(a){var o=Object.getOwnPropertyDescriptor(a,e);return o.get?o.get.call(r):o.value}},_get(e,r,a||e)}t.exports=_get},function(t,e,r){t.exports=r(28)},function(t,e){function asyncGeneratorStep(t,e,r,n,a,o,i){try{var u=t[o](i),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,a)}t.exports=function _asyncToGenerator(t){return function(){var e=this,r=arguments;return new Promise(function(n,a){var o=t.apply(e,r);function _next(t){asyncGeneratorStep(o,n,a,_next,_throw,\"next\",t)}function _throw(t){asyncGeneratorStep(o,n,a,_next,_throw,\"throw\",t)}_next(void 0)})}}},function(t,e){function _setPrototypeOf(e,r){return t.exports=_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(t,e){return t.__proto__=e,t},_setPrototypeOf(e,r)}t.exports=_setPrototypeOf},function(t,e,r){\"use strict\";var n=r(13);function VectorTileLayer(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(readLayer,this,e),this.length=this._features.length}function readLayer(t,e,r){15===t?e.version=r.readVarint():1===t?e.name=r.readString():5===t?e.extent=r.readVarint():2===t?e._features.push(r.pos):3===t?e._keys.push(r.readString()):4===t&&e._values.push(function readValueMessage(t){var e=null,r=t.readVarint()+t.pos;for(;t.pos<r;){var n=t.readVarint()>>3;e=1===n?t.readString():2===n?t.readFloat():3===n?t.readDouble():4===n?t.readVarint64():5===n?t.readVarint():6===n?t.readSVarint():7===n?t.readBoolean():null}return e}(r))}t.exports=VectorTileLayer,VectorTileLayer.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error(\"feature index out of bounds\");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new n(this._pbf,e,this.extent,this._keys,this._values)}},function(t,e,r){\"use strict\";var n=r(31);function VectorTileFeature(t,e,r,n,a){this.properties={},this.extent=r,this.type=0,this._pbf=t,this._geometry=-1,this._keys=n,this._values=a,t.readFields(readFeature,this,e)}function readFeature(t,e,r){1==t?e.id=r.readVarint():2==t?function readTag(t,e){var r=t.readVarint()+t.pos;for(;t.pos<r;){var n=e._keys[t.readVarint()],a=e._values[t.readVarint()];e.properties[n]=a}}(r,e):3==t?e.type=r.readVarint():4==t&&(e._geometry=r.pos)}function signedArea(t){for(var e,r,n=0,a=0,o=t.length,i=o-1;a<o;i=a++)e=t[a],n+=((r=t[i]).x-e.x)*(e.y+r.y);return n}t.exports=VectorTileFeature,VectorTileFeature.types=[\"Unknown\",\"Point\",\"LineString\",\"Polygon\"],VectorTileFeature.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,r=t.readVarint()+t.pos,a=1,o=0,i=0,u=0,s=[];t.pos<r;){if(o<=0){var c=t.readVarint();a=7&c,o=c>>3}if(o--,1===a||2===a)i+=t.readSVarint(),u+=t.readSVarint(),1===a&&(e&&s.push(e),e=[]),e.push(new n(i,u));else{if(7!==a)throw new Error(\"unknown command \"+a);e&&e.push(e[0].clone())}}return e&&s.push(e),s},VectorTileFeature.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,r=1,n=0,a=0,o=0,i=1/0,u=-1/0,s=1/0,c=-1/0;t.pos<e;){if(n<=0){var f=t.readVarint();r=7&f,n=f>>3}if(n--,1===r||2===r)a+=t.readSVarint(),o+=t.readSVarint(),a<i&&(i=a),a>u&&(u=a),o<s&&(s=o),o>c&&(c=o);else if(7!==r)throw new Error(\"unknown command \"+r)}return[i,s,u,c]},VectorTileFeature.prototype.toGeoJSON=function(t,e,r){var n,a,o=this.extent*Math.pow(2,r),i=this.extent*t,u=this.extent*e,s=this.loadGeometry(),c=VectorTileFeature.types[this.type];function project(t){for(var e=0;e<t.length;e++){var r=t[e],n=180-360*(r.y+u)/o;t[e]=[360*(r.x+i)/o-180,360/Math.PI*Math.atan(Math.exp(n*Math.PI/180))-90]}}switch(this.type){case 1:var f=[];for(n=0;n<s.length;n++)f[n]=s[n][0];project(s=f);break;case 2:for(n=0;n<s.length;n++)project(s[n]);break;case 3:for(s=function classifyRings(t){var e=t.length;if(e<=1)return[t];for(var r,n,a=[],o=0;o<e;o++){var i=signedArea(t[o]);0!==i&&(void 0===n&&(n=i<0),n===i<0?(r&&a.push(r),r=[t[o]]):r.push(t[o]))}r&&a.push(r);return a}(s),n=0;n<s.length;n++)for(a=0;a<s[n].length;a++)project(s[n][a])}1===s.length?s=s[0]:c=\"Multi\"+c;var l={type:\"Feature\",geometry:{type:c,coordinates:s},properties:this.properties};return\"id\"in this&&(l.id=this.id),l}},function(t,e,r){t.exports.VectorTile=r(30),t.exports.VectorTileFeature=r(13),t.exports.VectorTileLayer=r(12)},function(t,e,r){\"use strict\";t.exports=Pbf;var n=r(32);function Pbf(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length}Pbf.Varint=0,Pbf.Fixed64=1,Pbf.Bytes=2,Pbf.Fixed32=5;function readPackedEnd(t){return t.type===Pbf.Bytes?t.readVarint()+t.pos:t.pos+1}function toNum(t,e,r){return r?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function makeRoomForExtraLength(t,e,r){var n=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.ceil(Math.log(e)/(7*Math.LN2));r.realloc(n);for(var a=r.pos-1;a>=t;a--)r.buf[a+n]=r.buf[a]}function writePackedVarint(t,e){for(var r=0;r<t.length;r++)e.writeVarint(t[r])}function writePackedSVarint(t,e){for(var r=0;r<t.length;r++)e.writeSVarint(t[r])}function writePackedFloat(t,e){for(var r=0;r<t.length;r++)e.writeFloat(t[r])}function writePackedDouble(t,e){for(var r=0;r<t.length;r++)e.writeDouble(t[r])}function writePackedBoolean(t,e){for(var r=0;r<t.length;r++)e.writeBoolean(t[r])}function writePackedFixed32(t,e){for(var r=0;r<t.length;r++)e.writeFixed32(t[r])}function writePackedSFixed32(t,e){for(var r=0;r<t.length;r++)e.writeSFixed32(t[r])}function writePackedFixed64(t,e){for(var r=0;r<t.length;r++)e.writeFixed64(t[r])}function writePackedSFixed64(t,e){for(var r=0;r<t.length;r++)e.writeSFixed64(t[r])}function readUInt32(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function writeInt32(t,e,r){t[r]=e,t[r+1]=e>>>8,t[r+2]=e>>>16,t[r+3]=e>>>24}function readInt32(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}Pbf.prototype={destroy:function(){this.buf=null},readFields:function(t,e,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),a=n>>3,o=this.pos;this.type=7&n,t(a,e,this),this.pos===o&&this.skip(n)}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=readUInt32(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=readInt32(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=readUInt32(this.buf,this.pos)+4294967296*readUInt32(this.buf,this.pos+4);return this.pos+=8,t},readSFixed64:function(){var t=readUInt32(this.buf,this.pos)+4294967296*readInt32(this.buf,this.pos+4);return this.pos+=8,t},readFloat:function(){var t=n.read(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=n.read(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,r,n=this.buf;return e=127&(r=n[this.pos++]),r<128?e:(e|=(127&(r=n[this.pos++]))<<7,r<128?e:(e|=(127&(r=n[this.pos++]))<<14,r<128?e:(e|=(127&(r=n[this.pos++]))<<21,r<128?e:function readVarintRemainder(t,e,r){var n,a,o=r.buf;if(a=o[r.pos++],n=(112&a)>>4,a<128)return toNum(t,n,e);if(a=o[r.pos++],n|=(127&a)<<3,a<128)return toNum(t,n,e);if(a=o[r.pos++],n|=(127&a)<<10,a<128)return toNum(t,n,e);if(a=o[r.pos++],n|=(127&a)<<17,a<128)return toNum(t,n,e);if(a=o[r.pos++],n|=(127&a)<<24,a<128)return toNum(t,n,e);if(a=o[r.pos++],n|=(1&a)<<31,a<128)return toNum(t,n,e);throw new Error(\"Expected varint not more than 10 bytes\")}(e|=(15&(r=n[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=function readUtf8(t,e,r){var n=\"\",a=e;for(;a<r;){var o,i,u,s=t[a],c=null,f=s>239?4:s>223?3:s>191?2:1;if(a+f>r)break;1===f?s<128&&(c=s):2===f?128==(192&(o=t[a+1]))&&(c=(31&s)<<6|63&o)<=127&&(c=null):3===f?(o=t[a+1],i=t[a+2],128==(192&o)&&128==(192&i)&&((c=(15&s)<<12|(63&o)<<6|63&i)<=2047||c>=55296&&c<=57343)&&(c=null)):4===f&&(o=t[a+1],i=t[a+2],u=t[a+3],128==(192&o)&&128==(192&i)&&128==(192&u)&&((c=(15&s)<<18|(63&o)<<12|(63&i)<<6|63&u)<=65535||c>=1114112)&&(c=null)),null===c?(c=65533,f=1):c>65535&&(c-=65536,n+=String.fromCharCode(c>>>10&1023|55296),c=56320|1023&c),n+=String.fromCharCode(c),a+=f}return n}(this.buf,this.pos,t);return this.pos=t,e},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){var r=readPackedEnd(this);for(t=t||[];this.pos<r;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){var e=readPackedEnd(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===Pbf.Varint)for(;this.buf[this.pos++]>127;);else if(e===Pbf.Bytes)this.pos=this.readVarint()+this.pos;else if(e===Pbf.Fixed32)this.pos+=4;else{if(e!==Pbf.Fixed64)throw new Error(\"Unimplemented type: \"+e);this.pos+=8}},writeTag:function(t,e){this.writeVarint(t<<3|e)},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var r=new Uint8Array(e);r.set(this.buf),this.buf=r,this.length=e}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),writeInt32(this.buf,t,this.pos),this.pos+=4},writeSFixed32:function(t){this.realloc(4),writeInt32(this.buf,t,this.pos),this.pos+=4},writeFixed64:function(t){this.realloc(8),writeInt32(this.buf,-1&t,this.pos),writeInt32(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8},writeSFixed64:function(t){this.realloc(8),writeInt32(this.buf,-1&t,this.pos),writeInt32(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8},writeVarint:function(t){(t=+t||0)>268435455||t<0?function writeBigVarint(t,e){var r,n;t>=0?(r=t%4294967296|0,n=t/4294967296|0):(n=~(-t/4294967296),4294967295^(r=~(-t%4294967296))?r=r+1|0:(r=0,n=n+1|0));if(t>=0x10000000000000000||t<-0x10000000000000000)throw new Error(\"Given varint doesn\\'t fit into 10 bytes\");e.realloc(10),function writeBigVarintLow(t,e,r){r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos++]=127&t|128,t>>>=7,r.buf[r.pos]=127&t}(r,0,e),function writeBigVarintHigh(t,e){var r=(7&t)<<4;if(e.buf[e.pos++]|=r|((t>>>=3)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;e.buf[e.pos++]=127&t}(n,e)}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))))},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t)},writeBoolean:function(t){this.writeVarint(Boolean(t))},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function writeUtf8(t,e,r){for(var n,a,o=0;o<e.length;o++){if((n=e.charCodeAt(o))>55295&&n<57344){if(!a){n>56319||o+1===e.length?(t[r++]=239,t[r++]=191,t[r++]=189):a=n;continue}if(n<56320){t[r++]=239,t[r++]=191,t[r++]=189,a=n;continue}n=a-55296<<10|n-56320|65536,a=null}else a&&(t[r++]=239,t[r++]=191,t[r++]=189,a=null);n<128?t[r++]=n:(n<2048?t[r++]=n>>6|192:(n<65536?t[r++]=n>>12|224:(t[r++]=n>>18|240,t[r++]=n>>12&63|128),t[r++]=n>>6&63|128),t[r++]=63&n|128)}return r}(this.buf,t,this.pos);var r=this.pos-e;r>=128&&makeRoomForExtraLength(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r},writeFloat:function(t){this.realloc(4),n.write(this.buf,t,this.pos,!0,23,4),this.pos+=4},writeDouble:function(t){this.realloc(8),n.write(this.buf,t,this.pos,!0,52,8),this.pos+=8},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var r=0;r<e;r++)this.buf[this.pos++]=t[r]},writeRawMessage:function(t,e){this.pos++;var r=this.pos;t(e,this);var n=this.pos-r;n>=128&&makeRoomForExtraLength(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n},writeMessage:function(t,e,r){this.writeTag(t,Pbf.Bytes),this.writeRawMessage(e,r)},writePackedVarint:function(t,e){this.writeMessage(t,writePackedVarint,e)},writePackedSVarint:function(t,e){this.writeMessage(t,writePackedSVarint,e)},writePackedBoolean:function(t,e){this.writeMessage(t,writePackedBoolean,e)},writePackedFloat:function(t,e){this.writeMessage(t,writePackedFloat,e)},writePackedDouble:function(t,e){this.writeMessage(t,writePackedDouble,e)},writePackedFixed32:function(t,e){this.writeMessage(t,writePackedFixed32,e)},writePackedSFixed32:function(t,e){this.writeMessage(t,writePackedSFixed32,e)},writePackedFixed64:function(t,e){this.writeMessage(t,writePackedFixed64,e)},writePackedSFixed64:function(t,e){this.writeMessage(t,writePackedSFixed64,e)},writeBytesField:function(t,e){this.writeTag(t,Pbf.Bytes),this.writeBytes(e)},writeFixed32Field:function(t,e){this.writeTag(t,Pbf.Fixed32),this.writeFixed32(e)},writeSFixed32Field:function(t,e){this.writeTag(t,Pbf.Fixed32),this.writeSFixed32(e)},writeFixed64Field:function(t,e){this.writeTag(t,Pbf.Fixed64),this.writeFixed64(e)},writeSFixed64Field:function(t,e){this.writeTag(t,Pbf.Fixed64),this.writeSFixed64(e)},writeVarintField:function(t,e){this.writeTag(t,Pbf.Varint),this.writeVarint(e)},writeSVarintField:function(t,e){this.writeTag(t,Pbf.Varint),this.writeSVarint(e)},writeStringField:function(t,e){this.writeTag(t,Pbf.Bytes),this.writeString(e)},writeFloatField:function(t,e){this.writeTag(t,Pbf.Fixed32),this.writeFloat(e)},writeDoubleField:function(t,e){this.writeTag(t,Pbf.Fixed64),this.writeDouble(e)},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e))}}},function(t,e,r){var n=r(1),a=r(11),o=r(34),i=r(35);function _wrapNativeSuper(e){var r=\"function\"==typeof Map?new Map:void 0;return t.exports=_wrapNativeSuper=function _wrapNativeSuper(t){if(null===t||!o(t))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return i(t,arguments,n(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),a(Wrapper,t)},_wrapNativeSuper(e)}t.exports=_wrapNativeSuper},function(t,e,r){\"use strict\";function earcut(t,e,r){r=r||2;var n,a,o,i,u,s,c,f=e&&e.length,l=f?e[0]*r:t.length,h=linkedList(t,0,l,r,!0),d=[];if(!h)return d;if(f&&(h=function eliminateHoles(t,e,r,n){var a,o,i,u,s,c=[];for(a=0,o=e.length;a<o;a++)i=e[a]*n,u=a<o-1?e[a+1]*n:t.length,(s=linkedList(t,i,u,n,!1))===s.next&&(s.steiner=!0),c.push(getLeftmost(s));for(c.sort(compareX),a=0;a<c.length;a++)eliminateHole(c[a],r),r=filterPoints(r,r.next);return r}(t,e,h,r)),t.length>80*r){n=o=t[0],a=i=t[1];for(var p=r;p<l;p+=r)u=t[p],s=t[p+1],u<n&&(n=u),s<a&&(a=s),u>o&&(o=u),s>i&&(i=s);c=0!==(c=Math.max(o-n,i-a))?1/c:0}return earcutLinked(h,d,r,n,a,c),d}function linkedList(t,e,r,n,a){var o,i;if(a===signedArea(t,e,r,n)>0)for(o=e;o<r;o+=n)i=insertNode(o,t[o],t[o+1],i);else for(o=r-n;o>=e;o-=n)i=insertNode(o,t[o],t[o+1],i);return i&&equals(i,i.next)&&(removeNode(i),i=i.next),i}function filterPoints(t,e){if(!t)return t;e||(e=t);var r,n=t;do{if(r=!1,n.steiner||!equals(n,n.next)&&0!==area(n.prev,n,n.next))n=n.next;else{if(removeNode(n),(n=e=n.prev)===n.next)break;r=!0}}while(r||n!==e);return e}function earcutLinked(t,e,r,n,a,o,i){if(t){!i&&o&&function indexCurve(t,e,r,n){var a=t;do{null===a.z&&(a.z=zOrder(a.x,a.y,e,r,n)),a.prevZ=a.prev,a.nextZ=a.next,a=a.next}while(a!==t);a.prevZ.nextZ=null,a.prevZ=null,function sortLinked(t){var e,r,n,a,o,i,u,s,c=1;do{for(r=t,t=null,o=null,i=0;r;){for(i++,n=r,u=0,e=0;e<c&&(u++,n=n.nextZ);e++);for(s=c;u>0||s>0&&n;)0!==u&&(0===s||!n||r.z<=n.z)?(a=r,r=r.nextZ,u--):(a=n,n=n.nextZ,s--),o?o.nextZ=a:t=a,a.prevZ=o,o=a;r=n}o.nextZ=null,c*=2}while(i>1);return t}(a)}(t,n,a,o);for(var u,s,c=t;t.prev!==t.next;)if(u=t.prev,s=t.next,o?isEarHashed(t,n,a,o):isEar(t))e.push(u.i/r),e.push(t.i/r),e.push(s.i/r),removeNode(t),t=s.next,c=s.next;else if((t=s)===c){i?1===i?earcutLinked(t=cureLocalIntersections(t,e,r),e,r,n,a,o,2):2===i&&splitEarcut(t,e,r,n,a,o):earcutLinked(filterPoints(t),e,r,n,a,o,1);break}}}function isEar(t){var e=t.prev,r=t,n=t.next;if(area(e,r,n)>=0)return!1;for(var a=t.next.next;a!==t.prev;){if(pointInTriangle(e.x,e.y,r.x,r.y,n.x,n.y,a.x,a.y)&&area(a.prev,a,a.next)>=0)return!1;a=a.next}return!0}function isEarHashed(t,e,r,n){var a=t.prev,o=t,i=t.next;if(area(a,o,i)>=0)return!1;for(var u=a.x<o.x?a.x<i.x?a.x:i.x:o.x<i.x?o.x:i.x,s=a.y<o.y?a.y<i.y?a.y:i.y:o.y<i.y?o.y:i.y,c=a.x>o.x?a.x>i.x?a.x:i.x:o.x>i.x?o.x:i.x,f=a.y>o.y?a.y>i.y?a.y:i.y:o.y>i.y?o.y:i.y,l=zOrder(u,s,e,r,n),h=zOrder(c,f,e,r,n),d=t.prevZ,p=t.nextZ;d&&d.z>=l&&p&&p.z<=h;){if(d!==t.prev&&d!==t.next&&pointInTriangle(a.x,a.y,o.x,o.y,i.x,i.y,d.x,d.y)&&area(d.prev,d,d.next)>=0)return!1;if(d=d.prevZ,p!==t.prev&&p!==t.next&&pointInTriangle(a.x,a.y,o.x,o.y,i.x,i.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(;d&&d.z>=l;){if(d!==t.prev&&d!==t.next&&pointInTriangle(a.x,a.y,o.x,o.y,i.x,i.y,d.x,d.y)&&area(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;p&&p.z<=h;){if(p!==t.prev&&p!==t.next&&pointInTriangle(a.x,a.y,o.x,o.y,i.x,i.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function cureLocalIntersections(t,e,r){var n=t;do{var a=n.prev,o=n.next.next;!equals(a,o)&&intersects(a,n,n.next,o)&&locallyInside(a,o)&&locallyInside(o,a)&&(e.push(a.i/r),e.push(n.i/r),e.push(o.i/r),removeNode(n),removeNode(n.next),n=t=o),n=n.next}while(n!==t);return n}function splitEarcut(t,e,r,n,a,o){var i=t;do{for(var u=i.next.next;u!==i.prev;){if(i.i!==u.i&&isValidDiagonal(i,u)){var s=splitPolygon(i,u);return i=filterPoints(i,i.next),s=filterPoints(s,s.next),earcutLinked(i,e,r,n,a,o),void earcutLinked(s,e,r,n,a,o)}u=u.next}i=i.next}while(i!==t)}function compareX(t,e){return t.x-e.x}function eliminateHole(t,e){if(e=function findHoleBridge(t,e){var r,n=e,a=t.x,o=t.y,i=-1/0;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){var u=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(u<=a&&u>i){if(i=u,u===a){if(o===n.y)return n;if(o===n.next.y)return n.next}r=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!r)return null;if(a===i)return r.prev;var s,c=r,f=r.x,l=r.y,h=1/0;n=r.next;for(;n!==c;)a>=n.x&&n.x>=f&&a!==n.x&&pointInTriangle(o<l?a:i,o,f,l,o<l?i:a,o,n.x,n.y)&&((s=Math.abs(o-n.y)/(a-n.x))<h||s===h&&n.x>r.x)&&locallyInside(n,t)&&(r=n,h=s),n=n.next;return r}(t,e)){var r=splitPolygon(e,t);filterPoints(r,r.next)}}function zOrder(t,e,r,n,a){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*a)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*a)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function getLeftmost(t){var e=t,r=t;do{e.x<r.x&&(r=e),e=e.next}while(e!==t);return r}function pointInTriangle(t,e,r,n,a,o,i,u){return(a-i)*(e-u)-(t-i)*(o-u)>=0&&(t-i)*(n-u)-(r-i)*(e-u)>=0&&(r-i)*(o-u)-(a-i)*(n-u)>=0}function isValidDiagonal(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function intersectsPolygon(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&intersects(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}(t,e)&&locallyInside(t,e)&&locallyInside(e,t)&&function middleInside(t,e){var r=t,n=!1,a=(t.x+e.x)/2,o=(t.y+e.y)/2;do{r.y>o!=r.next.y>o&&r.next.y!==r.y&&a<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next}while(r!==t);return n}(t,e)}function area(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function equals(t,e){return t.x===e.x&&t.y===e.y}function intersects(t,e,r,n){return!!(equals(t,e)&&equals(r,n)||equals(t,n)&&equals(r,e))||area(t,e,r)>0!=area(t,e,n)>0&&area(r,n,t)>0!=area(r,n,e)>0}function locallyInside(t,e){return area(t.prev,t,t.next)<0?area(t,e,t.next)>=0&&area(t,t.prev,e)>=0:area(t,e,t.prev)<0||area(t,t.next,e)<0}function splitPolygon(t,e){var r=new Node(t.i,t.x,t.y),n=new Node(e.i,e.x,e.y),a=t.next,o=e.prev;return t.next=e,e.prev=t,r.next=a,a.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function insertNode(t,e,r,n){var a=new Node(t,e,r);return n?(a.next=n.next,a.prev=n,n.next.prev=a,n.next=a):(a.prev=a,a.next=a),a}function removeNode(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Node(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(t,e,r,n){for(var a=0,o=e,i=r-n;o<r;o+=n)a+=(t[i]-t[o])*(t[o+1]+t[i+1]),i=o;return a}t.exports=earcut,t.exports.default=earcut,earcut.deviation=function(t,e,r,n){var a=e&&e.length,o=a?e[0]*r:t.length,i=Math.abs(signedArea(t,0,o,r));if(a)for(var u=0,s=e.length;u<s;u++){var c=e[u]*r,f=u<s-1?e[u+1]*r:t.length;i-=Math.abs(signedArea(t,c,f,r))}var l=0;for(u=0;u<n.length;u+=3){var h=n[u]*r,d=n[u+1]*r,p=n[u+2]*r;l+=Math.abs((t[h]-t[p])*(t[d+1]-t[h+1])-(t[h]-t[d])*(t[p+1]-t[h+1]))}return 0===i&&0===l?0:Math.abs((l-i)/i)},earcut.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},n=0,a=0;a<t.length;a++){for(var o=0;o<t[a].length;o++)for(var i=0;i<e;i++)r.vertices.push(t[a][o][i]);a>0&&(n+=t[a-1].length,r.holes.push(n))}return r}},,,,,,,,function(t,e){t.exports=function _arrayWithHoles(t){if(Array.isArray(t))return t}},function(t,e){t.exports=function _iterableToArrayLimit(t,e){var r=[],n=!0,a=!1,o=void 0;try{for(var i,u=t[Symbol.iterator]();!(n=(i=u.next()).done)&&(r.push(i.value),!e||r.length!==e);n=!0);}catch(t){a=!0,o=t}finally{try{n||null==u.return||u.return()}finally{if(a)throw o}}return r}},function(t,e){t.exports=function _nonIterableRest(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}},function(t,e,r){var n=function(){return this||\"object\"==typeof self&&self}()||Function(\"return this\")(),a=n.regeneratorRuntime&&Object.getOwnPropertyNames(n).indexOf(\"regeneratorRuntime\")>=0,o=a&&n.regeneratorRuntime;if(n.regeneratorRuntime=void 0,t.exports=r(29),a)n.regeneratorRuntime=o;else try{delete n.regeneratorRuntime}catch(t){n.regeneratorRuntime=void 0}},function(t,e){!function(e){\"use strict\";var r,n=Object.prototype,a=n.hasOwnProperty,o=\"function\"==typeof Symbol?Symbol:{},i=o.iterator||\"@@iterator\",u=o.asyncIterator||\"@@asyncIterator\",s=o.toStringTag||\"@@toStringTag\",c=\"object\"==typeof t,f=e.regeneratorRuntime;if(f)c&&(t.exports=f);else{(f=e.regeneratorRuntime=c?t.exports:{}).wrap=wrap;var l=\"suspendedStart\",h=\"suspendedYield\",d=\"executing\",p=\"completed\",y={},v={};v[i]=function(){return this};var m=Object.getPrototypeOf,g=m&&m(m(values([])));g&&g!==n&&a.call(g,i)&&(v=g);var x=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(v);GeneratorFunction.prototype=x.constructor=GeneratorFunctionPrototype,GeneratorFunctionPrototype.constructor=GeneratorFunction,GeneratorFunctionPrototype[s]=GeneratorFunction.displayName=\"GeneratorFunction\",f.isGeneratorFunction=function(t){var e=\"function\"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||\"GeneratorFunction\"===(e.displayName||e.name))},f.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,s in t||(t[s]=\"GeneratorFunction\")),t.prototype=Object.create(x),t},f.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),AsyncIterator.prototype[u]=function(){return this},f.AsyncIterator=AsyncIterator,f.async=function(t,e,r,n){var a=new AsyncIterator(wrap(t,e,r,n));return f.isGeneratorFunction(e)?a:a.next().then(function(t){return t.done?t.value:a.next()})},defineIteratorMethods(x),x[s]=\"Generator\",x[i]=function(){return this},x.toString=function(){return\"[object Generator]\"},f.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function next(){for(;e.length;){var r=e.pop();if(r in t)return next.value=r,next.done=!1,next}return next.done=!0,next}},f.values=values,Context.prototype={constructor:Context,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method=\"next\",this.arg=r,this.tryEntries.forEach(resetTryEntry),!t)for(var e in this)\"t\"===e.charAt(0)&&a.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if(\"throw\"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function handle(n,a){return i.type=\"throw\",i.arg=t,e.next=n,a&&(e.method=\"next\",e.arg=r),!!a}for(var n=this.tryEntries.length-1;n>=0;--n){var o=this.tryEntries[n],i=o.completion;if(\"root\"===o.tryLoc)return handle(\"end\");if(o.tryLoc<=this.prev){var u=a.call(o,\"catchLoc\"),s=a.call(o,\"finallyLoc\");if(u&&s){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0);if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}else if(u){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0)}else{if(!s)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&a.call(n,\"finallyLoc\")&&this.prev<n.finallyLoc){var o=n;break}}o&&(\"break\"===t||\"continue\"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=t,i.arg=e,o?(this.method=\"next\",this.next=o.finallyLoc,y):this.complete(i)},complete:function(t,e){if(\"throw\"===t.type)throw t.arg;return\"break\"===t.type||\"continue\"===t.type?this.next=t.arg:\"return\"===t.type?(this.rval=this.arg=t.arg,this.method=\"return\",this.next=\"end\"):\"normal\"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if(\"throw\"===n.type){var a=n.arg;resetTryEntry(r)}return a}}throw new Error(\"illegal catch attempt\")},delegateYield:function(t,e,n){return this.delegate={iterator:values(t),resultName:e,nextLoc:n},\"next\"===this.method&&(this.arg=r),y}}}function wrap(t,e,r,n){var a=e&&e.prototype instanceof Generator?e:Generator,o=Object.create(a.prototype),i=new Context(n||[]);return o._invoke=function makeInvokeMethod(t,e,r){var n=l;return function invoke(a,o){if(n===d)throw new Error(\"Generator is already running\");if(n===p){if(\"throw\"===a)throw o;return doneResult()}for(r.method=a,r.arg=o;;){var i=r.delegate;if(i){var u=maybeInvokeDelegate(i,r);if(u){if(u===y)continue;return u}}if(\"next\"===r.method)r.sent=r._sent=r.arg;else if(\"throw\"===r.method){if(n===l)throw n=p,r.arg;r.dispatchException(r.arg)}else\"return\"===r.method&&r.abrupt(\"return\",r.arg);n=d;var s=tryCatch(t,e,r);if(\"normal\"===s.type){if(n=r.done?p:h,s.arg===y)continue;return{value:s.arg,done:r.done}}\"throw\"===s.type&&(n=p,r.method=\"throw\",r.arg=s.arg)}}}(t,r,i),o}function tryCatch(t,e,r){try{return{type:\"normal\",arg:t.call(e,r)}}catch(t){return{type:\"throw\",arg:t}}}function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}function defineIteratorMethods(t){[\"next\",\"throw\",\"return\"].forEach(function(e){t[e]=function(t){return this._invoke(e,t)}})}function AsyncIterator(t){var e;this._invoke=function enqueue(r,n){function callInvokeWithMethodAndArg(){return new Promise(function(e,o){!function invoke(e,r,n,o){var i=tryCatch(t[e],t,r);if(\"throw\"!==i.type){var u=i.arg,s=u.value;return s&&\"object\"==typeof s&&a.call(s,\"__await\")?Promise.resolve(s.__await).then(function(t){invoke(\"next\",t,n,o)},function(t){invoke(\"throw\",t,n,o)}):Promise.resolve(s).then(function(t){u.value=t,n(u)},function(t){return invoke(\"throw\",t,n,o)})}o(i.arg)}(r,n,e,o)})}return e=e?e.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}}function maybeInvokeDelegate(t,e){var n=t.iterator[e.method];if(n===r){if(e.delegate=null,\"throw\"===e.method){if(t.iterator.return&&(e.method=\"return\",e.arg=r,maybeInvokeDelegate(t,e),\"throw\"===e.method))return y;e.method=\"throw\",e.arg=new TypeError(\"The iterator does not provide a \\'throw\\' method\")}return y}var a=tryCatch(n,t.iterator,e.arg);if(\"throw\"===a.type)return e.method=\"throw\",e.arg=a.arg,e.delegate=null,y;var o=a.arg;return o?o.done?(e[t.resultName]=o.value,e.next=t.nextLoc,\"return\"!==e.method&&(e.method=\"next\",e.arg=r),e.delegate=null,y):o:(e.method=\"throw\",e.arg=new TypeError(\"iterator result is not an object\"),e.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type=\"normal\",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:\"root\"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(t){if(t){var e=t[i];if(e)return e.call(t);if(\"function\"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,o=function next(){for(;++n<t.length;)if(a.call(t,n))return next.value=t[n],next.done=!1,next;return next.value=r,next.done=!0,next};return o.next=o}}return{next:doneResult}}function doneResult(){return{value:r,done:!0}}}(function(){return this||\"object\"==typeof self&&self}()||Function(\"return this\")())},function(t,e,r){\"use strict\";var n=r(12);function readTile(t,e,r){if(3===t){var a=new n(r,r.readVarint()+r.pos);a.length&&(e[a.name]=a)}}t.exports=function VectorTile(t,e){this.layers=t.readFields(readTile,{},e)}},function(t,e,r){\"use strict\";function Point(t,e){this.x=t,this.y=e}t.exports=Point,Point.prototype={clone:function(){return new Point(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,r=t.y-this.y;return e*e+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[0]*this.x+t[1]*this.y,r=t[2]*this.x+t[3]*this.y;return this.x=e,this.y=r,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),r=Math.sin(t),n=e*this.x-r*this.y,a=r*this.x+e*this.y;return this.x=n,this.y=a,this},_rotateAround:function(t,e){var r=Math.cos(t),n=Math.sin(t),a=e.x+r*(this.x-e.x)-n*(this.y-e.y),o=e.y+n*(this.x-e.x)+r*(this.y-e.y);return this.x=a,this.y=o,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},Point.convert=function(t){return t instanceof Point?t:Array.isArray(t)?new Point(t[0],t[1]):t}},function(t,e){e.read=function(t,e,r,n,a){var o,i,u=8*a-n-1,s=(1<<u)-1,c=s>>1,f=-7,l=r?a-1:0,h=r?-1:1,d=t[e+l];for(l+=h,o=d&(1<<-f)-1,d>>=-f,f+=u;f>0;o=256*o+t[e+l],l+=h,f-=8);for(i=o&(1<<-f)-1,o>>=-f,f+=n;f>0;i=256*i+t[e+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===s)return i?NaN:1/0*(d?-1:1);i+=Math.pow(2,n),o-=c}return(d?-1:1)*i*Math.pow(2,o-n)},e.write=function(t,e,r,n,a,o){var i,u,s,c=8*o-a-1,f=(1<<c)-1,l=f>>1,h=23===a?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,p=n?1:-1,y=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(u=isNaN(e)?1:0,i=f):(i=Math.floor(Math.log(e)/Math.LN2),e*(s=Math.pow(2,-i))<1&&(i--,s*=2),(e+=i+l>=1?h/s:h*Math.pow(2,1-l))*s>=2&&(i++,s/=2),i+l>=f?(u=0,i=f):i+l>=1?(u=(e*s-1)*Math.pow(2,a),i+=l):(u=e*Math.pow(2,l-1)*Math.pow(2,a),i=0));a>=8;t[r+d]=255&u,d+=p,u/=256,a-=8);for(i=i<<a|u,c+=a;c>0;t[r+d]=255&i,d+=p,i/=256,c-=8);t[r+d-p]|=128*y}},function(t,e){t.exports=function _assertThisInitialized(t){if(void 0===t)throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\");return t}},function(t,e){t.exports=function _isNativeFunction(t){return-1!==Function.toString.call(t).indexOf(\"[native code]\")}},function(t,e,r){var n=r(11);function _construct(e,r,a){return!function isNativeReflectConstruct(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}()?t.exports=_construct=function _construct(t,e,r){var a=[null];a.push.apply(a,e);var o=new(Function.bind.apply(t,a));return r&&n(o,r.prototype),o}:t.exports=_construct=Reflect.construct,_construct.apply(null,arguments)}t.exports=_construct},function(t,e,r){var n=r(1);t.exports=function _superPropBase(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=n(t)););return t}},function(t,e){t.exports=function _arrayWithoutHoles(t){if(Array.isArray(t)){for(var e=0,r=new Array(t.length);e<t.length;e++)r[e]=t[e];return r}}},function(t,e){t.exports=function _iterableToArray(t){if(Symbol.iterator in Object(t)||\"[object Arguments]\"===Object.prototype.toString.call(t))return Array.from(t)}},function(t,e){t.exports=function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance\")}},function(t,e,r){\"use strict\";r.r(e);var n={};r.r(n),r.d(n,\"create\",function(){return create}),r.d(n,\"clone\",function(){return clone}),r.d(n,\"copy\",function(){return copy}),r.d(n,\"fromValues\",function(){return fromValues}),r.d(n,\"set\",function(){return set}),r.d(n,\"identity\",function(){return identity}),r.d(n,\"transpose\",function(){return transpose}),r.d(n,\"invert\",function(){return invert}),r.d(n,\"adjoint\",function(){return adjoint}),r.d(n,\"determinant\",function(){return determinant}),r.d(n,\"multiply\",function(){return multiply}),r.d(n,\"translate\",function(){return translate}),r.d(n,\"scale\",function(){return mat4_scale}),r.d(n,\"rotate\",function(){return rotate}),r.d(n,\"rotateX\",function(){return rotateX}),r.d(n,\"rotateY\",function(){return rotateY}),r.d(n,\"rotateZ\",function(){return rotateZ}),r.d(n,\"fromTranslation\",function(){return fromTranslation}),r.d(n,\"fromScaling\",function(){return fromScaling}),r.d(n,\"fromRotation\",function(){return fromRotation}),r.d(n,\"fromXRotation\",function(){return fromXRotation}),r.d(n,\"fromYRotation\",function(){return fromYRotation}),r.d(n,\"fromZRotation\",function(){return fromZRotation}),r.d(n,\"fromRotationTranslation\",function(){return fromRotationTranslation}),r.d(n,\"fromQuat2\",function(){return fromQuat2}),r.d(n,\"getTranslation\",function(){return getTranslation}),r.d(n,\"getScaling\",function(){return getScaling}),r.d(n,\"getRotation\",function(){return getRotation}),r.d(n,\"fromRotationTranslationScale\",function(){return fromRotationTranslationScale}),r.d(n,\"fromRotationTranslationScaleOrigin\",function(){return fromRotationTranslationScaleOrigin}),r.d(n,\"fromQuat\",function(){return fromQuat}),r.d(n,\"frustum\",function(){return frustum}),r.d(n,\"perspective\",function(){return perspective}),r.d(n,\"perspectiveFromFieldOfView\",function(){return perspectiveFromFieldOfView}),r.d(n,\"ortho\",function(){return ortho}),r.d(n,\"lookAt\",function(){return lookAt}),r.d(n,\"targetTo\",function(){return targetTo}),r.d(n,\"str\",function(){return str}),r.d(n,\"frob\",function(){return frob}),r.d(n,\"add\",function(){return add}),r.d(n,\"subtract\",function(){return subtract}),r.d(n,\"multiplyScalar\",function(){return multiplyScalar}),r.d(n,\"multiplyScalarAndAdd\",function(){return multiplyScalarAndAdd}),r.d(n,\"exactEquals\",function(){return exactEquals}),r.d(n,\"equals\",function(){return mat4_equals}),r.d(n,\"mul\",function(){return b}),r.d(n,\"sub\",function(){return M});var a={};r.r(a),r.d(a,\"create\",function(){return vec4_create}),r.d(a,\"clone\",function(){return vec4_clone}),r.d(a,\"fromValues\",function(){return vec4_fromValues}),r.d(a,\"copy\",function(){return vec4_copy}),r.d(a,\"set\",function(){return vec4_set}),r.d(a,\"add\",function(){return vec4_add}),r.d(a,\"subtract\",function(){return vec4_subtract}),r.d(a,\"multiply\",function(){return vec4_multiply}),r.d(a,\"divide\",function(){return divide}),r.d(a,\"ceil\",function(){return ceil}),r.d(a,\"floor\",function(){return floor}),r.d(a,\"min\",function(){return vec4_min}),r.d(a,\"max\",function(){return vec4_max}),r.d(a,\"round\",function(){return round}),r.d(a,\"scale\",function(){return vec4_scale}),r.d(a,\"scaleAndAdd\",function(){return scaleAndAdd}),r.d(a,\"distance\",function(){return distance}),r.d(a,\"squaredDistance\",function(){return squaredDistance}),r.d(a,\"length\",function(){return vec4_length}),r.d(a,\"squaredLength\",function(){return squaredLength}),r.d(a,\"negate\",function(){return negate}),r.d(a,\"inverse\",function(){return inverse}),r.d(a,\"normalize\",function(){return normalize}),r.d(a,\"dot\",function(){return dot}),r.d(a,\"lerp\",function(){return lerp}),r.d(a,\"random\",function(){return random}),r.d(a,\"transformMat4\",function(){return transformMat4}),r.d(a,\"transformQuat\",function(){return transformQuat}),r.d(a,\"str\",function(){return vec4_str}),r.d(a,\"exactEquals\",function(){return vec4_exactEquals}),r.d(a,\"equals\",function(){return vec4_equals}),r.d(a,\"sub\",function(){return T}),r.d(a,\"mul\",function(){return P}),r.d(a,\"div\",function(){return k}),r.d(a,\"dist\",function(){return I}),r.d(a,\"sqrDist\",function(){return F}),r.d(a,\"len\",function(){return E}),r.d(a,\"sqrLen\",function(){return C}),r.d(a,\"forEach\",function(){return N});var o=r(5),i=r.n(o),u=r(9),s=r.n(u),c=r(10),f=r.n(c),l=r(0),h=r.n(l),d=r(2),p=r.n(d),y=r(14),v=r(15);function getRsysFromTile(t,e,r){return{center:{x:(t+.5)/Math.pow(2,r)*2-1,y:2*(1-(e+.5)/Math.pow(2,r))-1},scale:1/Math.pow(2,r)}}var m=r(6),g=r.n(m),x=1e-6,_=\"undefined\"!=typeof Float32Array?Float32Array:Array,w=Math.random;Math.PI;function create(){var t=new _(16);return _!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function clone(t){var e=new _(16);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function fromValues(t,e,r,n,a,o,i,u,s,c,f,l,h,d,p,y){var v=new _(16);return v[0]=t,v[1]=e,v[2]=r,v[3]=n,v[4]=a,v[5]=o,v[6]=i,v[7]=u,v[8]=s,v[9]=c,v[10]=f,v[11]=l,v[12]=h,v[13]=d,v[14]=p,v[15]=y,v}function set(t,e,r,n,a,o,i,u,s,c,f,l,h,d,p,y,v){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t[4]=o,t[5]=i,t[6]=u,t[7]=s,t[8]=c,t[9]=f,t[10]=l,t[11]=h,t[12]=d,t[13]=p,t[14]=y,t[15]=v,t}function identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function transpose(t,e){if(t===e){var r=e[1],n=e[2],a=e[3],o=e[6],i=e[7],u=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=r,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=o,t[11]=e[14],t[12]=a,t[13]=i,t[14]=u}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function invert(t,e){var r=e[0],n=e[1],a=e[2],o=e[3],i=e[4],u=e[5],s=e[6],c=e[7],f=e[8],l=e[9],h=e[10],d=e[11],p=e[12],y=e[13],v=e[14],m=e[15],g=r*u-n*i,x=r*s-a*i,_=r*c-o*i,w=n*s-a*u,b=n*c-o*u,M=a*c-o*s,T=f*y-l*p,P=f*v-h*p,k=f*m-d*p,I=l*v-h*y,F=l*m-d*y,E=h*m-d*v,C=g*E-x*F+_*I+w*k-b*P+M*T;return C?(C=1/C,t[0]=(u*E-s*F+c*I)*C,t[1]=(a*F-n*E-o*I)*C,t[2]=(y*M-v*b+m*w)*C,t[3]=(h*b-l*M-d*w)*C,t[4]=(s*k-i*E-c*P)*C,t[5]=(r*E-a*k+o*P)*C,t[6]=(v*_-p*M-m*x)*C,t[7]=(f*M-h*_+d*x)*C,t[8]=(i*F-u*k+c*T)*C,t[9]=(n*k-r*F-o*T)*C,t[10]=(p*b-y*_+m*g)*C,t[11]=(l*_-f*b-d*g)*C,t[12]=(u*P-i*I-s*T)*C,t[13]=(r*I-n*P+a*T)*C,t[14]=(y*x-p*w-v*g)*C,t[15]=(f*w-l*x+h*g)*C,t):null}function adjoint(t,e){var r=e[0],n=e[1],a=e[2],o=e[3],i=e[4],u=e[5],s=e[6],c=e[7],f=e[8],l=e[9],h=e[10],d=e[11],p=e[12],y=e[13],v=e[14],m=e[15];return t[0]=u*(h*m-d*v)-l*(s*m-c*v)+y*(s*d-c*h),t[1]=-(n*(h*m-d*v)-l*(a*m-o*v)+y*(a*d-o*h)),t[2]=n*(s*m-c*v)-u*(a*m-o*v)+y*(a*c-o*s),t[3]=-(n*(s*d-c*h)-u*(a*d-o*h)+l*(a*c-o*s)),t[4]=-(i*(h*m-d*v)-f*(s*m-c*v)+p*(s*d-c*h)),t[5]=r*(h*m-d*v)-f*(a*m-o*v)+p*(a*d-o*h),t[6]=-(r*(s*m-c*v)-i*(a*m-o*v)+p*(a*c-o*s)),t[7]=r*(s*d-c*h)-i*(a*d-o*h)+f*(a*c-o*s),t[8]=i*(l*m-d*y)-f*(u*m-c*y)+p*(u*d-c*l),t[9]=-(r*(l*m-d*y)-f*(n*m-o*y)+p*(n*d-o*l)),t[10]=r*(u*m-c*y)-i*(n*m-o*y)+p*(n*c-o*u),t[11]=-(r*(u*d-c*l)-i*(n*d-o*l)+f*(n*c-o*u)),t[12]=-(i*(l*v-h*y)-f*(u*v-s*y)+p*(u*h-s*l)),t[13]=r*(l*v-h*y)-f*(n*v-a*y)+p*(n*h-a*l),t[14]=-(r*(u*v-s*y)-i*(n*v-a*y)+p*(n*s-a*u)),t[15]=r*(u*h-s*l)-i*(n*h-a*l)+f*(n*s-a*u),t}function determinant(t){var e=t[0],r=t[1],n=t[2],a=t[3],o=t[4],i=t[5],u=t[6],s=t[7],c=t[8],f=t[9],l=t[10],h=t[11],d=t[12],p=t[13],y=t[14],v=t[15];return(e*i-r*o)*(l*v-h*y)-(e*u-n*o)*(f*v-h*p)+(e*s-a*o)*(f*y-l*p)+(r*u-n*i)*(c*v-h*d)-(r*s-a*i)*(c*y-l*d)+(n*s-a*u)*(c*p-f*d)}function multiply(t,e,r){var n=e[0],a=e[1],o=e[2],i=e[3],u=e[4],s=e[5],c=e[6],f=e[7],l=e[8],h=e[9],d=e[10],p=e[11],y=e[12],v=e[13],m=e[14],g=e[15],x=r[0],_=r[1],w=r[2],b=r[3];return t[0]=x*n+_*u+w*l+b*y,t[1]=x*a+_*s+w*h+b*v,t[2]=x*o+_*c+w*d+b*m,t[3]=x*i+_*f+w*p+b*g,x=r[4],_=r[5],w=r[6],b=r[7],t[4]=x*n+_*u+w*l+b*y,t[5]=x*a+_*s+w*h+b*v,t[6]=x*o+_*c+w*d+b*m,t[7]=x*i+_*f+w*p+b*g,x=r[8],_=r[9],w=r[10],b=r[11],t[8]=x*n+_*u+w*l+b*y,t[9]=x*a+_*s+w*h+b*v,t[10]=x*o+_*c+w*d+b*m,t[11]=x*i+_*f+w*p+b*g,x=r[12],_=r[13],w=r[14],b=r[15],t[12]=x*n+_*u+w*l+b*y,t[13]=x*a+_*s+w*h+b*v,t[14]=x*o+_*c+w*d+b*m,t[15]=x*i+_*f+w*p+b*g,t}function translate(t,e,r){var n=r[0],a=r[1],o=r[2],i=void 0,u=void 0,s=void 0,c=void 0,f=void 0,l=void 0,h=void 0,d=void 0,p=void 0,y=void 0,v=void 0,m=void 0;return e===t?(t[12]=e[0]*n+e[4]*a+e[8]*o+e[12],t[13]=e[1]*n+e[5]*a+e[9]*o+e[13],t[14]=e[2]*n+e[6]*a+e[10]*o+e[14],t[15]=e[3]*n+e[7]*a+e[11]*o+e[15]):(i=e[0],u=e[1],s=e[2],c=e[3],f=e[4],l=e[5],h=e[6],d=e[7],p=e[8],y=e[9],v=e[10],m=e[11],t[0]=i,t[1]=u,t[2]=s,t[3]=c,t[4]=f,t[5]=l,t[6]=h,t[7]=d,t[8]=p,t[9]=y,t[10]=v,t[11]=m,t[12]=i*n+f*a+p*o+e[12],t[13]=u*n+l*a+y*o+e[13],t[14]=s*n+h*a+v*o+e[14],t[15]=c*n+d*a+m*o+e[15]),t}function mat4_scale(t,e,r){var n=r[0],a=r[1],o=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*a,t[5]=e[5]*a,t[6]=e[6]*a,t[7]=e[7]*a,t[8]=e[8]*o,t[9]=e[9]*o,t[10]=e[10]*o,t[11]=e[11]*o,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function rotate(t,e,r,n){var a,o,i,u,s,c,f,l,h,d,p,y,v,m,g,_,w,b,M,T,P,k,I,F,E=n[0],C=n[1],N=n[2],V=Math.sqrt(E*E+C*C+N*N);return V<x?null:(E*=V=1/V,C*=V,N*=V,a=Math.sin(r),i=1-(o=Math.cos(r)),u=e[0],s=e[1],c=e[2],f=e[3],l=e[4],h=e[5],d=e[6],p=e[7],y=e[8],v=e[9],m=e[10],g=e[11],_=E*E*i+o,w=C*E*i+N*a,b=N*E*i-C*a,M=E*C*i-N*a,T=C*C*i+o,P=N*C*i+E*a,k=E*N*i+C*a,I=C*N*i-E*a,F=N*N*i+o,t[0]=u*_+l*w+y*b,t[1]=s*_+h*w+v*b,t[2]=c*_+d*w+m*b,t[3]=f*_+p*w+g*b,t[4]=u*M+l*T+y*P,t[5]=s*M+h*T+v*P,t[6]=c*M+d*T+m*P,t[7]=f*M+p*T+g*P,t[8]=u*k+l*I+y*F,t[9]=s*k+h*I+v*F,t[10]=c*k+d*I+m*F,t[11]=f*k+p*I+g*F,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function rotateX(t,e,r){var n=Math.sin(r),a=Math.cos(r),o=e[4],i=e[5],u=e[6],s=e[7],c=e[8],f=e[9],l=e[10],h=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=o*a+c*n,t[5]=i*a+f*n,t[6]=u*a+l*n,t[7]=s*a+h*n,t[8]=c*a-o*n,t[9]=f*a-i*n,t[10]=l*a-u*n,t[11]=h*a-s*n,t}function rotateY(t,e,r){var n=Math.sin(r),a=Math.cos(r),o=e[0],i=e[1],u=e[2],s=e[3],c=e[8],f=e[9],l=e[10],h=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*a-c*n,t[1]=i*a-f*n,t[2]=u*a-l*n,t[3]=s*a-h*n,t[8]=o*n+c*a,t[9]=i*n+f*a,t[10]=u*n+l*a,t[11]=s*n+h*a,t}function rotateZ(t,e,r){var n=Math.sin(r),a=Math.cos(r),o=e[0],i=e[1],u=e[2],s=e[3],c=e[4],f=e[5],l=e[6],h=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=o*a+c*n,t[1]=i*a+f*n,t[2]=u*a+l*n,t[3]=s*a+h*n,t[4]=c*a-o*n,t[5]=f*a-i*n,t[6]=l*a-u*n,t[7]=h*a-s*n,t}function fromTranslation(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function fromScaling(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromRotation(t,e,r){var n,a,o,i=r[0],u=r[1],s=r[2],c=Math.sqrt(i*i+u*u+s*s);return c<x?null:(i*=c=1/c,u*=c,s*=c,n=Math.sin(e),o=1-(a=Math.cos(e)),t[0]=i*i*o+a,t[1]=u*i*o+s*n,t[2]=s*i*o-u*n,t[3]=0,t[4]=i*u*o-s*n,t[5]=u*u*o+a,t[6]=s*u*o+i*n,t[7]=0,t[8]=i*s*o+u*n,t[9]=u*s*o-i*n,t[10]=s*s*o+a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function fromXRotation(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromYRotation(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromZRotation(t,e){var r=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromRotationTranslation(t,e,r){var n=e[0],a=e[1],o=e[2],i=e[3],u=n+n,s=a+a,c=o+o,f=n*u,l=n*s,h=n*c,d=a*s,p=a*c,y=o*c,v=i*u,m=i*s,g=i*c;return t[0]=1-(d+y),t[1]=l+g,t[2]=h-m,t[3]=0,t[4]=l-g,t[5]=1-(f+y),t[6]=p+v,t[7]=0,t[8]=h+m,t[9]=p-v,t[10]=1-(f+d),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function fromQuat2(t,e){var r=new _(3),n=-e[0],a=-e[1],o=-e[2],i=e[3],u=e[4],s=e[5],c=e[6],f=e[7],l=n*n+a*a+o*o+i*i;return l>0?(r[0]=2*(u*i+f*n+s*o-c*a)/l,r[1]=2*(s*i+f*a+c*n-u*o)/l,r[2]=2*(c*i+f*o+u*a-s*n)/l):(r[0]=2*(u*i+f*n+s*o-c*a),r[1]=2*(s*i+f*a+c*n-u*o),r[2]=2*(c*i+f*o+u*a-s*n)),fromRotationTranslation(t,e,r),t}function getTranslation(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function getScaling(t,e){var r=e[0],n=e[1],a=e[2],o=e[4],i=e[5],u=e[6],s=e[8],c=e[9],f=e[10];return t[0]=Math.sqrt(r*r+n*n+a*a),t[1]=Math.sqrt(o*o+i*i+u*u),t[2]=Math.sqrt(s*s+c*c+f*f),t}function getRotation(t,e){var r=e[0]+e[5]+e[10],n=0;return r>0?(n=2*Math.sqrt(r+1),t[3]=.25*n,t[0]=(e[6]-e[9])/n,t[1]=(e[8]-e[2])/n,t[2]=(e[1]-e[4])/n):e[0]>e[5]&&e[0]>e[10]?(n=2*Math.sqrt(1+e[0]-e[5]-e[10]),t[3]=(e[6]-e[9])/n,t[0]=.25*n,t[1]=(e[1]+e[4])/n,t[2]=(e[8]+e[2])/n):e[5]>e[10]?(n=2*Math.sqrt(1+e[5]-e[0]-e[10]),t[3]=(e[8]-e[2])/n,t[0]=(e[1]+e[4])/n,t[1]=.25*n,t[2]=(e[6]+e[9])/n):(n=2*Math.sqrt(1+e[10]-e[0]-e[5]),t[3]=(e[1]-e[4])/n,t[0]=(e[8]+e[2])/n,t[1]=(e[6]+e[9])/n,t[2]=.25*n),t}function fromRotationTranslationScale(t,e,r,n){var a=e[0],o=e[1],i=e[2],u=e[3],s=a+a,c=o+o,f=i+i,l=a*s,h=a*c,d=a*f,p=o*c,y=o*f,v=i*f,m=u*s,g=u*c,x=u*f,_=n[0],w=n[1],b=n[2];return t[0]=(1-(p+v))*_,t[1]=(h+x)*_,t[2]=(d-g)*_,t[3]=0,t[4]=(h-x)*w,t[5]=(1-(l+v))*w,t[6]=(y+m)*w,t[7]=0,t[8]=(d+g)*b,t[9]=(y-m)*b,t[10]=(1-(l+p))*b,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function fromRotationTranslationScaleOrigin(t,e,r,n,a){var o=e[0],i=e[1],u=e[2],s=e[3],c=o+o,f=i+i,l=u+u,h=o*c,d=o*f,p=o*l,y=i*f,v=i*l,m=u*l,g=s*c,x=s*f,_=s*l,w=n[0],b=n[1],M=n[2],T=a[0],P=a[1],k=a[2],I=(1-(y+m))*w,F=(d+_)*w,E=(p-x)*w,C=(d-_)*b,N=(1-(h+m))*b,V=(v+g)*b,S=(p+x)*M,A=(v-g)*M,D=(1-(h+y))*M;return t[0]=I,t[1]=F,t[2]=E,t[3]=0,t[4]=C,t[5]=N,t[6]=V,t[7]=0,t[8]=S,t[9]=A,t[10]=D,t[11]=0,t[12]=r[0]+T-(I*T+C*P+S*k),t[13]=r[1]+P-(F*T+N*P+A*k),t[14]=r[2]+k-(E*T+V*P+D*k),t[15]=1,t}function fromQuat(t,e){var r=e[0],n=e[1],a=e[2],o=e[3],i=r+r,u=n+n,s=a+a,c=r*i,f=n*i,l=n*u,h=a*i,d=a*u,p=a*s,y=o*i,v=o*u,m=o*s;return t[0]=1-l-p,t[1]=f+m,t[2]=h-v,t[3]=0,t[4]=f-m,t[5]=1-c-p,t[6]=d+y,t[7]=0,t[8]=h+v,t[9]=d-y,t[10]=1-c-l,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function frustum(t,e,r,n,a,o,i){var u=1/(r-e),s=1/(a-n),c=1/(o-i);return t[0]=2*o*u,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*o*s,t[6]=0,t[7]=0,t[8]=(r+e)*u,t[9]=(a+n)*s,t[10]=(i+o)*c,t[11]=-1,t[12]=0,t[13]=0,t[14]=i*o*2*c,t[15]=0,t}function perspective(t,e,r,n,a){var o=1/Math.tan(e/2),i=void 0;return t[0]=o/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=a&&a!==1/0?(i=1/(n-a),t[10]=(a+n)*i,t[14]=2*a*n*i):(t[10]=-1,t[14]=-2*n),t}function perspectiveFromFieldOfView(t,e,r,n){var a=Math.tan(e.upDegrees*Math.PI/180),o=Math.tan(e.downDegrees*Math.PI/180),i=Math.tan(e.leftDegrees*Math.PI/180),u=Math.tan(e.rightDegrees*Math.PI/180),s=2/(i+u),c=2/(a+o);return t[0]=s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=-(i-u)*s*.5,t[9]=(a-o)*c*.5,t[10]=n/(r-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*r/(r-n),t[15]=0,t}function ortho(t,e,r,n,a,o,i){var u=1/(e-r),s=1/(n-a),c=1/(o-i);return t[0]=-2*u,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(e+r)*u,t[13]=(a+n)*s,t[14]=(i+o)*c,t[15]=1,t}function lookAt(t,e,r,n){var a=void 0,o=void 0,i=void 0,u=void 0,s=void 0,c=void 0,f=void 0,l=void 0,h=void 0,d=void 0,p=e[0],y=e[1],v=e[2],m=n[0],g=n[1],_=n[2],w=r[0],b=r[1],M=r[2];return Math.abs(p-w)<x&&Math.abs(y-b)<x&&Math.abs(v-M)<x?identity(t):(f=p-w,l=y-b,h=v-M,a=g*(h*=d=1/Math.sqrt(f*f+l*l+h*h))-_*(l*=d),o=_*(f*=d)-m*h,i=m*l-g*f,(d=Math.sqrt(a*a+o*o+i*i))?(a*=d=1/d,o*=d,i*=d):(a=0,o=0,i=0),u=l*i-h*o,s=h*a-f*i,c=f*o-l*a,(d=Math.sqrt(u*u+s*s+c*c))?(u*=d=1/d,s*=d,c*=d):(u=0,s=0,c=0),t[0]=a,t[1]=u,t[2]=f,t[3]=0,t[4]=o,t[5]=s,t[6]=l,t[7]=0,t[8]=i,t[9]=c,t[10]=h,t[11]=0,t[12]=-(a*p+o*y+i*v),t[13]=-(u*p+s*y+c*v),t[14]=-(f*p+l*y+h*v),t[15]=1,t)}function targetTo(t,e,r,n){var a=e[0],o=e[1],i=e[2],u=n[0],s=n[1],c=n[2],f=a-r[0],l=o-r[1],h=i-r[2],d=f*f+l*l+h*h;d>0&&(f*=d=1/Math.sqrt(d),l*=d,h*=d);var p=s*h-c*l,y=c*f-u*h,v=u*l-s*f;return(d=p*p+y*y+v*v)>0&&(p*=d=1/Math.sqrt(d),y*=d,v*=d),t[0]=p,t[1]=y,t[2]=v,t[3]=0,t[4]=l*v-h*y,t[5]=h*p-f*v,t[6]=f*y-l*p,t[7]=0,t[8]=f,t[9]=l,t[10]=h,t[11]=0,t[12]=a,t[13]=o,t[14]=i,t[15]=1,t}function str(t){return\"mat4(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\", \"+t[4]+\", \"+t[5]+\", \"+t[6]+\", \"+t[7]+\", \"+t[8]+\", \"+t[9]+\", \"+t[10]+\", \"+t[11]+\", \"+t[12]+\", \"+t[13]+\", \"+t[14]+\", \"+t[15]+\")\"}function frob(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))}function add(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t[4]=e[4]+r[4],t[5]=e[5]+r[5],t[6]=e[6]+r[6],t[7]=e[7]+r[7],t[8]=e[8]+r[8],t[9]=e[9]+r[9],t[10]=e[10]+r[10],t[11]=e[11]+r[11],t[12]=e[12]+r[12],t[13]=e[13]+r[13],t[14]=e[14]+r[14],t[15]=e[15]+r[15],t}function subtract(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t[4]=e[4]-r[4],t[5]=e[5]-r[5],t[6]=e[6]-r[6],t[7]=e[7]-r[7],t[8]=e[8]-r[8],t[9]=e[9]-r[9],t[10]=e[10]-r[10],t[11]=e[11]-r[11],t[12]=e[12]-r[12],t[13]=e[13]-r[13],t[14]=e[14]-r[14],t[15]=e[15]-r[15],t}function multiplyScalar(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*r,t[9]=e[9]*r,t[10]=e[10]*r,t[11]=e[11]*r,t[12]=e[12]*r,t[13]=e[13]*r,t[14]=e[14]*r,t[15]=e[15]*r,t}function multiplyScalarAndAdd(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t[4]=e[4]+r[4]*n,t[5]=e[5]+r[5]*n,t[6]=e[6]+r[6]*n,t[7]=e[7]+r[7]*n,t[8]=e[8]+r[8]*n,t[9]=e[9]+r[9]*n,t[10]=e[10]+r[10]*n,t[11]=e[11]+r[11]*n,t[12]=e[12]+r[12]*n,t[13]=e[13]+r[13]*n,t[14]=e[14]+r[14]*n,t[15]=e[15]+r[15]*n,t}function exactEquals(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]}function mat4_equals(t,e){var r=t[0],n=t[1],a=t[2],o=t[3],i=t[4],u=t[5],s=t[6],c=t[7],f=t[8],l=t[9],h=t[10],d=t[11],p=t[12],y=t[13],v=t[14],m=t[15],g=e[0],_=e[1],w=e[2],b=e[3],M=e[4],T=e[5],P=e[6],k=e[7],I=e[8],F=e[9],E=e[10],C=e[11],N=e[12],V=e[13],S=e[14],A=e[15];return Math.abs(r-g)<=x*Math.max(1,Math.abs(r),Math.abs(g))&&Math.abs(n-_)<=x*Math.max(1,Math.abs(n),Math.abs(_))&&Math.abs(a-w)<=x*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(o-b)<=x*Math.max(1,Math.abs(o),Math.abs(b))&&Math.abs(i-M)<=x*Math.max(1,Math.abs(i),Math.abs(M))&&Math.abs(u-T)<=x*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(s-P)<=x*Math.max(1,Math.abs(s),Math.abs(P))&&Math.abs(c-k)<=x*Math.max(1,Math.abs(c),Math.abs(k))&&Math.abs(f-I)<=x*Math.max(1,Math.abs(f),Math.abs(I))&&Math.abs(l-F)<=x*Math.max(1,Math.abs(l),Math.abs(F))&&Math.abs(h-E)<=x*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(d-C)<=x*Math.max(1,Math.abs(d),Math.abs(C))&&Math.abs(p-N)<=x*Math.max(1,Math.abs(p),Math.abs(N))&&Math.abs(y-V)<=x*Math.max(1,Math.abs(y),Math.abs(V))&&Math.abs(v-S)<=x*Math.max(1,Math.abs(v),Math.abs(S))&&Math.abs(m-A)<=x*Math.max(1,Math.abs(m),Math.abs(A))}var b=multiply,M=subtract;function vec4_create(){var t=new _(4);return _!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function vec4_clone(t){var e=new _(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function vec4_fromValues(t,e,r,n){var a=new _(4);return a[0]=t,a[1]=e,a[2]=r,a[3]=n,a}function vec4_copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function vec4_set(t,e,r,n,a){return t[0]=e,t[1]=r,t[2]=n,t[3]=a,t}function vec4_add(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t}function vec4_subtract(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t[2]=e[2]-r[2],t[3]=e[3]-r[3],t}function vec4_multiply(t,e,r){return t[0]=e[0]*r[0],t[1]=e[1]*r[1],t[2]=e[2]*r[2],t[3]=e[3]*r[3],t}function divide(t,e,r){return t[0]=e[0]/r[0],t[1]=e[1]/r[1],t[2]=e[2]/r[2],t[3]=e[3]/r[3],t}function ceil(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t}function floor(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t}function vec4_min(t,e,r){return t[0]=Math.min(e[0],r[0]),t[1]=Math.min(e[1],r[1]),t[2]=Math.min(e[2],r[2]),t[3]=Math.min(e[3],r[3]),t}function vec4_max(t,e,r){return t[0]=Math.max(e[0],r[0]),t[1]=Math.max(e[1],r[1]),t[2]=Math.max(e[2],r[2]),t[3]=Math.max(e[3],r[3]),t}function round(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t}function vec4_scale(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function scaleAndAdd(t,e,r,n){return t[0]=e[0]+r[0]*n,t[1]=e[1]+r[1]*n,t[2]=e[2]+r[2]*n,t[3]=e[3]+r[3]*n,t}function distance(t,e){var r=e[0]-t[0],n=e[1]-t[1],a=e[2]-t[2],o=e[3]-t[3];return Math.sqrt(r*r+n*n+a*a+o*o)}function squaredDistance(t,e){var r=e[0]-t[0],n=e[1]-t[1],a=e[2]-t[2],o=e[3]-t[3];return r*r+n*n+a*a+o*o}function vec4_length(t){var e=t[0],r=t[1],n=t[2],a=t[3];return Math.sqrt(e*e+r*r+n*n+a*a)}function squaredLength(t){var e=t[0],r=t[1],n=t[2],a=t[3];return e*e+r*r+n*n+a*a}function negate(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t}function inverse(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t}function normalize(t,e){var r=e[0],n=e[1],a=e[2],o=e[3],i=r*r+n*n+a*a+o*o;return i>0&&(i=1/Math.sqrt(i),t[0]=r*i,t[1]=n*i,t[2]=a*i,t[3]=o*i),t}function dot(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function lerp(t,e,r,n){var a=e[0],o=e[1],i=e[2],u=e[3];return t[0]=a+n*(r[0]-a),t[1]=o+n*(r[1]-o),t[2]=i+n*(r[2]-i),t[3]=u+n*(r[3]-u),t}function random(t,e){var r,n,a,o,i,u;e=e||1;do{i=(r=2*w()-1)*r+(n=2*w()-1)*n}while(i>=1);do{u=(a=2*w()-1)*a+(o=2*w()-1)*o}while(u>=1);var s=Math.sqrt((1-i)/u);return t[0]=e*r,t[1]=e*n,t[2]=e*a*s,t[3]=e*o*s,t}function transformMat4(t,e,r){var n=e[0],a=e[1],o=e[2],i=e[3];return t[0]=r[0]*n+r[4]*a+r[8]*o+r[12]*i,t[1]=r[1]*n+r[5]*a+r[9]*o+r[13]*i,t[2]=r[2]*n+r[6]*a+r[10]*o+r[14]*i,t[3]=r[3]*n+r[7]*a+r[11]*o+r[15]*i,t}function transformQuat(t,e,r){var n=e[0],a=e[1],o=e[2],i=r[0],u=r[1],s=r[2],c=r[3],f=c*n+u*o-s*a,l=c*a+s*n-i*o,h=c*o+i*a-u*n,d=-i*n-u*a-s*o;return t[0]=f*c+d*-i+l*-s-h*-u,t[1]=l*c+d*-u+h*-i-f*-s,t[2]=h*c+d*-s+f*-u-l*-i,t[3]=e[3],t}function vec4_str(t){return\"vec4(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\")\"}function vec4_exactEquals(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function vec4_equals(t,e){var r=t[0],n=t[1],a=t[2],o=t[3],i=e[0],u=e[1],s=e[2],c=e[3];return Math.abs(r-i)<=x*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(n-u)<=x*Math.max(1,Math.abs(n),Math.abs(u))&&Math.abs(a-s)<=x*Math.max(1,Math.abs(a),Math.abs(s))&&Math.abs(o-c)<=x*Math.max(1,Math.abs(o),Math.abs(c))}var T=vec4_subtract,P=vec4_multiply,k=divide,I=distance,F=squaredDistance,E=vec4_length,C=squaredLength,N=function(){var t=vec4_create();return function(e,r,n,a,o,i){var u=void 0,s=void 0;for(r||(r=4),n||(n=0),s=a?Math.min(a*r+n,e.length):e.length,u=n;u<s;u+=r)t[0]=e[u],t[1]=e[u+1],t[2]=e[u+2],t[3]=e[u+3],o(t,t,i),e[u]=t[0],e[u+1]=t[1],e[u+2]=t[2],e[u+3]=t[3];return e}}(),V=function average(t){for(var e=0,r=0;r<t.length;r++)e+=t[r];return e/t.length},S=r(3),A=r.n(S),D=r(1),O=r.n(D),L=r(4),R=r.n(L),B=r(16),q=function(t){function CartoError(t){var e;if(h()(this,CartoError),!t)throw Error(\"Invalid CartoError, a message is mandatory\");if(!t.message)throw Error(\"Invalid CartoError, a message is mandatory\");if(!t.type)throw Error(\"Invalid CartoError, a type is mandatory\");return(e=A()(this,O()(CartoError).call(this,\"\".concat(t.type,\" \").concat(t.message)))).name=\"CartoError\",e.type=t.type,e.originalError=t,e}return R()(CartoError,t),CartoError}(r.n(B)()(Error)),W=function(t){function CartoValidationError(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.DEFAULT;return h()(this,CartoValidationError),(e=A()(this,O()(CartoValidationError).call(this,{message:t,type:r}))).name=\"CartoValidationError\",e}return R()(CartoValidationError,t),CartoValidationError}(q),G={DEFAULT:\"[Error]\",MISSING_REQUIRED:\"[Missing required property]\",INCORRECT_TYPE:\"[Property with an incorrect type]\",INCORRECT_VALUE:\"[Incorrect value]\",TOO_MANY_ARGS:\"[Too many arguments]\",NOT_ENOUGH_ARGS:\"[Not enough arguments]\",WRONG_NUMBER_ARGS:\"[Wrong number of arguments]\"},Z={UNKNOWN:\"unknown\",POINT:\"point\",LINE:\"line\",POLYGON:\"polygon\"};function geometry_sub(t,e){var r=i()(t,2),n=r[0],a=r[1],o=i()(e,2);return[n-o[0],a-o[1]]}function geometry_dot(t,e){var r=i()(t,2),n=r[0],a=r[1],o=i()(e,2);return n*o[0]+a*o[1]}function perpendicular(t){var e=i()(t,2),r=e[0];return[-e[1],r]}function getLineNormal(t,e){var r=function geometry_normalize(t,e){var r=Math.hypot(t,e);return[t/r,e/r]}(t[0]-e[0],t[1]-e[1]);return[-r[1],r[0]]}function getJoinNormal(t,e){var r=[t[1],-t[0]],n=[-e[1],e[0]],a=n[0]*r[1]-n[1]*r[0],o=n[0]*r[0]+n[1]*r[1],i=Math.abs(a);return{turnLeft:a>0,joinNormal:!(i<.866&&o>.5)&&neg([(r[0]+n[0])/i,(r[1]+n[1])/i])}}function neg(t){return[-t[0],-t[1]]}function halfPlaneSign(t,e,r){return(t.x-r.x)*(e.y-r.y)-(e.x-r.x)*(t.y-r.y)}function equalPoints(t,e){return t.x===e.x&&t.y===e.y}function computeCentroids(t,e){switch(e){case Z.POINT:return function _computeCentroidsForPoints(t){for(var e=[],r=0;r<t.vertices.length/6;r++){var n=6*r,a=n+6,o=t.vertices.slice(n,a),u=i()(o,6),s=u[4],c=u[5];e.push({x:s,y:c})}return e}(t);case Z.LINE:case Z.POLYGON:return function _computeCentroidsForLinesOrPolygons(t,e){var r=[],n=0;return t.breakpoints.forEach(function(a){var o=t.vertices.slice(n,a),u=null;u=e===Z.LINE?function _centroidForLines(t){for(var e=[],r=[],n=0;n<t.length/6;n++){var a=6*n,o=a+6,u=t.slice(a,o),s=i()(u,6),c=s[0],f=s[1],l=s[2],h=s[3],d=s[4],p=s[5],y=c===l&&f===h,v=l===d&&h===p;if(!y||!v){var m=[c,f],g=y?[d,p]:[l,h];e.push(m[0]),e.push(g[0]),r.push(m[1]),r.push(g[1])}}return{x:V(e),y:V(r)}}(o):function _centroidForPolygons(t){for(var e=[],r=[],n=[],a=0;a<t.length/6;a++){var o=6*a,u=o+6,s=t.slice(o,u),c=i()(s,6),f=c[0],l=c[1],h=c[2],d=c[3],p=c[4],y=c[5],v=[[f,l],[h,d],[p,y]],m=triangleArea(v);if(m>0){var g=V([f,h,p]),x=V([l,d,y]);e.push(g*m),r.push(x*m),n.push(m)}}var _=_sumArray(n);return{x:_sumArray(e)/_,y:_sumArray(r)/_}}(o),r.push(u),n=a}),r}(t,e);default:throw new W(\"Invalid type argument, decoded geometry must have a point, line or polygon type.\",G.INCORRECT_VALUE)}}function _sumArray(t){return t.reduce(function(t,e){return t+e},0)}function triangleArea(t){var e=i()(t[0],2),r=e[0],n=e[1],a=i()(t[1],2),o=a[0],u=a[1],s=i()(t[2],2),c=s[0],f=s[1];return Math.abs((r-c)*(u-n)-(r-o)*(f-n))/2}function _updateAABBForGeometry(t,e,r){switch(r){case Z.LINE:return function _updateAABBLine(t,e){for(var r=t,n=t.length,a=0;a<n;a+=2)e.minx=Math.min(e.minx,r[a+0]),e.miny=Math.min(e.miny,r[a+1]),e.maxx=Math.max(e.maxx,r[a+0]),e.maxy=Math.max(e.maxy,r[a+1]);return e}(t,e);case Z.POLYGON:return function _updateAABBPolygon(t,e){for(var r=[t.flat,t.holes[0]||t.flat.length/2],n=r[0],a=r[1],o=0;o<a;o++)e.minx=Math.min(e.minx,n[2*o+0]),e.miny=Math.min(e.miny,n[2*o+1]),e.maxx=Math.max(e.maxx,n[2*o+0]),e.maxy=Math.max(e.maxy,n[2*o+1]);return e}(t,e)}}var j={intersect:function geometry_intersect(t,e,r,n){var a=t,o=r,i=geometry_sub(e,t),u=geometry_sub(n,r),s=perpendicular(i),c=perpendicular(u),f=geometry_dot(geometry_sub(o,a),c)/geometry_dot(i,c),l=geometry_dot(geometry_sub(a,o),s)/geometry_dot(u,s);if(f>=0&&f<=1&&l>=0&&l<=1)return[a[0]+f*i[0],a[1]+f*i[1]]},sub:geometry_sub,dot:geometry_dot,perpendicular:perpendicular,getLineNormal:getLineNormal,getJoinNormal:getJoinNormal,neg:neg,halfPlaneSign:halfPlaneSign,pointInTriangle:function pointInTriangle(t,e,r,n){if(equalPoints(e,r)||equalPoints(r,n)||equalPoints(n,e))return!1;var a=halfPlaneSign(t,e,r)<0,o=halfPlaneSign(t,r,n)<0,i=halfPlaneSign(t,n,e)<0;return a===o&&o===i},equalPoints:equalPoints,pointInCircle:function pointInCircle(t,e,r){var n=t.x-e.x,a=t.y-e.y;return n*n+a*a<=r*r},pointInRectangle:function pointInRectangle(t,e){if(null===e)return!1;var r=t.x.toFixed(2),n=t.y.toFixed(2);return e.minx<=r&&r<=e.maxx&&e.miny<=n&&n<=e.maxy}},U=function Polygon(){h()(this,Polygon),this.flat=[],this.holes=[],this.clipped=[],this.clippedType=[]};function decodeLines(t,e){var r=[];return t.map(function(t){var n=[];t.map(function(t){n.push([2*t.x/e-1,2*(1-t.y/e)-1])}),r.push.apply(r,g()(function clipLine(t){var e=[],r=[];function clipType(t){for(var e=0,r=0;r<Y;r++)e|=z[r].inside(t)?0:1<<r;return e}function intersect(t,e,r){for(var n=0;n<Y;n++){var a=1<<n;if(r&a){var o=z[n].intersect(t,e);return r=clipType(o)&~a,[o,r]}}}for(var n=t[0],a=clipType(n),o=1;o<t.length;++o){for(var u=t[o],s=clipType(u),c=s,f=u;;){if(!(a|s)){var l,h;if((l=e).push.apply(l,g()(n)),s!==c)(h=e).push.apply(h,g()(u)),o<t.length-1&&(r.push(e),e=[]);else if(o===t.length-1){var d;(d=e).push.apply(d,g()(u))}break}if(a&s)break;if(a){var p=intersect(n,u,a),y=i()(p,2);n=y[0],a=y[1]}else{var v=intersect(n,u,s),m=i()(v,2);u=m[0],s=m[1]}}n=f,a=c}(e=function _removeDuplicatedVerticesOnLine(t){for(var e,r,n=[],a=0;a<t.length;a+=2){var o=t[a],i=t[a+1];o===e&&i===r||(n.push(o,i),e=o,r=i)}return n}(e)).length>0&&r.push(e);return r}(n)))}),r}function decodePolygons(t,e){var r,n=null,a=[];return t.forEach(function(t){var o=function signedPolygonArea(t){for(var e=0,r=0;r<t.length;r++){var n=(r+1)%t.length;e+=t[r].x*t[n].y,e-=t[n].x*t[r].y}return e/2}(t);if(0!==o){void 0===r&&(r=o>0);var i=r?o>0:o<0,u=function _getPreClippedVertices(t,e){return t.map(function(t){var r=t.x,n=t.y;return[r=2*r/e-1,n=2*(1-n/e)-1]})}(t,e);i&&(n&&a.push(n),n=new U),n=function clipPolygon(t,e,r){for(var n={},a=function _loop(e){for(var r=[],a={},o=function setClippedType(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,o=0;e>=0&&(o=n[e]||0),r>=0&&(o|=1<<r),o&&(a[t]=o)},i=0;i<t.length-1;i++){var u=t[i],s=t[i+1],c=z[e].inside(u),f=z[e].inside(s);if(c&&f)o(r.length,i+1),r.push(s);else if(c){var l=z[e].intersect(u,s);o(r.length,i+1,e),r.push(l)}else if(f){var h=z[e].intersect(u,s);o(r.length,i,e),r.push(h),o(r.length,i+1),r.push(s)}}r.length&&(a[0]&&(a[r.length]=a[0]),r.push(r[0])),t=r,n=a},o=0;o<Y;o++)a(o);t.length>=4&&(r&&e.holes.push(e.flat.length/2),t.forEach(function(t){e.flat.push(t[0],t[1])}),Object.keys(n).forEach(function(t){e.clipped.push(2*Number(t)),e.clippedType.push(n[t])}));return e}(u,n,!i)}}),n&&a.push(n),a}var z=[{inside:function inside(t){return t[0]<=1},intersect:function intersect(t,e){return j.intersect(t,e,[1,-100],[1,100])}},{inside:function inside(t){return t[1]<=1},intersect:function intersect(t,e){return j.intersect(t,e,[-100,1],[100,1])}},{inside:function inside(t){return t[0]>=-1},intersect:function intersect(t,e){return j.intersect(t,e,[-1,-100],[-1,100])}},{inside:function inside(t){return t[1]>=-1},intersect:function intersect(t,e){return j.intersect(t,e,[-100,-1],[100,-1])}}],Y=z.length;var Q=function(t){function CartoRuntimeError(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.DEFAULT;return h()(this,CartoRuntimeError),(e=A()(this,O()(CartoRuntimeError).call(this,{message:t,type:r}))).name=\"CartoRuntimeError\",e}return R()(CartoRuntimeError,t),CartoRuntimeError}(q),H={DEFAULT:\"[Error]\",NOT_SUPPORTED:\"[Not supported]\",WEB_GL:\"[WebGL]\",MVT:\"[MVT]\"},$=function(){function BaseCodec(t,e){h()(this,BaseCodec),t&&e&&(this._baseName=t.baseName(e))}return p()(BaseCodec,[{key:\"isRange\",value:function isRange(){return!1}},{key:\"isIdentity\",value:function isIdentity(){return!1}},{key:\"sourceToInternal\",value:function sourceToInternal(t,e){return e}},{key:\"internalToExternal\",value:function internalToExternal(t,e){return e}},{key:\"externalToSource\",value:function externalToSource(t,e){return e}},{key:\"sourceToExternal\",value:function sourceToExternal(t,e){return this.internalToExternal(t,this.sourceToInternal(t,e))}},{key:\"externalToInternal\",value:function externalToInternal(t,e){return this.sourceToInternal(t,this.externalToSource(t,e))}},{key:\"inlineInternalMatch\",value:function inlineInternalMatch(t,e){return\"\".concat(t)}}]),BaseCodec}(),X=function(t){function IdentityCodec(){return h()(this,IdentityCodec),A()(this,O()(IdentityCodec).apply(this,arguments))}return R()(IdentityCodec,t),p()(IdentityCodec,[{key:\"isIdentity\",value:function isIdentity(){return!0}},{key:\"sourceToInternal\",value:function sourceToInternal(t,e){return e}},{key:\"internalToExternal\",value:function internalToExternal(t,e){return e}},{key:\"sourceToExternal\",value:function sourceToExternal(t,e){return e}},{key:\"externalToSource\",value:function externalToSource(t,e){return e}},{key:\"externalToInternal\",value:function externalToInternal(t,e){return e}}]),IdentityCodec}($),J=4096,K=\"cartodb_id\",tt=function(){function Metadata(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{properties:{}},r=e.properties,n=e.featureCount,a=e.sample,o=e.geomType,i=e.isAggregated,u=e.idProperty,s=e.extent;h()(this,Metadata),this.properties=r,this.featureCount=n,this.sample=a,this.geomType=o,this.isAggregated=i,this.idProperty=u||K,this.properties.hasOwnProperty(this.idProperty)||(this.properties[this.idProperty]={type:\"number\"}),this.categoryToID=new Map,this.IDToCategory=new Map,this.numCategories=0,this.extent=s||J,Object.values(r).map(function(e){e.categories=e.categories||[],e.categories.map(function(r){return t.categorizeString(e,r.name,!0)})}),this.propertyKeys=Object.keys(r)}return p()(Metadata,[{key:\"setCodecs\",value:function setCodecs(){throw new Q(\\'You must call \"setCodecs\" once you have determined the proper subclass\\')}},{key:\"categorizeString\",value:function categorizeString(t,e){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(void 0===e&&(e=null),this.categoryToID.has(e))return this.categoryToID.get(e);r||null===e||this.properties[t].categories.push({name:e,frequency:Number.NaN});var n=null===e?-(1<<24):this.numCategories;return this.categoryToID.set(e,n),this.IDToCategory.set(n,e),this.numCategories++,n}},{key:\"decodedProperties\",value:function decodedProperties(t){return[t]}},{key:\"baseName\",value:function baseName(t){return t}},{key:\"sourcePropertyName\",value:function sourcePropertyName(t){return t}},{key:\"stats\",value:function stats(t){return this.properties[t]}},{key:\"codec\",value:function codec(t){var e=this.baseName(t);return this.properties[e]&&this.properties[e].codec?this.properties[e].codec:new X}}]),Metadata}(),et=r(7),rt=r.n(et),nt=r(8),at=r.n(nt),ot=function(t){function NumberCodec(){return h()(this,NumberCodec),A()(this,O()(NumberCodec).apply(this,arguments))}return R()(NumberCodec,t),p()(NumberCodec,[{key:\"sourceToInternal\",value:function sourceToInternal(t,e){return(isNaN(e)||null==e)&&(e=-(1<<24)),e}},{key:\"internalToExternal\",value:function internalToExternal(t,e){return e===-(1<<24)&&(e=null),e}},{key:\"externalToInternal\",value:function externalToInternal(t,e){return null===e&&(e=-(1<<24)),e}}]),NumberCodec}(X),it=function(t){function MVTNumberCodec(){return h()(this,MVTNumberCodec),A()(this,O()(MVTNumberCodec).apply(this,arguments))}return R()(MVTNumberCodec,t),p()(MVTNumberCodec,[{key:\"sourceToInternal\",value:function sourceToInternal(t,e){var r=rt()(e);if(null!==e&&\"undefined\"!==r&&\"number\"!==r)throw new Q(\"MVT decoding error. Metadata property \\'\".concat(this._baseName,\"\\' is of type \\'number\\' but the MVT tile contained a feature property of type \\'\").concat(r,\"\\': \\'\").concat(e,\"\\'\"),H.MVT);return at()(O()(MVTNumberCodec.prototype),\"sourceToInternal\",this).call(this,t,e)}}]),MVTNumberCodec}(ot),ut=function(t){function CategoryCodec(){return h()(this,CategoryCodec),A()(this,O()(CategoryCodec).apply(this,arguments))}return R()(CategoryCodec,t),p()(CategoryCodec,[{key:\"sourceToInternal\",value:function sourceToInternal(t,e){return t.categorizeString(this._baseName,e)}},{key:\"internalToExternal\",value:function internalToExternal(t,e){return t.IDToCategory.get(e)}},{key:\"sourceToExternal\",value:function sourceToExternal(t,e){return e}},{key:\"externalToSource\",value:function externalToSource(t,e){return e}}]),CategoryCodec}($),st=function(t){function MVTCategoryCodec(){return h()(this,MVTCategoryCodec),A()(this,O()(MVTCategoryCodec).apply(this,arguments))}return R()(MVTCategoryCodec,t),p()(MVTCategoryCodec,[{key:\"sourceToInternal\",value:function sourceToInternal(t,e){var r=rt()(e);if(null!==e&&\"undefined\"!==r&&\"string\"!==r)throw new Q(\"MVT decoding error. Metadata property \\'\".concat(this._baseName,\"\\' is of type \\'category\\' but the MVT tile contained a feature property of type \\'\").concat(r,\"\\': \\'\").concat(e,\"\\'\"),H.MVT);return at()(O()(MVTCategoryCodec.prototype),\"sourceToInternal\",this).call(this,t,e)}}]),MVTCategoryCodec}(ut);var ct=function(t){function MVTMetadata(){return h()(this,MVTMetadata),A()(this,O()(MVTMetadata).apply(this,arguments))}return R()(MVTMetadata,t),p()(MVTMetadata,[{key:\"setCodecs\",value:function setCodecs(){var t=this;Object.keys(this.properties).forEach(function(e){var r=t.properties[e],n=r.type;\"geometry\"!==n&&(r.codec=function MVTCodecFactory(t,e,r){switch(e){case\"number\":return new it(t,r);case\"category\":return new st(t,r);default:throw new Q(\"MVT decoding error. Feature property value of type \\'\".concat(e,\"\\' cannot be decoded.\"),H.MVT)}}(t,n,e))})}}]),MVTMetadata}(tt);function addLineString(t,e,r,n,a){var o,i,u,s,c;if(t.length>=4){o=[t[0],t[1]];for(var f=2;f<=t.length;f+=2)if(i=[t[f],t[f+1]],o[0]!==i[0]||o[1]!==i[1]){f+=2;break}for(u=getLineNormal(o,i);f<=t.length;f+=2){c=!(a&&a(f));var l=void 0;if(f<=t.length-2?l=[t[f],t[f+1]]:n&&(l=[t[2],t[3]]),!c||o[0]===i[0]&&o[1]===i[1]||(e.vertices[r]=o[0],e.normals[r++]=-u[0],e.vertices[r]=o[1],e.normals[r++]=-u[1],e.vertices[r]=o[0],e.normals[r++]=u[0],e.vertices[r]=o[1],e.normals[r++]=u[1],e.vertices[r]=i[0],e.normals[r++]=u[0],e.vertices[r]=i[1],e.normals[r++]=u[1],e.vertices[r]=o[0],e.normals[r++]=-u[0],e.vertices[r]=o[1],e.normals[r++]=-u[1],e.vertices[r]=i[0],e.normals[r++]=u[0],e.vertices[r]=i[1],e.normals[r++]=u[1],e.vertices[r]=i[0],e.normals[r++]=-u[0],e.vertices[r]=i[1],e.normals[r++]=-u[1]),!l||l[0]===i[0]&&l[1]===i[1])s=u;else if(s=getLineNormal(i,l),c){var h=getJoinNormal(u,s),d=h.turnLeft,p=h.joinNormal,y=d?u:neg(s),v=d?s:neg(u);e.vertices[r]=i[0],e.normals[r++]=0,e.vertices[r]=i[1],e.normals[r++]=n?1e-37:0,e.vertices[r]=i[0],e.normals[r++]=y[0],e.vertices[r]=i[1],e.normals[r++]=y[1],e.vertices[r]=i[0],e.normals[r++]=v[0],e.vertices[r]=i[1],e.normals[r++]=v[1],p&&(e.vertices[r]=i[0],e.normals[r++]=p[0],e.vertices[r]=i[1],e.normals[r++]=p[1],e.vertices[r]=i[0],e.normals[r++]=v[0],e.vertices[r]=i[1],e.normals[r++]=v[1],e.vertices[r]=i[0],e.normals[r++]=y[0],e.vertices[r]=i[1],e.normals[r++]=y[1])}o=i,i=l,u=s}}return r}function resizeBuffer(t,e){var r=new Float32Array(e);return r.set(t),r}var ft=24,lt=0,ht={vertices:new Float32Array(1048576),normals:new Float32Array(1048576)};function resizeBuffers(t){var e=lt+t;if(e>ht.vertices.length){var r=2*e;ht.vertices=resizeBuffer(ht.vertices,r),ht.normals=resizeBuffer(ht.normals,r)}}var dt=r(17),pt=2,yt=24,vt=0,mt={vertices:new Float32Array(2097152),normals:new Float32Array(2097152)};function polygonDecoder_resizeBuffers(t){var e=vt+t;if(e>mt.vertices.length){var r=2*e;mt.vertices=resizeBuffer(mt.vertices,r),mt.normals=resizeBuffer(mt.normals,r)}}function addVertex(t,e){mt.vertices[vt]=t[e],mt.normals[vt++]=0,mt.vertices[vt]=t[e+1],mt.normals[vt++]=0}function isClipped(t,e,r){return!!(t.clipped.includes(e)&&t.clipped.includes(r)&&t.clippedType[t.clipped.indexOf(e)]&t.clippedType[t.clipped.indexOf(r)])}function decodeGeom(t,e){switch(t){case Z.POINT:return function decodePoint(t){return{verticesArrayBuffer:t,vertices:new Float32Array(t),breakpoints:[]}}(e);case Z.LINE:return function decodeLine(t){var e=[],r=new Map;lt=0;for(var n=0;n<t.length;n++){for(var a=t[n],o=0;o<a.length;o++)resizeBuffers(ft*a[o].length),lt=addLineString(a[o],ht,lt);r.set(e.length,0===e.length?{start:0,end:lt}:{start:r.get(e.length-1).end,end:lt}),e.push(lt)}for(var i=new ArrayBuffer(4*lt),u=new ArrayBuffer(4*lt),s=new Float32Array(i),c=new Float32Array(u),f=0;f<lt;f++)s[f]=ht.vertices[f],c[f]=ht.normals[f];return{vertices:s,normals:c,verticesArrayBuffer:i,normalsArrayBuffer:u,featureIDToVertexIndex:r,breakpoints:e}}(e);case Z.POLYGON:return function decodePolygon(t){var e=[],r=new Map;vt=0;for(var n=0;n<t.length;n++){for(var a=t[n],o=function _loop(t){var e=a[t],r=dt(e.flat,e.holes);polygonDecoder_resizeBuffers(pt*r.length+yt*e.flat.length);for(var n=0;n<r.length;n++)addVertex(e.flat,2*r[n]);vt=addLineString(e.flat,mt,vt,!0,function(t){return e.holes.includes((t-2)/2)||isClipped(e,t-4,t-2)})},i=0;i<a.length;i++)o(i);r.set(e.length,0===e.length?{start:0,end:vt}:{start:r.get(e.length-1).end,end:vt}),e.push(vt)}for(var u=new ArrayBuffer(4*vt),s=new ArrayBuffer(4*vt),c=new Float32Array(u),f=new Float32Array(s),l=0;l<vt;l++)c[l]=mt.vertices[l],f[l]=mt.normals[l];return{vertices:c,normals:f,verticesArrayBuffer:u,normalsArrayBuffer:s,featureIDToVertexIndex:r,breakpoints:e}}(e);default:throw new Q(\"Unimplemented geometry type: \\'\".concat(t,\"\\'.\"),H.NOT_SUPPORTED)}}var gt=function DummyDataframe(t){var e=t.active,r=t.center,n=t.properties,a=t.propertiesArrayBuffer,o=t.scale,i=t.type,u=t.geom,s=t.size,c=t.metadata;h()(this,DummyDataframe),this.active=e,this.center=r,this.properties=n,this.propertiesArrayBuffer=a,this.scale=o,this.type=i,this.decodedGeom=decodeGeom(i,u),this.numVertex=i===Z.POINT?3*s:this.decodedGeom.vertices.length/2,this.numFeatures=i===Z.POINT?s:this.decodedGeom.breakpoints.length||this.numVertex,this.propertyTex=[],this.metadata=c,this.propertyCount=0,this._aabb=function computeAABB(t,e){switch(e){case Z.POINT:return[];case Z.LINE:case Z.POLYGON:for(var r=[],n=0;n<t.length;n++){for(var a=t[n],o={minx:Number.POSITIVE_INFINITY,miny:Number.POSITIVE_INFINITY,maxx:Number.NEGATIVE_INFINITY,maxy:Number.NEGATIVE_INFINITY},i=0;i<a.length;i++)o=_updateAABBForGeometry(a[i],o,e);o.minx===Number.POSITIVE_INFINITY&&(o=null),r.push(o)}return r}}(u,i),this._centroids=computeCentroids(this.decodedGeom,i),this.t1=[.1,.1,.1,.1],this.t2=[.1,.1,.1,.1],this.t3=[.1,.1,.1,.1],this.t4=[.1,.1,.1,.1]},xt=1,_t=2,wt=3,bt={1:Z.POINT,2:Z.LINE,3:Z.POLYGON},Mt=function(){function MVTWorker(){h()(this,MVTWorker)}return p()(MVTWorker,[{key:\"onmessage\",value:function onmessage(t){this.processEvent(t).then(function(t){var e=[];t.dataframe.empty||(e.push(t.dataframe.propertiesArrayBuffer),e.push(t.dataframe.decodedGeom.verticesArrayBuffer),t.dataframe.decodedGeom.normalsArrayBuffer&&e.push(t.dataframe.decodedGeom.normalsArrayBuffer)),postMessage(t,e)})}},{key:\"processEvent\",value:function(){var t=f()(s.a.mark(function _callee(t){var e,r;return s.a.wrap(function _callee$(n){for(;;)switch(n.prev=n.next){case 0:return(e=t.data).metadata&&(this.castMetadata(e.metadata),this.metadata=e.metadata),n.next=4,this._requestDataframe(e.x,e.y,e.z,e.url,e.layerID,this.metadata);case 4:return r=n.sent,n.abrupt(\"return\",{mID:e.mID,dataframe:r});case 6:case\"end\":return n.stop()}},_callee,this)}));return function processEvent(e){return t.apply(this,arguments)}}()},{key:\"castMetadata\",value:function castMetadata(t){Object.setPrototypeOf(t,ct.prototype),t.setCodecs()}},{key:\"_requestDataframe\",value:function(){var t=f()(s.a.mark(function _callee2(t,e,r,n,a,o){var i,u;return s.a.wrap(function _callee2$(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,fetch(n);case 2:return i=s.sent,s.next=5,this.urlToDataframeTransformer(i,t,e,r,a,o);case 5:return u=s.sent,s.abrupt(\"return\",u);case 7:case\"end\":return s.stop()}},_callee2,this)}));return function _requestDataframe(e,r,n,a,o,i){return t.apply(this,arguments)}}()},{key:\"urlToDataframeTransformer\",value:function(){var t=f()(s.a.mark(function _callee3(t,e,r,n,a,o){var i,u,c,f,l,h,d,p,m,g,x;return s.a.wrap(function _callee3$(s){for(;;)switch(s.prev=s.next){case 0:return i=o.extent,s.next=3,t.arrayBuffer();case 3:if(0!==(u=s.sent).byteLength&&\"null\"!==t){s.next=6;break}return s.abrupt(\"return\",{empty:!0});case 6:if(c=new y.VectorTile(new v(u)),!(Object.keys(c.layers).length>1)||a){s.next=9;break}throw new W(\"LayerID parameter wasn\\'t specified and the MVT tile contains multiple layers: \".concat(JSON.stringify(Object.keys(c.layers)),\".\"),G.MISSING_REQUIRED);case 9:if(f=c.layers[a||Object.keys(c.layers)[0]]){s.next=12;break}return s.abrupt(\"return\",{empty:!0});case 12:return l=this._decodeMVTLayer(f,o,i),h=l.geometries,d=l.properties,p=l.propertiesArrayBuffer,m=l.numFeatures,g=getRsysFromTile(e,r,n),x=this._generateDataFrame(g,h,d,p,m,o.geomType,o),s.abrupt(\"return\",x);case 16:case\"end\":return s.stop()}},_callee3,this)}));return function urlToDataframeTransformer(e,r,n,a,o,i){return t.apply(this,arguments)}}()},{key:\"_decodeMVTLayer\",value:function _decodeMVTLayer(t,e,r){if(!t.length)return{properties:[],geometries:{},propertiesArrayBuffer:[],numFeatures:0};switch(e.geomType||(e.geomType=this._autoDiscoverType(t)),e.geomType){case Z.POINT:var n=new ArrayBuffer(2*t.length*3*4);return this._decode(t,e,r,n);case Z.LINE:return this._decode(t,e,r,[],decodeLines);case Z.POLYGON:return this._decode(t,e,r,[],decodePolygons);default:throw new W(\"MVT: invalid geometry type \\'\".concat(e.geomType,\"\\'\"),G.INCORRECT_TYPE)}}},{key:\"_autoDiscoverType\",value:function _autoDiscoverType(t){var e=t.feature(0).type;switch(e){case xt:return Z.POINT;case _t:return Z.LINE;case wt:return Z.POLYGON;default:throw new W(\"MVT: invalid geometry type \\'\".concat(e,\"\\'\"),G.INCORRECT_TYPE)}}},{key:\"_decode\",value:function _decode(t,e,r,n,a){var o,i=0;n&&(o=new Float32Array(n));for(var u=this._initializePropertyArrays(e,t.length),s=u.properties,c=u.propertiesArrayBuffer,f=this._scalarPropertyCodecs(e),l=this._rangePropertyCodecs(e),h=0;h<t.length;h++){var d=t.feature(h);this._checkType(d,e.geomType);var p=d.loadGeometry();if(a){var y=a(p,r);n.push(y)}else{var v=2*p[0][0].x/r-1,m=2*(1-p[0][0].y/r)-1;if(v<-1||v>=1||m<-1||m>=1)continue;o[6*i+0]=v,o[6*i+1]=m,o[6*i+2]=v,o[6*i+3]=m,o[6*i+4]=v,o[6*i+5]=m}if(void 0===d.properties[e.idProperty])throw new Q(\"MVT feature with undefined idProperty \\'\".concat(e.idProperty,\"\\'\"),H.MVT);this._decodeProperties(e,f,l,s,d,i),i++}return{properties:s,propertiesArrayBuffer:c,geometries:n,numFeatures:i}}},{key:\"_checkType\",value:function _checkType(t,e){var r=t.type,n=bt[r];if(n!==e)throw new Q(\"MVT: mixed geometry types in the same layer. Layer has type: \".concat(e,\" but feature was \").concat(n),H.MVT)}},{key:\"_initializePropertyArrays\",value:function _initializePropertyArrays(t,e){var r=this._getPropertyNamesFrom(t),n=this._getPropertiesFor(r,e);return{propertyNames:r,properties:n.properties,propertiesArrayBuffer:n.propertiesArrayBuffer}}},{key:\"_getSourcePropertyNamesFrom\",value:function _getSourcePropertyNamesFrom(t){return t.propertyKeys.filter(function(e){return\"geometry\"!==t.properties[t.baseName(e)].type})}},{key:\"_getPropertyNamesFrom\",value:function _getPropertyNamesFrom(t){var e=[];return this._getSourcePropertyNamesFrom(t).forEach(function(r){t.decodedProperties(r).forEach(function(t){e.push(t)})}),e}},{key:\"_getPropertiesFor\",value:function _getPropertiesFor(t,e){for(var r={},n=1024*Math.ceil(e/1024),a=new ArrayBuffer(4*n*t.length),o=a,i=0;i<t.length;i++){r[t[i]]=new Float32Array(a,4*i*n,n)}return{properties:r,propertiesArrayBuffer:o}}},{key:\"_scalarPropertyCodecs\",value:function _scalarPropertyCodecs(t){return this._getSourcePropertyNamesFrom(t).map(function(e){return[e,t.codec(e)]}).filter(function(t){var e=i()(t,2);e[0];return!e[1].isRange()})}},{key:\"_rangePropertyCodecs\",value:function _rangePropertyCodecs(t){return this._getSourcePropertyNamesFrom(t).map(function(e){return[e,t.decodedProperties(e),t.codec(e)]}).filter(function(t){var e=i()(t,3);e[0],e[1];return e[2].isRange()})}},{key:\"_decodeProperties\",value:function _decodeProperties(t,e,r,n,a,o){for(var u=e.length,s=0;s<u;s++){var c=i()(e[s],2),f=c[0],l=c[1],h=a.properties[f];n[f][o]=l.sourceToInternal(t,h)}u=r.length;for(var d=0;d<u;d++){var p=i()(r[d],3),y=(f=p[0],i()(p[1],2)),v=y[0],m=y[1],g=(l=p[2],a.properties[f]),x=l.sourceToInternal(t,g),_=i()(x,2),w=_[0],b=_[1];n[v][o]=w,n[m][o]=b}}},{key:\"_generateDataFrame\",value:function _generateDataFrame(t,e,r,n,a,o,i){return new gt({active:!1,center:t.center,geom:e,properties:r,propertiesArrayBuffer:n,scale:t.scale,size:a,type:o,metadata:i})}}]),MVTWorker}(),Tt=[\"year\",\"month\",\"day\",\"hour\",\"minute\",\"second\"],Pt=[1,1,1,0,0,0],kt=0,It=1,Ft=2,Et=3,Ct=4,Nt=5,Vt=864e5,St=36e5,At=6e4,Dt=1e3;function startLevel(t){for(var e=Tt.length-1;e>0&&t[Tt[e]]===Pt[e];)--e;return e}function pad(t,e){return t.toString().padStart(e,\"0\")}function parsedValue(t){var e=msToDate(t);return{year:e.getUTCFullYear(),month:e.getUTCMonth()+1,day:e.getUTCDate(),hour:e.getUTCHours(),minute:e.getUTCMinutes(),second:e.getUTCSeconds()}}function invalidPeriod(t,e){throw new Error(\"Invalid period of \".concat(e,\" between \").concat(t.v1,\" and \").concat(t.v2))}function yearWeek(t,e){var r=function isoDow(t,e,r){var n=new Date(t,e-1,r).getDay();return 0===n?7:n}(t,1,1),n=r>4?9-r:2-r;return Math.abs(e-n)%7!=0?[]:e<n?yearWeek(t-1,e+=Math.round((Date.UTC(t,0,1)-Date.UTC(t-1,0,1))/Vt)):Date.UTC(t,0,1)+(e-1+3)*Vt>=Date.UTC(t+1,0,1)?yearWeek(t+1,e-=Math.round((Date.UTC(t+1,0,1)-Date.UTC(t,0,1))/Vt)):[t,1+Math.round((e-n)/7)]}function periodISO(t,e){var r=parsedValue(t),n=parsedValue(e),a=startLevel(r),o=startLevel(n),u={v1:t,v2:e,t1:r,t2:n};return Math.max(a,o)===kt?function yearsPeriod(t){var e=t.t2.year-t.t1.year;return 1e3===e&&(t.t1.year-1)%1e3==0?\"M\".concat(1+(t.t1.year-1)/1e3):100===e&&(t.t1.year-1)%100==0?\"C\".concat(1+(t.t1.year-1)/100):10===e&&t.t1.year%10==0?\"D\".concat(t.t1.year/10):1===e?pad(t.t1.year,4):void invalidPeriod(\"\".concat(e,\" years\"))}(u):Math.max(a,o)===It?function monthsPeriod(t){var e=12*t.t2.year+t.t2.month-12*t.t1.year-t.t1.month;return 6===e&&(t.t1.month-1)%6==0?\"\".concat(pad(t.t1.year,4),\"S\").concat(1+(t.t1.month-1)/6):4===e?\"\".concat(pad(t.t1.year,4),\"t\").concat(1+(t.t1.month-1)/4):3===e?\"\".concat(pad(t.t1.year,4),\"-Q\").concat(1+(t.t1.month-1)/3):1===e?\"\".concat(pad(t.t1.year,4),\"-\").concat(pad(t.t1.month,2)):void invalidPeriod(\"\".concat(e,\" months\"))}(u):Math.max(a,o)===Ft?function daysPeriod(t){var e=Math.round((t.v2-t.v1)/Vt);if(1===e)return\"\".concat(pad(t.t1.year,4),\"-\").concat(pad(t.t1.month,2),\"-\").concat(pad(t.t1.day,2));if(7===e){var r=t.t1.year,n=Date.UTC(r,0,1),a=yearWeek(r,1+Math.round((t.v1-n)/Vt)),o=i()(a,2),u=o[0],s=o[1];if(u&&s)return\"\".concat(pad(u,4),\"-W\").concat(pad(s,2));invalidPeriod(\"7 days\")}else invalidPeriod(\"\".concat(e,\" days\"))}(u):Math.max(a,o)===Et?function hoursPeriod(t){var e=Math.round((t.v2-t.v1)/St);if(1===e)return\"\".concat(pad(t.t1.year,4),\"-\").concat(pad(t.t1.month,2),\"-\").concat(pad(t.t1.day,2),\"T\").concat(pad(t.t1.hour,2));invalidPeriod(\"\".concat(e,\" hours\"))}(u):Math.max(a,o)===Ct?function minutesPeriod(t){var e=Math.round((t.v2-t.v1)/At);if(1===e)return\"\".concat(pad(t.t1.year,4),\"-\").concat(pad(t.t1.month,2),\"-\").concat(pad(t.t1.day,2),\"T\").concat(pad(t.t1.hour,2),\":\").concat(pad(t.t1.minute,2));invalidPeriod(\"\".concat(e,\" minutes\"))}(u):Math.max(a,o)===Nt?function secondsPeriod(t){var e=Math.round((t.v2-t.v1)/Dt);if(1===e)return\"\".concat(pad(t.t1.year,4),\"-\").concat(pad(t.t1.month,2),\"-\").concat(pad(t.t1.day,2),\"T\").concat(pad(t.t1.hour,2),\":\").concat(pad(t.t1.minute,2),\":\").concat(pad(t.t1.second,2));invalidPeriod(\"\".concat(e,\" seconds\"))}(u):void invalidPeriod(u,\"fractional seconds\")}var Ot=function(t){function CartoParsingError(t){var e;h()(this,CartoParsingError);return(e=A()(this,O()(CartoParsingError).call(this,{message:t,type:\"[Error]\"}))).name=\"CartoParsingError\",e}return R()(CartoParsingError,t),CartoParsingError}(q),Lt=function(){function IsoParser(t){h()(this,IsoParser),this._format=t}return p()(IsoParser,[{key:\"check\",value:function check(t){return t.match(this._format)}}]),IsoParser}();function fieldDefault(t,e){return void 0===t?e:Number(t)}function dateFields(t){return{year:fieldDefault(t.year,1),month:fieldDefault(t.month,1),day:fieldDefault(t.day,1),hour:fieldDefault(t.hour,0),minute:fieldDefault(t.minute,0),second:fieldDefault(t.second,0)}}function fieldsFromMatch(t){return dateFields({year:t[1],month:t[2],day:t[3],hour:t[4],minute:t[5],second:t[6]})}var Rt=function(t){function YMDHMSParser(){return h()(this,YMDHMSParser),A()(this,O()(YMDHMSParser).call(this,/^(\\\\d\\\\d\\\\d\\\\d)(?:\\\\-?(\\\\d\\\\d)(?:\\\\-?(\\\\d\\\\d)(?:[T\\\\s]?(\\\\d\\\\d)(?:\\\\:(\\\\d\\\\d)(?:\\\\:(\\\\d\\\\d))?)?)?)?)?$/))}return R()(YMDHMSParser,t),p()(YMDHMSParser,[{key:\"parse\",value:function parse(t){var e=this.check(t)||[],r=e.slice(),n=[1,2,3,4,5,6].find(function(t){return void 0===r[t]})||7;return 1===n?r[1]=2:r[n-1]=Number(r[n-1])+1,[fieldsFromMatch(e),fieldsFromMatch(r)]}}]),YMDHMSParser}(Lt),Bt=function(t){function MillenniumParser(){return h()(this,MillenniumParser),A()(this,O()(MillenniumParser).call(this,/^M(\\\\d+)$/))}return R()(MillenniumParser,t),p()(MillenniumParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=function year(t){return 1e3*(t-1)+1};return[dateFields({year:n(r)}),dateFields({year:n(r+1)})]}}]),MillenniumParser}(Lt),qt=function(t){function CenturyParser(){return h()(this,CenturyParser),A()(this,O()(CenturyParser).call(this,/^C(\\\\d+)$/))}return R()(CenturyParser,t),p()(CenturyParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=function year(t){return 100*(t-1)+1};return[dateFields({year:n(r)}),dateFields({year:n(r+1)})]}}]),CenturyParser}(Lt),Wt=function(t){function DecadeParser(){return h()(this,DecadeParser),A()(this,O()(DecadeParser).call(this,/^D(\\\\d+)$/))}return R()(DecadeParser,t),p()(DecadeParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=function year(t){return 10*t};return[dateFields({year:n(r)}),dateFields({year:n(r+1)})]}}]),DecadeParser}(Lt),Gt=function(t){function SemesterParser(){return h()(this,SemesterParser),A()(this,O()(SemesterParser).call(this,/^(\\\\d\\\\d\\\\d\\\\d)S(\\\\d)$/))}return R()(SemesterParser,t),p()(SemesterParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=Number(e[2]),a=function month(t){return 6*(t-1)+1};return[dateFields({year:r,month:a(n)}),dateFields({year:r,month:a(n+1)})]}}]),SemesterParser}(Lt),Zt=function(t){function TrimesterParser(){return h()(this,TrimesterParser),A()(this,O()(TrimesterParser).call(this,/^(\\\\d\\\\d\\\\d\\\\d)t(\\\\d)$/))}return R()(TrimesterParser,t),p()(TrimesterParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=Number(e[2]),a=function month(t){return 4*(t-1)+1};return[dateFields({year:r,month:a(n)}),dateFields({year:r,month:a(n+1)})]}}]),TrimesterParser}(Lt),jt=function(t){function QuarterParser(){return h()(this,QuarterParser),A()(this,O()(QuarterParser).call(this,/^(\\\\d\\\\d\\\\d\\\\d)\\\\-?Q(\\\\d)$/))}return R()(QuarterParser,t),p()(QuarterParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=Number(e[2]),a=function month(t){return 3*(t-1)+1};return[dateFields({year:r,month:a(n)}),dateFields({year:r,month:a(n+1)})]}}]),QuarterParser}(Lt);function startOfIsoWeek(t,e){var r=function parseISO_isoDow(t,e,r){var n=new Date(t,e-1,r).getDay();return 0===n?7:n}(t,1,1);return function addDays(t,e){var r=new Date(t.valueOf());return r.setDate(r.getDate()+e),r}(new Date(t,0,r>4?9-r:2-r),7*(e-1))}var Ut=function(t){function WeekParser(){return h()(this,WeekParser),A()(this,O()(WeekParser).call(this,/^(\\\\d\\\\d\\\\d\\\\d)\\\\-?W(\\\\d\\\\d)$/))}return R()(WeekParser,t),p()(WeekParser,[{key:\"parse\",value:function parse(t){var e=this.check(t),r=Number(e[1]),n=Number(e[2]),a=startOfIsoWeek(r,n),o=startOfIsoWeek(r,n+1),i=function fields(t){return{year:t.getFullYear(),month:t.getMonth()+1,day:t.getDate()}};return[dateFields(i(a)),dateFields(i(o))]}}]),WeekParser}(Lt),zt=[new Bt,new qt,new Wt,new Gt,new Zt,new jt,new Ut,new Rt];function parseISO(t){var e=function findParser(t){return zt.find(function(e){return e.check(t)})}(t=t||\"\");if(!e)throw new Ot(\"No date parser found for \".concat(t));return e.parse(t)}var Yt=function(){function TimeZoneDate(t,e){h()(this,TimeZoneDate),this._value=t,this._date=msToDate(t),this._timeZone=e}return p()(TimeZoneDate,[{key:\"year\",get:function get(){return this._date.getUTCFullYear()}},{key:\"month\",get:function get(){return this._date.getUTCMonth()+1}},{key:\"day\",get:function get(){return this._date.getUTCDate()}},{key:\"hour\",get:function get(){return this._date.getUTCHours()}},{key:\"minute\",get:function get(){return this._date.getUTCMinutes()}},{key:\"second\",get:function get(){return this._date.getUTCSeconds()}},{key:\"text\",get:function get(){return periodISO(this._date.getTime(),this._date.getTime()+1e3)}},{key:\"timeZone\",get:function get(){return this._timeZone}}],[{key:\"fromValue\",value:function fromValue(t,e){return new TimeZoneDate(t,e)}},{key:\"from\",value:function from(t,e,r,n,a,o,i){return this.fromValue(Date.UTC(t,(e||1)-1,r,n,a,o),i)}}]),TimeZoneDate}(),Qt=function(){function TimeRange(t,e,r,n){if(h()(this,TimeRange),this._startValue=r,this._endValue=n,r&&n)this._iso=periodISO(r,n);else if(!r&&!n&&e){var a=function _startEndTimeValues(t){return parseISO(t).map(_timeValue)}(e);this._iso=e,this._startValue=a[0],this._endValue=a[1]}this._timeZone=t}return p()(TimeRange,[{key:\"timeZone\",get:function get(){return this._timeZone}},{key:\"iso\",get:function get(){return this._iso}},{key:\"startValue\",get:function get(){return this._startValue}},{key:\"endValue\",get:function get(){return this._endValue}},{key:\"startDate\",get:function get(){return Yt.fromValue(this._startValue,this._timeZone)}},{key:\"endDate\",get:function get(){return Yt.fromValue(this._endValue,this._timeZone)}}]),TimeRange}();function _timeValue(t){return Date.UTC(t.year,t.month-1,t.day,t.hour,t.minute,t.second)}Math.PI;var Ht=6378137;Math.PI;function msToDate(t){return new Date(t)}function castTimeRange(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return void 0===t||function isTimeRange(t){return t instanceof Qt}(t)?t&&e?util_timeRange({iso:t._iso,timeZone:e}):t:\"string\"==typeof t?util_timeRange({iso:t,timeZone:e}):void 0}function util_timeRange(t){var e=t.start,r=t.end,n=t.iso,a=t.timeZone;return new Qt(a,n,e,r)}var $t=function(t){function WindshaftDateCodec(t,e){var r;h()(this,WindshaftDateCodec),r=A()(this,O()(WindshaftDateCodec).call(this,t,e));var n=t.stats(e).min;return r._min_ms=1e3*n,r._min_date=msToDate(r._min_ms),r}return R()(WindshaftDateCodec,t),p()(WindshaftDateCodec,[{key:\"sourceToInternal\",value:function sourceToInternal(t,e){return msToDate(1e3*e)-this._min_date}},{key:\"internalToExternal\",value:function internalToExternal(t,e){var r=e;return msToDate(r+=this._min_ms)}},{key:\"externalToSource\",value:function externalToSource(t,e){return e.getTime()/1e3}},{key:\"sourceToExternal\",value:function sourceToExternal(t,e){return function asDate(t){if(t instanceof Date)return t;return msToDate(1e3*t)}(e)}},{key:\"inlineInternalMatch\",value:function inlineInternalMatch(t,e){var r=e._min_ms-this._min_ms;return\"(\".concat(t,\"-\").concat(r.toFixed(20),\")\")}}]),WindshaftDateCodec}($);var Xt=function(t){function TimeRangeCodec(t,e){var r;h()(this,TimeRangeCodec),r=A()(this,O()(TimeRangeCodec).call(this,t,e));var n=t.stats(e),a=n.min,o=n.grouping&&n.grouping.timezone,i=util_timeRange({timeZone:o,iso:a});return r._min=i.startValue/1e3,r._timeZone=o,r}return R()(TimeRangeCodec,t),p()(TimeRangeCodec,[{key:\"isRange\",value:function isRange(){return!0}},{key:\"sourceToInternal\",value:function sourceToInternal(t,e){var r=this,n=util_timeRange({iso:e});return[n.startValue/1e3,n.endValue/1e3].map(function(t){return t-r._min})}},{key:\"internalToExternal\",value:function internalToExternal(t,e){var r=i()(e,2),n=r[0],a=r[1];return util_timeRange({start:1e3*(n+this._min),end:1e3*(a+this._min),timeZone:this._timeZone})}},{key:\"externalToSource\",value:function externalToSource(t,e){return castTimeRange(e,this._timeZone)._iso}},{key:\"sourceToExternal\",value:function sourceToExternal(t,e){return util_timeRange({iso:e,timeZone:this._timeZone})}},{key:\"inlineInternalMatch\",value:function inlineInternalMatch(t,e){var r=e._min.getTime()-this._min.getTime();return\"(\".concat(t,\"-\").concat(r.toFixed(20),\")\")}}]),TimeRangeCodec}($),Jt=function(t){function CartoMapsAPIError(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Kt.DEFAULT;return h()(this,CartoMapsAPIError),(e=A()(this,O()(CartoMapsAPIError).call(this,{message:t,type:r}))).name=\"CartoMapsAPIError\",e}return R()(CartoMapsAPIError,t),CartoMapsAPIError}(q),Kt={DEFAULT:\"[Error]\",SQL:\"[SQL]\",NOT_SUPPORTED:\"[Not supported]\",SECURITY:\"[Security]\"};var te=function(t){function WindshaftMetadata(){var t,e;h()(this,WindshaftMetadata);for(var r=arguments.length,n=new Array(r),a=0;a<r;a++)n[a]=arguments[a];return(e=A()(this,(t=O()(WindshaftMetadata)).call.apply(t,[this].concat(n)))).propertyKeys=[],e.baseNames={},Object.keys(e.properties).forEach(function(t){var r=e.properties[t];r.aggregations?Object.values(r.aggregations).forEach(function(r){e._addProperty(t,r)}):r.dimension?r.dimension.range?(r.dimension.range.forEach(function(r){e._addProperty(t,r,!1)}),e._addProperty(t,r.dimension.propertyName)):e._addProperty(t,r.dimension.propertyName):e._addProperty(t,t)}),e}return R()(WindshaftMetadata,t),p()(WindshaftMetadata,[{key:\"_addProperty\",value:function _addProperty(t,e){var r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];this.baseNames[e]=t,r&&this.propertyKeys.push(e)}},{key:\"_dimensionInfo\",value:function _dimensionInfo(t){var e=this.baseName(t)||t,r=this.properties[e],n=null;e!==t&&e!==t&&r.dimension&&(n=r.dimension);var a=r.type,o=n?function dimensionBaseType(t){return t.type}(n):a;return{baseName:e,column:r,dimension:n,dataframeType:n?function dimensionType(t,e){if(t.range)return\"date\";return t.type}(n):o,baseType:a,sourceType:o}}},{key:\"baseName\",value:function baseName(t){return this.baseNames[t]}},{key:\"decodedProperties\",value:function decodedProperties(t){var e=this._dimensionInfo(t).dimension;return e&&e.grouping&&e.range?e.range:at()(O()(WindshaftMetadata.prototype),\"decodedProperties\",this).call(this,t)}},{key:\"stats\",value:function stats(t){var e=this._dimensionInfo(t).dimension;return e&&e.grouping?e:at()(O()(WindshaftMetadata.prototype),\"stats\",this).call(this,t)}},{key:\"setCodecs\",value:function setCodecs(){!function setMetadataCodecs(t){Object.keys(t.properties).forEach(function(e){var r=t.properties[e],n=r.type;if(\"geometry\"!==n){var a=r.dimension?r.dimension.type:null,o=a?r.dimension.propertyName:e,i=\"category\"===a&&r.dimension.range?\"timerange\":a;r.codec=function windshaftCodecFactory(t,e,r){switch(e){case\"number\":return new ot(t,r);case\"category\":return new ut(t,r);case\"date\":return new $t(t,r);case\"timerange\":return new Xt(t,r);default:throw new Jt(\"Windshaft MVT decoding error. Feature property value of type \\'\".concat(e,\"\\' cannot be decoded.\"),Kt.NOT_SUPPORTED)}}(t,i||n,o||e)}})}(this)}},{key:\"sourcePropertyName\",value:function sourcePropertyName(t){var e=this.baseName(t),r=this.properties[e].dimension;return r&&r.range?r.propertyName:t}}]),WindshaftMetadata}(ct);var ee=function(t){function WindshaftWorker(){return h()(this,WindshaftWorker),A()(this,O()(WindshaftWorker).apply(this,arguments))}return R()(WindshaftWorker,t),p()(WindshaftWorker,[{key:\"castMetadata\",value:function castMetadata(t){Object.setPrototypeOf(t,te.prototype),t.setCodecs()}}]),WindshaftWorker}(Mt);const re={MVT:new Mt,windshaft:new ee};onmessage=function(t){return re[t.data.workerName].onmessage(t)}}]);', \"/dist/carto-vl-70c6f9f887e8887f697f.worker.min.js\");\n    };\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\n\\nuniform float orderMinWidth;\\nuniform float orderMaxWidth;\\nuniform vec2 resolution;\\nuniform mat4 matrix;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D widthTex;\\nuniform sampler2D strokeColorTex;\\nuniform sampler2D strokeWidthTex;\\nuniform sampler2D filterTex;\\n\\nvarying highp vec4 color;\\nvarying highp vec4 stroke;\\nvarying highp float dp;\\nvarying highp float fillScale;\\nvarying highp float strokeScale;\\nvarying highp vec2 pointCoord;\\n\\nfloat decodeWidth(vec2 enc) {\\n  return enc.x*(255.*4.) + 4.*enc.y;\\n}\\n\\n$propertyPreface\\n$transform_preface\\n\\nvec2 transform(vec2 p){\\n    return $transform_inline(p*resolution*0.5)/resolution*2.;\\n}\\n\\nvoid main(void) {\\n  color = texture2D(colorTex, abs(featureID));\\n  stroke = texture2D(strokeColorTex, abs(featureID));\\n  float filtering = texture2D(filterTex, abs(featureID)).a;\\n  color.a *= filtering;\\n  stroke.a *= filtering;\\n  float size = decodeWidth(texture2D(widthTex, abs(featureID)).rg);\\n  float fillSize = size;\\n  float strokeSize = decodeWidth(texture2D(strokeWidthTex, abs(featureID)).rg);\\n  size += strokeSize;\\n  fillScale = min(size / fillSize, 1.);\\n  strokeScale = size / max(0.001, (fillSize - strokeSize));\\n  if (fillScale == strokeScale) {\\n    stroke.a = 0.;\\n  }\\n  dp = 1.0 / (size + 1.);\\n  float sizeNormalizer = (size +1.)/size;\\n\\n  vec4 p =  matrix*vec4(vertexPosition, 0., 1.);\\n  p/=p.w;\\n  vec2 size2 = (2.*size+4.)/resolution;\\n\\n    if (featureID.y<0.){\\n        pointCoord = vec2(0.866025, -0.5)*2.*sizeNormalizer;\\n        p.xy += transform(size2*vec2(0.866025, -0.5));\\n    }else if (featureID.x<0.){\\n        pointCoord = vec2(-0.866025, -0.5)*2.*sizeNormalizer;\\n        p.xy += transform(size2*vec2(-0.866025, -0.5));\\n    }else{\\n        pointCoord = vec2(0., 1.)*2.*sizeNormalizer;\\n        p.xy += transform(vec2(0.,size2.y));\\n    }\\n\\n  if (size == 0. || (stroke.a == 0. && color.a == 0.) || size < orderMinWidth || size >= orderMaxWidth) {\\n    p.z = p.w*2.;\\n  }\\n\\n  gl_Position = p;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nvarying lowp vec4 color;\\nvarying lowp vec4 stroke;\\nvarying highp float dp;\\nvarying highp float fillScale;\\nvarying highp float strokeScale;\\nvarying highp vec2 pointCoord;\\n\\nfloat distanceAntialias(vec2 p){\\n    // return length(p) > 1 ? 0. : 1. ; // to disable antialias\\n    return 1. - smoothstep(1.-dp*1.4142, 1.+dp*1.4142, length(p));\\n}\\n\\nvoid main(void) {\\n    vec2 p = pointCoord;\\n    vec4 c = color;\\n\\n    vec4 s = stroke;\\n\\n    c.a *= distanceAntialias(p*fillScale);\\n    c.rgb*=c.a;\\n\\n    s.a *= distanceAntialias(p);\\n    s.a *= 1.-distanceAntialias((strokeScale)*p);\\n    s.rgb*=s.a;\\n\\n    c=s+(1.-s.a)*c;\\n\\n    gl_FragColor = c;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"// Line Vertex Shader\\nprecision highp float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\nattribute vec2 normal;\\n\\nuniform float normalScale;\\nuniform vec2 resolution;\\nuniform mat4 matrix;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D widthTex;\\nuniform sampler2D filterTex;\\n\\nvarying lowp vec4 color;\\n\\nfloat decodeWidth(vec2 enc) {\\n  return enc.x*(255.*4.) + 4.*enc.y;\\n}\\n\\n$propertyPreface\\n$transform_preface\\n\\nvoid main(void) {\\n    color = texture2D(colorTex, featureID);\\n    float filtering = texture2D(filterTex, featureID).a;\\n    color.a *= filtering;\\n    color.rgb *= color.a; // premultiplied-alpha\\n    float size = decodeWidth(texture2D(widthTex, featureID).rg);\\n\\n    // 64 is computed based on RTT_WIDTH and the depth buffer precision\\n    // 64 = 2^(BUFFER_BITS)/RTT_WIDTH = 2^16/1024 = 64\\n    float z = featureID.y * 63. / 64. + featureID.x / (64.);\\n\\n    // Set z range (-1, 1)\\n    z = z * 2. - 1.;\\n\\n    vec2 n = normal*size*normalScale;\\n    vec4 p =  matrix*vec4(vertexPosition+n, 0., 1.);\\n    p/=p.w;\\n\\n    p.xy = $transform_inline(p.xy*resolution)/resolution;\\n    if (size==0. || color.a==0.){\\n        p.x=10000.;\\n    }\\n    p.z=z;\\n    gl_Position  = p;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision highp float;\\n\\nvarying lowp vec4 color;\\n\\nvoid main(void) {\\n    gl_FragColor = color;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision mediump float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\nattribute vec2 normal;\\n\\nuniform float normalScale;\\nuniform vec2 resolution;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D strokeColorTex;\\nuniform sampler2D strokeWidthTex;\\nuniform sampler2D filterTex;\\nuniform mat4 matrix;\\n\\nvarying lowp vec4 color;\\n\\nfloat decodeWidth(vec2 enc) {\\n  return enc.x*(255.*4.) + 4.*enc.y;\\n}\\n\\n$propertyPreface\\n$transform_preface\\n\\nvoid main(void) {\\n    // 64 is computed based on RTT_WIDTH and the depth buffer precision\\n    // 64 = 2^(BUFFER_BITS)/RTT_WIDTH = 2^16/1024 = 64\\n    float z = featureID.y * 63. / 64. + featureID.x / 64.;\\n\\n    vec4 c;\\n    if (normal == vec2(0.)){\\n        c = texture2D(colorTex, featureID);\\n    }else{\\n        z = mod(z + (z > 0.5 ? -1./64. : 1./64.), 1.);\\n        c = texture2D(strokeColorTex, featureID);\\n    }\\n    z = 2.*z - 1.;\\n    float filtering = texture2D(filterTex, featureID).a;\\n    c.a *= filtering;\\n    float size = decodeWidth(texture2D(strokeWidthTex, featureID).rg);\\n\\n    vec2 n = normal*size*normalScale;\\n    vec4 p =  matrix*vec4(vertexPosition+n, 0., 1.);\\n    p/=p.w;\\n\\n    p.xy = $transform_inline(p.xy*resolution*0.5)/resolution*2.;\\n\\n    if (c.a==0.){\\n        p.x=10000.;\\n    }\\n    p.z=z;\\n    color = vec4(c.rgb*c.a, c.a);\\n    gl_Position  = p;\\n}\\n\";\n  }, function (e, t) {\n    e.exports = \"precision lowp float;\\n\\nvarying lowp vec4 color;\\n\\nvoid main(void) {\\n    gl_FragColor = color;\\n}\\n\";\n  },,,,,,,, function (e, t) {\n    e.exports = function _arrayWithoutHoles(e) {\n      if (Array.isArray(e)) {\n        for (var t = 0, r = new Array(e.length); t < e.length; t++) r[t] = e[t];\n\n        return r;\n      }\n    };\n  }, function (e, t) {\n    e.exports = function _nonIterableSpread() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n    };\n  }, function (e, t) {\n    e.exports = function _isNativeFunction(e) {\n      return -1 !== Function.toString.call(e).indexOf(\"[native code]\");\n    };\n  }, function (e, t) {\n    e.exports = function _iterableToArrayLimit(e, t) {\n      var r = [],\n          n = !0,\n          a = !1,\n          i = void 0;\n\n      try {\n        for (var o, u = e[Symbol.iterator](); !(n = (o = u.next()).done) && (r.push(o.value), !t || r.length !== t); n = !0);\n      } catch (e) {\n        a = !0, i = e;\n      } finally {\n        try {\n          n || null == u.return || u.return();\n        } finally {\n          if (a) throw i;\n        }\n      }\n\n      return r;\n    };\n  }, function (e, t) {\n    e.exports = function _objectWithoutPropertiesLoose(e, t) {\n      if (null == e) return {};\n      var r,\n          n,\n          a = {},\n          i = Object.keys(e);\n\n      for (n = 0; n < i.length; n++) r = i[n], t.indexOf(r) >= 0 || (a[r] = e[r]);\n\n      return a;\n    };\n  }, function (e, t, r) {\n    var n = function () {\n      return this || \"object\" == typeof self && self;\n    }() || Function(\"return this\")(),\n        a = n.regeneratorRuntime && Object.getOwnPropertyNames(n).indexOf(\"regeneratorRuntime\") >= 0,\n        i = a && n.regeneratorRuntime;\n\n    if (n.regeneratorRuntime = void 0, e.exports = r(59), a) n.regeneratorRuntime = i;else try {\n      delete n.regeneratorRuntime;\n    } catch (e) {\n      n.regeneratorRuntime = void 0;\n    }\n  }, function (e, t) {\n    !function (t) {\n      \"use strict\";\n\n      var r,\n          n = Object.prototype,\n          a = n.hasOwnProperty,\n          i = \"function\" == typeof Symbol ? Symbol : {},\n          o = i.iterator || \"@@iterator\",\n          u = i.asyncIterator || \"@@asyncIterator\",\n          s = i.toStringTag || \"@@toStringTag\",\n          c = \"object\" == typeof e,\n          l = t.regeneratorRuntime;\n      if (l) c && (e.exports = l);else {\n        (l = t.regeneratorRuntime = c ? e.exports : {}).wrap = wrap;\n        var f = \"suspendedStart\",\n            h = \"suspendedYield\",\n            d = \"executing\",\n            p = \"completed\",\n            m = {},\n            v = {};\n\n        v[o] = function () {\n          return this;\n        };\n\n        var y = Object.getPrototypeOf,\n            g = y && y(y(values([])));\n        g && g !== n && a.call(g, o) && (v = g);\n\n        var _ = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(v);\n\n        GeneratorFunction.prototype = _.constructor = GeneratorFunctionPrototype, GeneratorFunctionPrototype.constructor = GeneratorFunction, GeneratorFunctionPrototype[s] = GeneratorFunction.displayName = \"GeneratorFunction\", l.isGeneratorFunction = function (e) {\n          var t = \"function\" == typeof e && e.constructor;\n          return !!t && (t === GeneratorFunction || \"GeneratorFunction\" === (t.displayName || t.name));\n        }, l.mark = function (e) {\n          return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, s in e || (e[s] = \"GeneratorFunction\")), e.prototype = Object.create(_), e;\n        }, l.awrap = function (e) {\n          return {\n            __await: e\n          };\n        }, defineIteratorMethods(AsyncIterator.prototype), AsyncIterator.prototype[u] = function () {\n          return this;\n        }, l.AsyncIterator = AsyncIterator, l.async = function (e, t, r, n) {\n          var a = new AsyncIterator(wrap(e, t, r, n));\n          return l.isGeneratorFunction(t) ? a : a.next().then(function (e) {\n            return e.done ? e.value : a.next();\n          });\n        }, defineIteratorMethods(_), _[s] = \"Generator\", _[o] = function () {\n          return this;\n        }, _.toString = function () {\n          return \"[object Generator]\";\n        }, l.keys = function (e) {\n          var t = [];\n\n          for (var r in e) t.push(r);\n\n          return t.reverse(), function next() {\n            for (; t.length;) {\n              var r = t.pop();\n              if (r in e) return next.value = r, next.done = !1, next;\n            }\n\n            return next.done = !0, next;\n          };\n        }, l.values = values, Context.prototype = {\n          constructor: Context,\n          reset: function (e) {\n            if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = r, this.tryEntries.forEach(resetTryEntry), !e) for (var t in this) \"t\" === t.charAt(0) && a.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = r);\n          },\n          stop: function () {\n            this.done = !0;\n            var e = this.tryEntries[0].completion;\n            if (\"throw\" === e.type) throw e.arg;\n            return this.rval;\n          },\n          dispatchException: function (e) {\n            if (this.done) throw e;\n            var t = this;\n\n            function handle(n, a) {\n              return o.type = \"throw\", o.arg = e, t.next = n, a && (t.method = \"next\", t.arg = r), !!a;\n            }\n\n            for (var n = this.tryEntries.length - 1; n >= 0; --n) {\n              var i = this.tryEntries[n],\n                  o = i.completion;\n              if (\"root\" === i.tryLoc) return handle(\"end\");\n\n              if (i.tryLoc <= this.prev) {\n                var u = a.call(i, \"catchLoc\"),\n                    s = a.call(i, \"finallyLoc\");\n\n                if (u && s) {\n                  if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n                  if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n                } else if (u) {\n                  if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n                } else {\n                  if (!s) throw new Error(\"try statement without catch or finally\");\n                  if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n                }\n              }\n            }\n          },\n          abrupt: function (e, t) {\n            for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n              var n = this.tryEntries[r];\n\n              if (n.tryLoc <= this.prev && a.call(n, \"finallyLoc\") && this.prev < n.finallyLoc) {\n                var i = n;\n                break;\n              }\n            }\n\n            i && (\"break\" === e || \"continue\" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);\n            var o = i ? i.completion : {};\n            return o.type = e, o.arg = t, i ? (this.method = \"next\", this.next = i.finallyLoc, m) : this.complete(o);\n          },\n          complete: function (e, t) {\n            if (\"throw\" === e.type) throw e.arg;\n            return \"break\" === e.type || \"continue\" === e.type ? this.next = e.arg : \"return\" === e.type ? (this.rval = this.arg = e.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === e.type && t && (this.next = t), m;\n          },\n          finish: function (e) {\n            for (var t = this.tryEntries.length - 1; t >= 0; --t) {\n              var r = this.tryEntries[t];\n              if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), m;\n            }\n          },\n          catch: function (e) {\n            for (var t = this.tryEntries.length - 1; t >= 0; --t) {\n              var r = this.tryEntries[t];\n\n              if (r.tryLoc === e) {\n                var n = r.completion;\n\n                if (\"throw\" === n.type) {\n                  var a = n.arg;\n                  resetTryEntry(r);\n                }\n\n                return a;\n              }\n            }\n\n            throw new Error(\"illegal catch attempt\");\n          },\n          delegateYield: function (e, t, n) {\n            return this.delegate = {\n              iterator: values(e),\n              resultName: t,\n              nextLoc: n\n            }, \"next\" === this.method && (this.arg = r), m;\n          }\n        };\n      }\n\n      function wrap(e, t, r, n) {\n        var a = t && t.prototype instanceof Generator ? t : Generator,\n            i = Object.create(a.prototype),\n            o = new Context(n || []);\n        return i._invoke = function makeInvokeMethod(e, t, r) {\n          var n = f;\n          return function invoke(a, i) {\n            if (n === d) throw new Error(\"Generator is already running\");\n\n            if (n === p) {\n              if (\"throw\" === a) throw i;\n              return doneResult();\n            }\n\n            for (r.method = a, r.arg = i;;) {\n              var o = r.delegate;\n\n              if (o) {\n                var u = maybeInvokeDelegate(o, r);\n\n                if (u) {\n                  if (u === m) continue;\n                  return u;\n                }\n              }\n\n              if (\"next\" === r.method) r.sent = r._sent = r.arg;else if (\"throw\" === r.method) {\n                if (n === f) throw n = p, r.arg;\n                r.dispatchException(r.arg);\n              } else \"return\" === r.method && r.abrupt(\"return\", r.arg);\n              n = d;\n              var s = tryCatch(e, t, r);\n\n              if (\"normal\" === s.type) {\n                if (n = r.done ? p : h, s.arg === m) continue;\n                return {\n                  value: s.arg,\n                  done: r.done\n                };\n              }\n\n              \"throw\" === s.type && (n = p, r.method = \"throw\", r.arg = s.arg);\n            }\n          };\n        }(e, r, o), i;\n      }\n\n      function tryCatch(e, t, r) {\n        try {\n          return {\n            type: \"normal\",\n            arg: e.call(t, r)\n          };\n        } catch (e) {\n          return {\n            type: \"throw\",\n            arg: e\n          };\n        }\n      }\n\n      function Generator() {}\n\n      function GeneratorFunction() {}\n\n      function GeneratorFunctionPrototype() {}\n\n      function defineIteratorMethods(e) {\n        [\"next\", \"throw\", \"return\"].forEach(function (t) {\n          e[t] = function (e) {\n            return this._invoke(t, e);\n          };\n        });\n      }\n\n      function AsyncIterator(e) {\n        var t;\n\n        this._invoke = function enqueue(r, n) {\n          function callInvokeWithMethodAndArg() {\n            return new Promise(function (t, i) {\n              !function invoke(t, r, n, i) {\n                var o = tryCatch(e[t], e, r);\n\n                if (\"throw\" !== o.type) {\n                  var u = o.arg,\n                      s = u.value;\n                  return s && \"object\" == typeof s && a.call(s, \"__await\") ? Promise.resolve(s.__await).then(function (e) {\n                    invoke(\"next\", e, n, i);\n                  }, function (e) {\n                    invoke(\"throw\", e, n, i);\n                  }) : Promise.resolve(s).then(function (e) {\n                    u.value = e, n(u);\n                  }, function (e) {\n                    return invoke(\"throw\", e, n, i);\n                  });\n                }\n\n                i(o.arg);\n              }(r, n, t, i);\n            });\n          }\n\n          return t = t ? t.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        };\n      }\n\n      function maybeInvokeDelegate(e, t) {\n        var n = e.iterator[t.method];\n\n        if (n === r) {\n          if (t.delegate = null, \"throw\" === t.method) {\n            if (e.iterator.return && (t.method = \"return\", t.arg = r, maybeInvokeDelegate(e, t), \"throw\" === t.method)) return m;\n            t.method = \"throw\", t.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n          }\n\n          return m;\n        }\n\n        var a = tryCatch(n, e.iterator, t.arg);\n        if (\"throw\" === a.type) return t.method = \"throw\", t.arg = a.arg, t.delegate = null, m;\n        var i = a.arg;\n        return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, \"return\" !== t.method && (t.method = \"next\", t.arg = r), t.delegate = null, m) : i : (t.method = \"throw\", t.arg = new TypeError(\"iterator result is not an object\"), t.delegate = null, m);\n      }\n\n      function pushTryEntry(e) {\n        var t = {\n          tryLoc: e[0]\n        };\n        1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);\n      }\n\n      function resetTryEntry(e) {\n        var t = e.completion || {};\n        t.type = \"normal\", delete t.arg, e.completion = t;\n      }\n\n      function Context(e) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], e.forEach(pushTryEntry, this), this.reset(!0);\n      }\n\n      function values(e) {\n        if (e) {\n          var t = e[o];\n          if (t) return t.call(e);\n          if (\"function\" == typeof e.next) return e;\n\n          if (!isNaN(e.length)) {\n            var n = -1,\n                i = function next() {\n              for (; ++n < e.length;) if (a.call(e, n)) return next.value = e[n], next.done = !1, next;\n\n              return next.value = r, next.done = !0, next;\n            };\n\n            return i.next = i;\n          }\n        }\n\n        return {\n          next: doneResult\n        };\n      }\n\n      function doneResult() {\n        return {\n          value: r,\n          done: !0\n        };\n      }\n    }(function () {\n      return this || \"object\" == typeof self && self;\n    }() || Function(\"return this\")());\n  }, function (e, t, r) {\n    var n, a;\n    !function () {\n      var i = {\n        Burg: {\n          2: [\"#ffc6c4\", \"#672044\"],\n          3: [\"#ffc6c4\", \"#cc607d\", \"#672044\"],\n          4: [\"#ffc6c4\", \"#e38191\", \"#ad466c\", \"#672044\"],\n          5: [\"#ffc6c4\", \"#ee919b\", \"#cc607d\", \"#9e3963\", \"#672044\"],\n          6: [\"#ffc6c4\", \"#f29ca3\", \"#da7489\", \"#b95073\", \"#93345d\", \"#672044\"],\n          7: [\"#ffc6c4\", \"#f4a3a8\", \"#e38191\", \"#cc607d\", \"#ad466c\", \"#8b3058\", \"#672044\"],\n          tags: [\"quantitative\"]\n        },\n        BurgYl: {\n          2: [\"#fbe6c5\", \"#70284a\"],\n          3: [\"#fbe6c5\", \"#dc7176\", \"#70284a\"],\n          4: [\"#fbe6c5\", \"#ee8a82\", \"#c8586c\", \"#70284a\"],\n          5: [\"#fbe6c5\", \"#f2a28a\", \"#dc7176\", \"#b24b65\", \"#70284a\"],\n          6: [\"#fbe6c5\", \"#f4b191\", \"#e7807d\", \"#d06270\", \"#a44360\", \"#70284a\"],\n          7: [\"#fbe6c5\", \"#f5ba98\", \"#ee8a82\", \"#dc7176\", \"#c8586c\", \"#9c3f5d\", \"#70284a\"],\n          tags: [\"quantitative\"]\n        },\n        RedOr: {\n          2: [\"#f6d2a9\", \"#b13f64\"],\n          3: [\"#f6d2a9\", \"#ea8171\", \"#b13f64\"],\n          4: [\"#f6d2a9\", \"#f19c7c\", \"#dd686c\", \"#b13f64\"],\n          5: [\"#f6d2a9\", \"#f3aa84\", \"#ea8171\", \"#d55d6a\", \"#b13f64\"],\n          6: [\"#f6d2a9\", \"#f4b28a\", \"#ef9177\", \"#e3726d\", \"#cf5669\", \"#b13f64\"],\n          7: [\"#f6d2a9\", \"#f5b78e\", \"#f19c7c\", \"#ea8171\", \"#dd686c\", \"#ca5268\", \"#b13f64\"],\n          tags: [\"quantitative\"]\n        },\n        OrYel: {\n          2: [\"#ecda9a\", \"#ee4d5a\"],\n          3: [\"#ecda9a\", \"#f7945d\", \"#ee4d5a\"],\n          4: [\"#ecda9a\", \"#f3ad6a\", \"#f97b57\", \"#ee4d5a\"],\n          5: [\"#ecda9a\", \"#f1b973\", \"#f7945d\", \"#f86f56\", \"#ee4d5a\"],\n          6: [\"#ecda9a\", \"#f0c079\", \"#f5a363\", \"#f98558\", \"#f76856\", \"#ee4d5a\"],\n          7: [\"#ecda9a\", \"#efc47e\", \"#f3ad6a\", \"#f7945d\", \"#f97b57\", \"#f66356\", \"#ee4d5a\"],\n          tags: [\"quantitative\"]\n        },\n        Peach: {\n          2: [\"#fde0c5\", \"#eb4a40\"],\n          3: [\"#fde0c5\", \"#f59e72\", \"#eb4a40\"],\n          4: [\"#fde0c5\", \"#f8b58b\", \"#f2855d\", \"#eb4a40\"],\n          5: [\"#fde0c5\", \"#f9c098\", \"#f59e72\", \"#f17854\", \"#eb4a40\"],\n          6: [\"#fde0c5\", \"#fac7a1\", \"#f7ac80\", \"#f38f65\", \"#f0704f\", \"#eb4a40\"],\n          7: [\"#fde0c5\", \"#facba6\", \"#f8b58b\", \"#f59e72\", \"#f2855d\", \"#ef6a4c\", \"#eb4a40\"],\n          tags: [\"quantitative\"]\n        },\n        PinkYl: {\n          2: [\"#fef6b5\", \"#e15383\"],\n          3: [\"#fef6b5\", \"#ffa679\", \"#e15383\"],\n          4: [\"#fef6b5\", \"#ffc285\", \"#fa8a76\", \"#e15383\"],\n          5: [\"#fef6b5\", \"#ffd08e\", \"#ffa679\", \"#f67b77\", \"#e15383\"],\n          6: [\"#fef6b5\", \"#ffd795\", \"#ffb77f\", \"#fd9576\", \"#f37378\", \"#e15383\"],\n          7: [\"#fef6b5\", \"#ffdd9a\", \"#ffc285\", \"#ffa679\", \"#fa8a76\", \"#f16d7a\", \"#e15383\"],\n          tags: [\"quantitative\"]\n        },\n        Mint: {\n          2: [\"#e4f1e1\", \"#0d585f\"],\n          3: [\"#e4f1e1\", \"#63a6a0\", \"#0d585f\"],\n          4: [\"#e4f1e1\", \"#89c0b6\", \"#448c8a\", \"#0d585f\"],\n          5: [\"#E4F1E1\", \"#9CCDC1\", \"#63A6A0\", \"#337F7F\", \"#0D585F\"],\n          6: [\"#e4f1e1\", \"#abd4c7\", \"#7ab5ad\", \"#509693\", \"#2c7778\", \"#0d585f\"],\n          7: [\"#e4f1e1\", \"#b4d9cc\", \"#89c0b6\", \"#63a6a0\", \"#448c8a\", \"#287274\", \"#0d585f\"],\n          tags: [\"quantitative\"]\n        },\n        BluGrn: {\n          2: [\"#c4e6c3\", \"#1d4f60\"],\n          3: [\"#c4e6c3\", \"#4da284\", \"#1d4f60\"],\n          4: [\"#c4e6c3\", \"#6dbc90\", \"#36877a\", \"#1d4f60\"],\n          5: [\"#c4e6c3\", \"#80c799\", \"#4da284\", \"#2d7974\", \"#1d4f60\"],\n          6: [\"#c4e6c3\", \"#8dce9f\", \"#5fb28b\", \"#3e927e\", \"#297071\", \"#1d4f60\"],\n          7: [\"#c4e6c3\", \"#96d2a4\", \"#6dbc90\", \"#4da284\", \"#36877a\", \"#266b6e\", \"#1d4f60\"],\n          tags: [\"quantitative\"]\n        },\n        DarkMint: {\n          2: [\"#d2fbd4\", \"#123f5a\"],\n          3: [\"#d2fbd4\", \"#559c9e\", \"#123f5a\"],\n          4: [\"#d2fbd4\", \"#7bbcb0\", \"#3a7c89\", \"#123f5a\"],\n          5: [\"#d2fbd4\", \"#8eccb9\", \"#559c9e\", \"#2b6c7f\", \"#123f5a\"],\n          6: [\"#d2fbd4\", \"#9cd5be\", \"#6cafa9\", \"#458892\", \"#266377\", \"#123f5a\"],\n          7: [\"#d2fbd4\", \"#a5dbc2\", \"#7bbcb0\", \"#559c9e\", \"#3a7c89\", \"#235d72\", \"#123f5a\"],\n          tags: [\"quantitative\"]\n        },\n        Emrld: {\n          2: [\"#d3f2a3\", \"#074050\"],\n          3: [\"#d3f2a3\", \"#4c9b82\", \"#074050\"],\n          4: [\"#d3f2a3\", \"#6cc08b\", \"#217a79\", \"#074050\"],\n          5: [\"#d3f2a3\", \"#82d091\", \"#4c9b82\", \"#19696f\", \"#074050\"],\n          6: [\"#d3f2a3\", \"#8fda94\", \"#60b187\", \"#35877d\", \"#145f69\", \"#074050\"],\n          7: [\"#d3f2a3\", \"#97e196\", \"#6cc08b\", \"#4c9b82\", \"#217a79\", \"#105965\", \"#074050\"],\n          tags: [\"quantitative\"]\n        },\n        ag_GrnYl: {\n          2: [\"#245668\", \"#EDEF5D\"],\n          3: [\"#245668\", \"#39AB7E\", \"#EDEF5D\"],\n          4: [\"#245668\", \"#0D8F81\", \"#6EC574\", \"#EDEF5D\"],\n          5: [\"#245668\", \"#04817E\", \"#39AB7E\", \"#8BD16D\", \"#EDEF5D\"],\n          6: [\"#245668\", \"#09787C\", \"#1D9A81\", \"#58BB79\", \"#9DD869\", \"#EDEF5D\"],\n          7: [\"#245668\", \"#0F7279\", \"#0D8F81\", \"#39AB7E\", \"#6EC574\", \"#A9DC67\", \"#EDEF5D\"],\n          tags: [\"aggregation\"]\n        },\n        BluYl: {\n          2: [\"#f7feae\", \"#045275\"],\n          3: [\"#f7feae\", \"#46aea0\", \"#045275\"],\n          4: [\"#f7feae\", \"#7ccba2\", \"#089099\", \"#045275\"],\n          5: [\"#f7feae\", \"#9bd8a4\", \"#46aea0\", \"#058092\", \"#045275\"],\n          6: [\"#f7feae\", \"#ace1a4\", \"#68bfa1\", \"#2a9c9c\", \"#02778e\", \"#045275\"],\n          7: [\"#f7feae\", \"#b7e6a5\", \"#7ccba2\", \"#46aea0\", \"#089099\", \"#00718b\", \"#045275\"],\n          tags: [\"quantitative\"]\n        },\n        Teal: {\n          2: [\"#d1eeea\", \"#2a5674\"],\n          3: [\"#d1eeea\", \"#68abb8\", \"#2a5674\"],\n          4: [\"#d1eeea\", \"#85c4c9\", \"#4f90a6\", \"#2a5674\"],\n          5: [\"#d1eeea\", \"#96d0d1\", \"#68abb8\", \"#45829b\", \"#2a5674\"],\n          6: [\"#d1eeea\", \"#a1d7d6\", \"#79bbc3\", \"#599bae\", \"#3f7994\", \"#2a5674\"],\n          7: [\"#d1eeea\", \"#a8dbd9\", \"#85c4c9\", \"#68abb8\", \"#4f90a6\", \"#3b738f\", \"#2a5674\"],\n          tags: [\"quantitative\"]\n        },\n        TealGrn: {\n          2: [\"#b0f2bc\", \"#257d98\"],\n          3: [\"#b0f2bc\", \"#4cc8a3\", \"#257d98\"],\n          4: [\"#b0f2bc\", \"#67dba5\", \"#38b2a3\", \"#257d98\"],\n          5: [\"#b0f2bc\", \"#77e2a8\", \"#4cc8a3\", \"#31a6a2\", \"#257d98\"],\n          6: [\"#b0f2bc\", \"#82e6aa\", \"#5bd4a4\", \"#3fbba3\", \"#2e9ea1\", \"#257d98\"],\n          7: [\"#b0f2bc\", \"#89e8ac\", \"#67dba5\", \"#4cc8a3\", \"#38b2a3\", \"#2c98a0\", \"#257d98\"],\n          tags: [\"quantitative\"]\n        },\n        Purp: {\n          2: [\"#f3e0f7\", \"#63589f\"],\n          3: [\"#f3e0f7\", \"#b998dd\", \"#63589f\"],\n          4: [\"#f3e0f7\", \"#d1afe8\", \"#9f82ce\", \"#63589f\"],\n          5: [\"#f3e0f7\", \"#dbbaed\", \"#b998dd\", \"#9178c4\", \"#63589f\"],\n          6: [\"#f3e0f7\", \"#e0c2ef\", \"#c8a5e4\", \"#aa8bd4\", \"#8871be\", \"#63589f\"],\n          7: [\"#f3e0f7\", \"#e4c7f1\", \"#d1afe8\", \"#b998dd\", \"#9f82ce\", \"#826dba\", \"#63589f\"],\n          tags: [\"quantitative\"]\n        },\n        PurpOr: {\n          3: [\"#f9ddda\", \"#ce78b3\", \"#573b88\"],\n          4: [\"#f9ddda\", \"#e597b9\", \"#ad5fad\", \"#573b88\"],\n          5: [\"#f9ddda\", \"#eda8bd\", \"#ce78b3\", \"#9955a8\", \"#573b88\"],\n          6: [\"#f9ddda\", \"#f0b2c1\", \"#dd8ab6\", \"#bb69b0\", \"#8c4fa4\", \"#573b88\"],\n          7: [\"#f9ddda\", \"#f2b9c4\", \"#e597b9\", \"#ce78b3\", \"#ad5fad\", \"#834ba0\", \"#573b88\"],\n          tags: [\"quantitative\"]\n        },\n        Sunset: {\n          2: [\"#f3e79b\", \"#5c53a5\"],\n          3: [\"#f3e79b\", \"#eb7f86\", \"#5c53a5\"],\n          4: [\"#f3e79b\", \"#f8a07e\", \"#ce6693\", \"#5c53a5\"],\n          5: [\"#f3e79b\", \"#fab27f\", \"#eb7f86\", \"#b95e9a\", \"#5c53a5\"],\n          6: [\"#f3e79b\", \"#fabc82\", \"#f59280\", \"#dc6f8e\", \"#ab5b9e\", \"#5c53a5\"],\n          7: [\"#f3e79b\", \"#fac484\", \"#f8a07e\", \"#eb7f86\", \"#ce6693\", \"#a059a0\", \"#5c53a5\"],\n          tags: [\"quantitative\"]\n        },\n        Magenta: {\n          2: [\"#f3cbd3\", \"#6c2167\"],\n          3: [\"#f3cbd3\", \"#ca699d\", \"#6c2167\"],\n          4: [\"#f3cbd3\", \"#dd88ac\", \"#b14d8e\", \"#6c2167\"],\n          5: [\"#f3cbd3\", \"#e498b4\", \"#ca699d\", \"#a24186\", \"#6c2167\"],\n          6: [\"#f3cbd3\", \"#e7a2b9\", \"#d67ba5\", \"#bc5894\", \"#983a81\", \"#6c2167\"],\n          7: [\"#f3cbd3\", \"#eaa9bd\", \"#dd88ac\", \"#ca699d\", \"#b14d8e\", \"#91357d\", \"#6c2167\"],\n          tags: [\"quantitative\"]\n        },\n        SunsetDark: {\n          2: [\"#fcde9c\", \"#7c1d6f\"],\n          3: [\"#fcde9c\", \"#e34f6f\", \"#7c1d6f\"],\n          4: [\"#fcde9c\", \"#f0746e\", \"#dc3977\", \"#7c1d6f\"],\n          5: [\"#fcde9c\", \"#f58670\", \"#e34f6f\", \"#d72d7c\", \"#7c1d6f\"],\n          6: [\"#fcde9c\", \"#f89872\", \"#ec666d\", \"#df4273\", \"#c5287b\", \"#7c1d6f\"],\n          7: [\"#fcde9c\", \"#faa476\", \"#f0746e\", \"#e34f6f\", \"#dc3977\", \"#b9257a\", \"#7c1d6f\"],\n          tags: [\"quantitative\"]\n        },\n        ag_Sunset: {\n          2: [\"#4b2991\", \"#edd9a3\"],\n          3: [\"#4b2991\", \"#ea4f88\", \"#edd9a3\"],\n          4: [\"#4b2991\", \"#c0369d\", \"#fa7876\", \"#edd9a3\"],\n          5: [\"#4b2991\", \"#a52fa2\", \"#ea4f88\", \"#fa9074\", \"#edd9a3\"],\n          6: [\"#4b2991\", \"#932da3\", \"#d43f96\", \"#f7667c\", \"#f89f77\", \"#edd9a3\"],\n          7: [\"#4b2991\", \"#872ca2\", \"#c0369d\", \"#ea4f88\", \"#fa7876\", \"#f6a97a\", \"#edd9a3\"],\n          tags: [\"aggregation\"]\n        },\n        BrwnYl: {\n          2: [\"#ede5cf\", \"#541f3f\"],\n          3: [\"#ede5cf\", \"#c1766f\", \"#541f3f\"],\n          4: [\"#ede5cf\", \"#d39c83\", \"#a65461\", \"#541f3f\"],\n          5: [\"#ede5cf\", \"#daaf91\", \"#c1766f\", \"#95455a\", \"#541f3f\"],\n          6: [\"#ede5cf\", \"#ddba9b\", \"#cd8c7a\", \"#b26166\", \"#8a3c56\", \"#541f3f\"],\n          7: [\"#ede5cf\", \"#e0c2a2\", \"#d39c83\", \"#c1766f\", \"#a65461\", \"#813753\", \"#541f3f\"],\n          tags: [\"quantitative\"]\n        },\n        ArmyRose: {\n          2: [\"#929b4f\", \"#db8195\"],\n          3: [\"#a3ad62\", \"#fdfbe4\", \"#df91a3\"],\n          4: [\"#929b4f\", \"#d9dbaf\", \"#f3d1ca\", \"#db8195\"],\n          5: [\"#879043\", \"#c1c68c\", \"#fdfbe4\", \"#ebb4b8\", \"#d8758b\"],\n          6: [\"#7f883b\", \"#b0b874\", \"#e3e4be\", \"#f6ddd1\", \"#e4a0ac\", \"#d66d85\"],\n          7: [\"#798234\", \"#a3ad62\", \"#d0d3a2\", \"#fdfbe4\", \"#f0c6c3\", \"#df91a3\", \"#d46780\"],\n          tags: [\"diverging\"]\n        },\n        Fall: {\n          2: [\"#3d5941\", \"#ca562c\"],\n          3: [\"#3d5941\", \"#f6edbd\", \"#ca562c\"],\n          4: [\"#3d5941\", \"#b5b991\", \"#edbb8a\", \"#ca562c\"],\n          5: [\"#3d5941\", \"#96a07c\", \"#f6edbd\", \"#e6a272\", \"#ca562c\"],\n          6: [\"#3d5941\", \"#839170\", \"#cecea2\", \"#f1cf9e\", \"#e19464\", \"#ca562c\"],\n          7: [\"#3d5941\", \"#778868\", \"#b5b991\", \"#f6edbd\", \"#edbb8a\", \"#de8a5a\", \"#ca562c\"],\n          tags: [\"diverging\"]\n        },\n        Geyser: {\n          2: [\"#008080\", \"#ca562c\"],\n          3: [\"#008080\", \"#f6edbd\", \"#ca562c\"],\n          4: [\"#008080\", \"#b4c8a8\", \"#edbb8a\", \"#ca562c\"],\n          5: [\"#008080\", \"#92b69e\", \"#f6edbd\", \"#e6a272\", \"#ca562c\"],\n          6: [\"#008080\", \"#7eab98\", \"#ced7b1\", \"#f1cf9e\", \"#e19464\", \"#ca562c\"],\n          7: [\"#008080\", \"#70a494\", \"#b4c8a8\", \"#f6edbd\", \"#edbb8a\", \"#de8a5a\", \"#ca562c\"],\n          tags: [\"diverging\"]\n        },\n        Temps: {\n          2: [\"#009392\", \"#cf597e\"],\n          3: [\"#009392\", \"#e9e29c\", \"#cf597e\"],\n          4: [\"#009392\", \"#9ccb86\", \"#eeb479\", \"#cf597e\"],\n          5: [\"#009392\", \"#71be83\", \"#e9e29c\", \"#ed9c72\", \"#cf597e\"],\n          6: [\"#009392\", \"#52b684\", \"#bcd48c\", \"#edc783\", \"#eb8d71\", \"#cf597e\"],\n          7: [\"#009392\", \"#39b185\", \"#9ccb86\", \"#e9e29c\", \"#eeb479\", \"#e88471\", \"#cf597e\"],\n          tags: [\"diverging\"]\n        },\n        TealRose: {\n          2: [\"#009392\", \"#d0587e\"],\n          3: [\"#009392\", \"#f1eac8\", \"#d0587e\"],\n          4: [\"#009392\", \"#91b8aa\", \"#f1eac8\", \"#dfa0a0\", \"#d0587e\"],\n          5: [\"#009392\", \"#91b8aa\", \"#f1eac8\", \"#dfa0a0\", \"#d0587e\"],\n          6: [\"#009392\", \"#72aaa1\", \"#b1c7b3\", \"#e5b9ad\", \"#d98994\", \"#d0587e\"],\n          7: [\"#009392\", \"#72aaa1\", \"#b1c7b3\", \"#f1eac8\", \"#e5b9ad\", \"#d98994\", \"#d0587e\"],\n          tags: [\"diverging\"]\n        },\n        Tropic: {\n          2: [\"#009B9E\", \"#C75DAB\"],\n          3: [\"#009B9E\", \"#F1F1F1\", \"#C75DAB\"],\n          4: [\"#009B9E\", \"#A7D3D4\", \"#E4C1D9\", \"#C75DAB\"],\n          5: [\"#009B9E\", \"#7CC5C6\", \"#F1F1F1\", \"#DDA9CD\", \"#C75DAB\"],\n          6: [\"#009B9E\", \"#5DBCBE\", \"#C6DFDF\", \"#E9D4E2\", \"#D99BC6\", \"#C75DAB\"],\n          7: [\"#009B9E\", \"#42B7B9\", \"#A7D3D4\", \"#F1F1F1\", \"#E4C1D9\", \"#D691C1\", \"#C75DAB\"],\n          tags: [\"diverging\"]\n        },\n        Earth: {\n          2: [\"#A16928\", \"#2887a1\"],\n          3: [\"#A16928\", \"#edeac2\", \"#2887a1\"],\n          4: [\"#A16928\", \"#d6bd8d\", \"#b5c8b8\", \"#2887a1\"],\n          5: [\"#A16928\", \"#caa873\", \"#edeac2\", \"#98b7b2\", \"#2887a1\"],\n          6: [\"#A16928\", \"#c29b64\", \"#e0cfa2\", \"#cbd5bc\", \"#85adaf\", \"#2887a1\"],\n          7: [\"#A16928\", \"#bd925a\", \"#d6bd8d\", \"#edeac2\", \"#b5c8b8\", \"#79a7ac\", \"#2887a1\"],\n          tags: [\"diverging\"]\n        },\n        Antique: {\n          2: [\"#855C75\", \"#D9AF6B\", \"#7C7C7C\"],\n          3: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#7C7C7C\"],\n          4: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#7C7C7C\"],\n          5: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#7C7C7C\"],\n          6: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#625377\", \"#7C7C7C\"],\n          7: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#625377\", \"#68855C\", \"#7C7C7C\"],\n          8: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#625377\", \"#68855C\", \"#9C9C5E\", \"#7C7C7C\"],\n          9: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#625377\", \"#68855C\", \"#9C9C5E\", \"#A06177\", \"#7C7C7C\"],\n          10: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#625377\", \"#68855C\", \"#9C9C5E\", \"#A06177\", \"#8C785D\", \"#7C7C7C\"],\n          11: [\"#855C75\", \"#D9AF6B\", \"#AF6458\", \"#736F4C\", \"#526A83\", \"#625377\", \"#68855C\", \"#9C9C5E\", \"#A06177\", \"#8C785D\", \"#467378\", \"#7C7C7C\"],\n          tags: [\"qualitative\"]\n        },\n        Bold: {\n          2: [\"#7F3C8D\", \"#11A579\", \"#A5AA99\"],\n          3: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#A5AA99\"],\n          4: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#A5AA99\"],\n          5: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#A5AA99\"],\n          6: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#80BA5A\", \"#A5AA99\"],\n          7: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#80BA5A\", \"#E68310\", \"#A5AA99\"],\n          8: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#80BA5A\", \"#E68310\", \"#008695\", \"#A5AA99\"],\n          9: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#80BA5A\", \"#E68310\", \"#008695\", \"#CF1C90\", \"#A5AA99\"],\n          10: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#80BA5A\", \"#E68310\", \"#008695\", \"#CF1C90\", \"#f97b72\", \"#A5AA99\"],\n          11: [\"#7F3C8D\", \"#11A579\", \"#3969AC\", \"#F2B701\", \"#E73F74\", \"#80BA5A\", \"#E68310\", \"#008695\", \"#CF1C90\", \"#f97b72\", \"#4b4b8f\", \"#A5AA99\"],\n          tags: [\"qualitative\"]\n        },\n        Pastel: {\n          2: [\"#66C5CC\", \"#F6CF71\", \"#B3B3B3\"],\n          3: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#B3B3B3\"],\n          4: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#B3B3B3\"],\n          5: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#B3B3B3\"],\n          6: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#9EB9F3\", \"#B3B3B3\"],\n          7: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#9EB9F3\", \"#FE88B1\", \"#B3B3B3\"],\n          8: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#9EB9F3\", \"#FE88B1\", \"#C9DB74\", \"#B3B3B3\"],\n          9: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#9EB9F3\", \"#FE88B1\", \"#C9DB74\", \"#8BE0A4\", \"#B3B3B3\"],\n          10: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#9EB9F3\", \"#FE88B1\", \"#C9DB74\", \"#8BE0A4\", \"#B497E7\", \"#B3B3B3\"],\n          11: [\"#66C5CC\", \"#F6CF71\", \"#F89C74\", \"#DCB0F2\", \"#87C55F\", \"#9EB9F3\", \"#FE88B1\", \"#C9DB74\", \"#8BE0A4\", \"#B497E7\", \"#D3B484\", \"#B3B3B3\"],\n          tags: [\"qualitative\"]\n        },\n        Prism: {\n          2: [\"#5F4690\", \"#1D6996\", \"#666666\"],\n          3: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#666666\"],\n          4: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#666666\"],\n          5: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#666666\"],\n          6: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \"#666666\"],\n          7: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \"#E17C05\", \"#666666\"],\n          8: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \"#E17C05\", \"#CC503E\", \"#666666\"],\n          9: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \"#E17C05\", \"#CC503E\", \"#94346E\", \"#666666\"],\n          10: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \"#E17C05\", \"#CC503E\", \"#94346E\", \"#6F4070\", \"#666666\"],\n          11: [\"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \"#E17C05\", \"#CC503E\", \"#94346E\", \"#6F4070\", \"#994E95\", \"#666666\"],\n          tags: [\"qualitative\"]\n        },\n        Safe: {\n          2: [\"#88CCEE\", \"#CC6677\", \"#888888\"],\n          3: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#888888\"],\n          4: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#888888\"],\n          5: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#888888\"],\n          6: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#888888\"],\n          7: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\", \"#888888\"],\n          8: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\", \"#999933\", \"#888888\"],\n          9: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\", \"#999933\", \"#882255\", \"#888888\"],\n          10: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\", \"#999933\", \"#882255\", \"#661100\", \"#888888\"],\n          11: [\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\", \"#999933\", \"#882255\", \"#661100\", \"#6699CC\", \"#888888\"],\n          tags: [\"qualitative\", \"colorblind\"]\n        },\n        Vivid: {\n          2: [\"#E58606\", \"#5D69B1\", \"#A5AA99\"],\n          3: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#A5AA99\"],\n          4: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#A5AA99\"],\n          5: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#A5AA99\"],\n          6: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#24796C\", \"#A5AA99\"],\n          7: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#24796C\", \"#DAA51B\", \"#A5AA99\"],\n          8: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#24796C\", \"#DAA51B\", \"#2F8AC4\", \"#A5AA99\"],\n          9: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#24796C\", \"#DAA51B\", \"#2F8AC4\", \"#764E9F\", \"#A5AA99\"],\n          10: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#24796C\", \"#DAA51B\", \"#2F8AC4\", \"#764E9F\", \"#ED645A\", \"#A5AA99\"],\n          11: [\"#E58606\", \"#5D69B1\", \"#52BCA3\", \"#99C945\", \"#CC61B0\", \"#24796C\", \"#DAA51B\", \"#2F8AC4\", \"#764E9F\", \"#ED645A\", \"#CC3A8E\", \"#A5AA99\"],\n          tags: [\"qualitative\"]\n        }\n      },\n          o = {\n        Blues: {\n          tags: [\"quantitative\"]\n        },\n        BrBG: {\n          tags: [\"diverging\"]\n        },\n        Greys: {\n          tags: [\"quantitative\"]\n        },\n        PiYG: {\n          tags: [\"diverging\"]\n        },\n        PRGn: {\n          tags: [\"diverging\"]\n        },\n        Purples: {\n          tags: [\"quantitative\"]\n        },\n        RdYlGn: {\n          tags: [\"diverging\"]\n        },\n        Spectral: {\n          tags: [\"diverging\"]\n        },\n        YlOrBr: {\n          tags: [\"quantitative\"]\n        },\n        YlGn: {\n          tags: [\"quantitative\"]\n        },\n        YlGnBu: {\n          tags: [\"quantitative\"]\n        },\n        YlOrRd: {\n          tags: [\"quantitative\"]\n        }\n      },\n          u = r(61);\n\n      for (var s in u) {\n        var c = u[s],\n            l = {};\n\n        for (var f in c) l[f] = c[f];\n\n        s in o && (l.tags = o[s].tags), i[\"cb_\" + s] = l;\n      }\n\n      void 0 === (a = \"function\" == typeof (n = i) ? n.call(t, r, t, e) : n) || (e.exports = a);\n    }();\n  }, function (e, t, r) {\n    e.exports = r(62);\n  }, function (e, t, r) {\n    var n, a;\n    void 0 === (a = \"function\" == typeof (n = {\n      YlGn: {\n        3: [\"#f7fcb9\", \"#addd8e\", \"#31a354\"],\n        4: [\"#ffffcc\", \"#c2e699\", \"#78c679\", \"#238443\"],\n        5: [\"#ffffcc\", \"#c2e699\", \"#78c679\", \"#31a354\", \"#006837\"],\n        6: [\"#ffffcc\", \"#d9f0a3\", \"#addd8e\", \"#78c679\", \"#31a354\", \"#006837\"],\n        7: [\"#ffffcc\", \"#d9f0a3\", \"#addd8e\", \"#78c679\", \"#41ab5d\", \"#238443\", \"#005a32\"],\n        8: [\"#ffffe5\", \"#f7fcb9\", \"#d9f0a3\", \"#addd8e\", \"#78c679\", \"#41ab5d\", \"#238443\", \"#005a32\"],\n        9: [\"#ffffe5\", \"#f7fcb9\", \"#d9f0a3\", \"#addd8e\", \"#78c679\", \"#41ab5d\", \"#238443\", \"#006837\", \"#004529\"]\n      },\n      YlGnBu: {\n        3: [\"#edf8b1\", \"#7fcdbb\", \"#2c7fb8\"],\n        4: [\"#ffffcc\", \"#a1dab4\", \"#41b6c4\", \"#225ea8\"],\n        5: [\"#ffffcc\", \"#a1dab4\", \"#41b6c4\", \"#2c7fb8\", \"#253494\"],\n        6: [\"#ffffcc\", \"#c7e9b4\", \"#7fcdbb\", \"#41b6c4\", \"#2c7fb8\", \"#253494\"],\n        7: [\"#ffffcc\", \"#c7e9b4\", \"#7fcdbb\", \"#41b6c4\", \"#1d91c0\", \"#225ea8\", \"#0c2c84\"],\n        8: [\"#ffffd9\", \"#edf8b1\", \"#c7e9b4\", \"#7fcdbb\", \"#41b6c4\", \"#1d91c0\", \"#225ea8\", \"#0c2c84\"],\n        9: [\"#ffffd9\", \"#edf8b1\", \"#c7e9b4\", \"#7fcdbb\", \"#41b6c4\", \"#1d91c0\", \"#225ea8\", \"#253494\", \"#081d58\"]\n      },\n      GnBu: {\n        3: [\"#e0f3db\", \"#a8ddb5\", \"#43a2ca\"],\n        4: [\"#f0f9e8\", \"#bae4bc\", \"#7bccc4\", \"#2b8cbe\"],\n        5: [\"#f0f9e8\", \"#bae4bc\", \"#7bccc4\", \"#43a2ca\", \"#0868ac\"],\n        6: [\"#f0f9e8\", \"#ccebc5\", \"#a8ddb5\", \"#7bccc4\", \"#43a2ca\", \"#0868ac\"],\n        7: [\"#f0f9e8\", \"#ccebc5\", \"#a8ddb5\", \"#7bccc4\", \"#4eb3d3\", \"#2b8cbe\", \"#08589e\"],\n        8: [\"#f7fcf0\", \"#e0f3db\", \"#ccebc5\", \"#a8ddb5\", \"#7bccc4\", \"#4eb3d3\", \"#2b8cbe\", \"#08589e\"],\n        9: [\"#f7fcf0\", \"#e0f3db\", \"#ccebc5\", \"#a8ddb5\", \"#7bccc4\", \"#4eb3d3\", \"#2b8cbe\", \"#0868ac\", \"#084081\"]\n      },\n      BuGn: {\n        3: [\"#e5f5f9\", \"#99d8c9\", \"#2ca25f\"],\n        4: [\"#edf8fb\", \"#b2e2e2\", \"#66c2a4\", \"#238b45\"],\n        5: [\"#edf8fb\", \"#b2e2e2\", \"#66c2a4\", \"#2ca25f\", \"#006d2c\"],\n        6: [\"#edf8fb\", \"#ccece6\", \"#99d8c9\", \"#66c2a4\", \"#2ca25f\", \"#006d2c\"],\n        7: [\"#edf8fb\", \"#ccece6\", \"#99d8c9\", \"#66c2a4\", \"#41ae76\", \"#238b45\", \"#005824\"],\n        8: [\"#f7fcfd\", \"#e5f5f9\", \"#ccece6\", \"#99d8c9\", \"#66c2a4\", \"#41ae76\", \"#238b45\", \"#005824\"],\n        9: [\"#f7fcfd\", \"#e5f5f9\", \"#ccece6\", \"#99d8c9\", \"#66c2a4\", \"#41ae76\", \"#238b45\", \"#006d2c\", \"#00441b\"]\n      },\n      PuBuGn: {\n        3: [\"#ece2f0\", \"#a6bddb\", \"#1c9099\"],\n        4: [\"#f6eff7\", \"#bdc9e1\", \"#67a9cf\", \"#02818a\"],\n        5: [\"#f6eff7\", \"#bdc9e1\", \"#67a9cf\", \"#1c9099\", \"#016c59\"],\n        6: [\"#f6eff7\", \"#d0d1e6\", \"#a6bddb\", \"#67a9cf\", \"#1c9099\", \"#016c59\"],\n        7: [\"#f6eff7\", \"#d0d1e6\", \"#a6bddb\", \"#67a9cf\", \"#3690c0\", \"#02818a\", \"#016450\"],\n        8: [\"#fff7fb\", \"#ece2f0\", \"#d0d1e6\", \"#a6bddb\", \"#67a9cf\", \"#3690c0\", \"#02818a\", \"#016450\"],\n        9: [\"#fff7fb\", \"#ece2f0\", \"#d0d1e6\", \"#a6bddb\", \"#67a9cf\", \"#3690c0\", \"#02818a\", \"#016c59\", \"#014636\"]\n      },\n      PuBu: {\n        3: [\"#ece7f2\", \"#a6bddb\", \"#2b8cbe\"],\n        4: [\"#f1eef6\", \"#bdc9e1\", \"#74a9cf\", \"#0570b0\"],\n        5: [\"#f1eef6\", \"#bdc9e1\", \"#74a9cf\", \"#2b8cbe\", \"#045a8d\"],\n        6: [\"#f1eef6\", \"#d0d1e6\", \"#a6bddb\", \"#74a9cf\", \"#2b8cbe\", \"#045a8d\"],\n        7: [\"#f1eef6\", \"#d0d1e6\", \"#a6bddb\", \"#74a9cf\", \"#3690c0\", \"#0570b0\", \"#034e7b\"],\n        8: [\"#fff7fb\", \"#ece7f2\", \"#d0d1e6\", \"#a6bddb\", \"#74a9cf\", \"#3690c0\", \"#0570b0\", \"#034e7b\"],\n        9: [\"#fff7fb\", \"#ece7f2\", \"#d0d1e6\", \"#a6bddb\", \"#74a9cf\", \"#3690c0\", \"#0570b0\", \"#045a8d\", \"#023858\"]\n      },\n      BuPu: {\n        3: [\"#e0ecf4\", \"#9ebcda\", \"#8856a7\"],\n        4: [\"#edf8fb\", \"#b3cde3\", \"#8c96c6\", \"#88419d\"],\n        5: [\"#edf8fb\", \"#b3cde3\", \"#8c96c6\", \"#8856a7\", \"#810f7c\"],\n        6: [\"#edf8fb\", \"#bfd3e6\", \"#9ebcda\", \"#8c96c6\", \"#8856a7\", \"#810f7c\"],\n        7: [\"#edf8fb\", \"#bfd3e6\", \"#9ebcda\", \"#8c96c6\", \"#8c6bb1\", \"#88419d\", \"#6e016b\"],\n        8: [\"#f7fcfd\", \"#e0ecf4\", \"#bfd3e6\", \"#9ebcda\", \"#8c96c6\", \"#8c6bb1\", \"#88419d\", \"#6e016b\"],\n        9: [\"#f7fcfd\", \"#e0ecf4\", \"#bfd3e6\", \"#9ebcda\", \"#8c96c6\", \"#8c6bb1\", \"#88419d\", \"#810f7c\", \"#4d004b\"]\n      },\n      RdPu: {\n        3: [\"#fde0dd\", \"#fa9fb5\", \"#c51b8a\"],\n        4: [\"#feebe2\", \"#fbb4b9\", \"#f768a1\", \"#ae017e\"],\n        5: [\"#feebe2\", \"#fbb4b9\", \"#f768a1\", \"#c51b8a\", \"#7a0177\"],\n        6: [\"#feebe2\", \"#fcc5c0\", \"#fa9fb5\", \"#f768a1\", \"#c51b8a\", \"#7a0177\"],\n        7: [\"#feebe2\", \"#fcc5c0\", \"#fa9fb5\", \"#f768a1\", \"#dd3497\", \"#ae017e\", \"#7a0177\"],\n        8: [\"#fff7f3\", \"#fde0dd\", \"#fcc5c0\", \"#fa9fb5\", \"#f768a1\", \"#dd3497\", \"#ae017e\", \"#7a0177\"],\n        9: [\"#fff7f3\", \"#fde0dd\", \"#fcc5c0\", \"#fa9fb5\", \"#f768a1\", \"#dd3497\", \"#ae017e\", \"#7a0177\", \"#49006a\"]\n      },\n      PuRd: {\n        3: [\"#e7e1ef\", \"#c994c7\", \"#dd1c77\"],\n        4: [\"#f1eef6\", \"#d7b5d8\", \"#df65b0\", \"#ce1256\"],\n        5: [\"#f1eef6\", \"#d7b5d8\", \"#df65b0\", \"#dd1c77\", \"#980043\"],\n        6: [\"#f1eef6\", \"#d4b9da\", \"#c994c7\", \"#df65b0\", \"#dd1c77\", \"#980043\"],\n        7: [\"#f1eef6\", \"#d4b9da\", \"#c994c7\", \"#df65b0\", \"#e7298a\", \"#ce1256\", \"#91003f\"],\n        8: [\"#f7f4f9\", \"#e7e1ef\", \"#d4b9da\", \"#c994c7\", \"#df65b0\", \"#e7298a\", \"#ce1256\", \"#91003f\"],\n        9: [\"#f7f4f9\", \"#e7e1ef\", \"#d4b9da\", \"#c994c7\", \"#df65b0\", \"#e7298a\", \"#ce1256\", \"#980043\", \"#67001f\"]\n      },\n      OrRd: {\n        3: [\"#fee8c8\", \"#fdbb84\", \"#e34a33\"],\n        4: [\"#fef0d9\", \"#fdcc8a\", \"#fc8d59\", \"#d7301f\"],\n        5: [\"#fef0d9\", \"#fdcc8a\", \"#fc8d59\", \"#e34a33\", \"#b30000\"],\n        6: [\"#fef0d9\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#e34a33\", \"#b30000\"],\n        7: [\"#fef0d9\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#ef6548\", \"#d7301f\", \"#990000\"],\n        8: [\"#fff7ec\", \"#fee8c8\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#ef6548\", \"#d7301f\", \"#990000\"],\n        9: [\"#fff7ec\", \"#fee8c8\", \"#fdd49e\", \"#fdbb84\", \"#fc8d59\", \"#ef6548\", \"#d7301f\", \"#b30000\", \"#7f0000\"]\n      },\n      YlOrRd: {\n        3: [\"#ffeda0\", \"#feb24c\", \"#f03b20\"],\n        4: [\"#ffffb2\", \"#fecc5c\", \"#fd8d3c\", \"#e31a1c\"],\n        5: [\"#ffffb2\", \"#fecc5c\", \"#fd8d3c\", \"#f03b20\", \"#bd0026\"],\n        6: [\"#ffffb2\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#f03b20\", \"#bd0026\"],\n        7: [\"#ffffb2\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#b10026\"],\n        8: [\"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#b10026\"],\n        9: [\"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#bd0026\", \"#800026\"]\n      },\n      YlOrBr: {\n        3: [\"#fff7bc\", \"#fec44f\", \"#d95f0e\"],\n        4: [\"#ffffd4\", \"#fed98e\", \"#fe9929\", \"#cc4c02\"],\n        5: [\"#ffffd4\", \"#fed98e\", \"#fe9929\", \"#d95f0e\", \"#993404\"],\n        6: [\"#ffffd4\", \"#fee391\", \"#fec44f\", \"#fe9929\", \"#d95f0e\", \"#993404\"],\n        7: [\"#ffffd4\", \"#fee391\", \"#fec44f\", \"#fe9929\", \"#ec7014\", \"#cc4c02\", \"#8c2d04\"],\n        8: [\"#ffffe5\", \"#fff7bc\", \"#fee391\", \"#fec44f\", \"#fe9929\", \"#ec7014\", \"#cc4c02\", \"#8c2d04\"],\n        9: [\"#ffffe5\", \"#fff7bc\", \"#fee391\", \"#fec44f\", \"#fe9929\", \"#ec7014\", \"#cc4c02\", \"#993404\", \"#662506\"]\n      },\n      Purples: {\n        3: [\"#efedf5\", \"#bcbddc\", \"#756bb1\"],\n        4: [\"#f2f0f7\", \"#cbc9e2\", \"#9e9ac8\", \"#6a51a3\"],\n        5: [\"#f2f0f7\", \"#cbc9e2\", \"#9e9ac8\", \"#756bb1\", \"#54278f\"],\n        6: [\"#f2f0f7\", \"#dadaeb\", \"#bcbddc\", \"#9e9ac8\", \"#756bb1\", \"#54278f\"],\n        7: [\"#f2f0f7\", \"#dadaeb\", \"#bcbddc\", \"#9e9ac8\", \"#807dba\", \"#6a51a3\", \"#4a1486\"],\n        8: [\"#fcfbfd\", \"#efedf5\", \"#dadaeb\", \"#bcbddc\", \"#9e9ac8\", \"#807dba\", \"#6a51a3\", \"#4a1486\"],\n        9: [\"#fcfbfd\", \"#efedf5\", \"#dadaeb\", \"#bcbddc\", \"#9e9ac8\", \"#807dba\", \"#6a51a3\", \"#54278f\", \"#3f007d\"]\n      },\n      Blues: {\n        3: [\"#deebf7\", \"#9ecae1\", \"#3182bd\"],\n        4: [\"#eff3ff\", \"#bdd7e7\", \"#6baed6\", \"#2171b5\"],\n        5: [\"#eff3ff\", \"#bdd7e7\", \"#6baed6\", \"#3182bd\", \"#08519c\"],\n        6: [\"#eff3ff\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#3182bd\", \"#08519c\"],\n        7: [\"#eff3ff\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#4292c6\", \"#2171b5\", \"#084594\"],\n        8: [\"#f7fbff\", \"#deebf7\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#4292c6\", \"#2171b5\", \"#084594\"],\n        9: [\"#f7fbff\", \"#deebf7\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#4292c6\", \"#2171b5\", \"#08519c\", \"#08306b\"]\n      },\n      Greens: {\n        3: [\"#e5f5e0\", \"#a1d99b\", \"#31a354\"],\n        4: [\"#edf8e9\", \"#bae4b3\", \"#74c476\", \"#238b45\"],\n        5: [\"#edf8e9\", \"#bae4b3\", \"#74c476\", \"#31a354\", \"#006d2c\"],\n        6: [\"#edf8e9\", \"#c7e9c0\", \"#a1d99b\", \"#74c476\", \"#31a354\", \"#006d2c\"],\n        7: [\"#edf8e9\", \"#c7e9c0\", \"#a1d99b\", \"#74c476\", \"#41ab5d\", \"#238b45\", \"#005a32\"],\n        8: [\"#f7fcf5\", \"#e5f5e0\", \"#c7e9c0\", \"#a1d99b\", \"#74c476\", \"#41ab5d\", \"#238b45\", \"#005a32\"],\n        9: [\"#f7fcf5\", \"#e5f5e0\", \"#c7e9c0\", \"#a1d99b\", \"#74c476\", \"#41ab5d\", \"#238b45\", \"#006d2c\", \"#00441b\"]\n      },\n      Oranges: {\n        3: [\"#fee6ce\", \"#fdae6b\", \"#e6550d\"],\n        4: [\"#feedde\", \"#fdbe85\", \"#fd8d3c\", \"#d94701\"],\n        5: [\"#feedde\", \"#fdbe85\", \"#fd8d3c\", \"#e6550d\", \"#a63603\"],\n        6: [\"#feedde\", \"#fdd0a2\", \"#fdae6b\", \"#fd8d3c\", \"#e6550d\", \"#a63603\"],\n        7: [\"#feedde\", \"#fdd0a2\", \"#fdae6b\", \"#fd8d3c\", \"#f16913\", \"#d94801\", \"#8c2d04\"],\n        8: [\"#fff5eb\", \"#fee6ce\", \"#fdd0a2\", \"#fdae6b\", \"#fd8d3c\", \"#f16913\", \"#d94801\", \"#8c2d04\"],\n        9: [\"#fff5eb\", \"#fee6ce\", \"#fdd0a2\", \"#fdae6b\", \"#fd8d3c\", \"#f16913\", \"#d94801\", \"#a63603\", \"#7f2704\"]\n      },\n      Reds: {\n        3: [\"#fee0d2\", \"#fc9272\", \"#de2d26\"],\n        4: [\"#fee5d9\", \"#fcae91\", \"#fb6a4a\", \"#cb181d\"],\n        5: [\"#fee5d9\", \"#fcae91\", \"#fb6a4a\", \"#de2d26\", \"#a50f15\"],\n        6: [\"#fee5d9\", \"#fcbba1\", \"#fc9272\", \"#fb6a4a\", \"#de2d26\", \"#a50f15\"],\n        7: [\"#fee5d9\", \"#fcbba1\", \"#fc9272\", \"#fb6a4a\", \"#ef3b2c\", \"#cb181d\", \"#99000d\"],\n        8: [\"#fff5f0\", \"#fee0d2\", \"#fcbba1\", \"#fc9272\", \"#fb6a4a\", \"#ef3b2c\", \"#cb181d\", \"#99000d\"],\n        9: [\"#fff5f0\", \"#fee0d2\", \"#fcbba1\", \"#fc9272\", \"#fb6a4a\", \"#ef3b2c\", \"#cb181d\", \"#a50f15\", \"#67000d\"]\n      },\n      Greys: {\n        3: [\"#f0f0f0\", \"#bdbdbd\", \"#636363\"],\n        4: [\"#f7f7f7\", \"#cccccc\", \"#969696\", \"#525252\"],\n        5: [\"#f7f7f7\", \"#cccccc\", \"#969696\", \"#636363\", \"#252525\"],\n        6: [\"#f7f7f7\", \"#d9d9d9\", \"#bdbdbd\", \"#969696\", \"#636363\", \"#252525\"],\n        7: [\"#f7f7f7\", \"#d9d9d9\", \"#bdbdbd\", \"#969696\", \"#737373\", \"#525252\", \"#252525\"],\n        8: [\"#ffffff\", \"#f0f0f0\", \"#d9d9d9\", \"#bdbdbd\", \"#969696\", \"#737373\", \"#525252\", \"#252525\"],\n        9: [\"#ffffff\", \"#f0f0f0\", \"#d9d9d9\", \"#bdbdbd\", \"#969696\", \"#737373\", \"#525252\", \"#252525\", \"#000000\"]\n      },\n      PuOr: {\n        3: [\"#f1a340\", \"#f7f7f7\", \"#998ec3\"],\n        4: [\"#e66101\", \"#fdb863\", \"#b2abd2\", \"#5e3c99\"],\n        5: [\"#e66101\", \"#fdb863\", \"#f7f7f7\", \"#b2abd2\", \"#5e3c99\"],\n        6: [\"#b35806\", \"#f1a340\", \"#fee0b6\", \"#d8daeb\", \"#998ec3\", \"#542788\"],\n        7: [\"#b35806\", \"#f1a340\", \"#fee0b6\", \"#f7f7f7\", \"#d8daeb\", \"#998ec3\", \"#542788\"],\n        8: [\"#b35806\", \"#e08214\", \"#fdb863\", \"#fee0b6\", \"#d8daeb\", \"#b2abd2\", \"#8073ac\", \"#542788\"],\n        9: [\"#b35806\", \"#e08214\", \"#fdb863\", \"#fee0b6\", \"#f7f7f7\", \"#d8daeb\", \"#b2abd2\", \"#8073ac\", \"#542788\"],\n        10: [\"#7f3b08\", \"#b35806\", \"#e08214\", \"#fdb863\", \"#fee0b6\", \"#d8daeb\", \"#b2abd2\", \"#8073ac\", \"#542788\", \"#2d004b\"],\n        11: [\"#7f3b08\", \"#b35806\", \"#e08214\", \"#fdb863\", \"#fee0b6\", \"#f7f7f7\", \"#d8daeb\", \"#b2abd2\", \"#8073ac\", \"#542788\", \"#2d004b\"]\n      },\n      BrBG: {\n        3: [\"#d8b365\", \"#f5f5f5\", \"#5ab4ac\"],\n        4: [\"#a6611a\", \"#dfc27d\", \"#80cdc1\", \"#018571\"],\n        5: [\"#a6611a\", \"#dfc27d\", \"#f5f5f5\", \"#80cdc1\", \"#018571\"],\n        6: [\"#8c510a\", \"#d8b365\", \"#f6e8c3\", \"#c7eae5\", \"#5ab4ac\", \"#01665e\"],\n        7: [\"#8c510a\", \"#d8b365\", \"#f6e8c3\", \"#f5f5f5\", \"#c7eae5\", \"#5ab4ac\", \"#01665e\"],\n        8: [\"#8c510a\", \"#bf812d\", \"#dfc27d\", \"#f6e8c3\", \"#c7eae5\", \"#80cdc1\", \"#35978f\", \"#01665e\"],\n        9: [\"#8c510a\", \"#bf812d\", \"#dfc27d\", \"#f6e8c3\", \"#f5f5f5\", \"#c7eae5\", \"#80cdc1\", \"#35978f\", \"#01665e\"],\n        10: [\"#543005\", \"#8c510a\", \"#bf812d\", \"#dfc27d\", \"#f6e8c3\", \"#c7eae5\", \"#80cdc1\", \"#35978f\", \"#01665e\", \"#003c30\"],\n        11: [\"#543005\", \"#8c510a\", \"#bf812d\", \"#dfc27d\", \"#f6e8c3\", \"#f5f5f5\", \"#c7eae5\", \"#80cdc1\", \"#35978f\", \"#01665e\", \"#003c30\"]\n      },\n      PRGn: {\n        3: [\"#af8dc3\", \"#f7f7f7\", \"#7fbf7b\"],\n        4: [\"#7b3294\", \"#c2a5cf\", \"#a6dba0\", \"#008837\"],\n        5: [\"#7b3294\", \"#c2a5cf\", \"#f7f7f7\", \"#a6dba0\", \"#008837\"],\n        6: [\"#762a83\", \"#af8dc3\", \"#e7d4e8\", \"#d9f0d3\", \"#7fbf7b\", \"#1b7837\"],\n        7: [\"#762a83\", \"#af8dc3\", \"#e7d4e8\", \"#f7f7f7\", \"#d9f0d3\", \"#7fbf7b\", \"#1b7837\"],\n        8: [\"#762a83\", \"#9970ab\", \"#c2a5cf\", \"#e7d4e8\", \"#d9f0d3\", \"#a6dba0\", \"#5aae61\", \"#1b7837\"],\n        9: [\"#762a83\", \"#9970ab\", \"#c2a5cf\", \"#e7d4e8\", \"#f7f7f7\", \"#d9f0d3\", \"#a6dba0\", \"#5aae61\", \"#1b7837\"],\n        10: [\"#40004b\", \"#762a83\", \"#9970ab\", \"#c2a5cf\", \"#e7d4e8\", \"#d9f0d3\", \"#a6dba0\", \"#5aae61\", \"#1b7837\", \"#00441b\"],\n        11: [\"#40004b\", \"#762a83\", \"#9970ab\", \"#c2a5cf\", \"#e7d4e8\", \"#f7f7f7\", \"#d9f0d3\", \"#a6dba0\", \"#5aae61\", \"#1b7837\", \"#00441b\"]\n      },\n      PiYG: {\n        3: [\"#e9a3c9\", \"#f7f7f7\", \"#a1d76a\"],\n        4: [\"#d01c8b\", \"#f1b6da\", \"#b8e186\", \"#4dac26\"],\n        5: [\"#d01c8b\", \"#f1b6da\", \"#f7f7f7\", \"#b8e186\", \"#4dac26\"],\n        6: [\"#c51b7d\", \"#e9a3c9\", \"#fde0ef\", \"#e6f5d0\", \"#a1d76a\", \"#4d9221\"],\n        7: [\"#c51b7d\", \"#e9a3c9\", \"#fde0ef\", \"#f7f7f7\", \"#e6f5d0\", \"#a1d76a\", \"#4d9221\"],\n        8: [\"#c51b7d\", \"#de77ae\", \"#f1b6da\", \"#fde0ef\", \"#e6f5d0\", \"#b8e186\", \"#7fbc41\", \"#4d9221\"],\n        9: [\"#c51b7d\", \"#de77ae\", \"#f1b6da\", \"#fde0ef\", \"#f7f7f7\", \"#e6f5d0\", \"#b8e186\", \"#7fbc41\", \"#4d9221\"],\n        10: [\"#8e0152\", \"#c51b7d\", \"#de77ae\", \"#f1b6da\", \"#fde0ef\", \"#e6f5d0\", \"#b8e186\", \"#7fbc41\", \"#4d9221\", \"#276419\"],\n        11: [\"#8e0152\", \"#c51b7d\", \"#de77ae\", \"#f1b6da\", \"#fde0ef\", \"#f7f7f7\", \"#e6f5d0\", \"#b8e186\", \"#7fbc41\", \"#4d9221\", \"#276419\"]\n      },\n      RdBu: {\n        3: [\"#ef8a62\", \"#f7f7f7\", \"#67a9cf\"],\n        4: [\"#ca0020\", \"#f4a582\", \"#92c5de\", \"#0571b0\"],\n        5: [\"#ca0020\", \"#f4a582\", \"#f7f7f7\", \"#92c5de\", \"#0571b0\"],\n        6: [\"#b2182b\", \"#ef8a62\", \"#fddbc7\", \"#d1e5f0\", \"#67a9cf\", \"#2166ac\"],\n        7: [\"#b2182b\", \"#ef8a62\", \"#fddbc7\", \"#f7f7f7\", \"#d1e5f0\", \"#67a9cf\", \"#2166ac\"],\n        8: [\"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#d1e5f0\", \"#92c5de\", \"#4393c3\", \"#2166ac\"],\n        9: [\"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#f7f7f7\", \"#d1e5f0\", \"#92c5de\", \"#4393c3\", \"#2166ac\"],\n        10: [\"#67001f\", \"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#d1e5f0\", \"#92c5de\", \"#4393c3\", \"#2166ac\", \"#053061\"],\n        11: [\"#67001f\", \"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#f7f7f7\", \"#d1e5f0\", \"#92c5de\", \"#4393c3\", \"#2166ac\", \"#053061\"]\n      },\n      RdGy: {\n        3: [\"#ef8a62\", \"#ffffff\", \"#999999\"],\n        4: [\"#ca0020\", \"#f4a582\", \"#bababa\", \"#404040\"],\n        5: [\"#ca0020\", \"#f4a582\", \"#ffffff\", \"#bababa\", \"#404040\"],\n        6: [\"#b2182b\", \"#ef8a62\", \"#fddbc7\", \"#e0e0e0\", \"#999999\", \"#4d4d4d\"],\n        7: [\"#b2182b\", \"#ef8a62\", \"#fddbc7\", \"#ffffff\", \"#e0e0e0\", \"#999999\", \"#4d4d4d\"],\n        8: [\"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#e0e0e0\", \"#bababa\", \"#878787\", \"#4d4d4d\"],\n        9: [\"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#ffffff\", \"#e0e0e0\", \"#bababa\", \"#878787\", \"#4d4d4d\"],\n        10: [\"#67001f\", \"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#e0e0e0\", \"#bababa\", \"#878787\", \"#4d4d4d\", \"#1a1a1a\"],\n        11: [\"#67001f\", \"#b2182b\", \"#d6604d\", \"#f4a582\", \"#fddbc7\", \"#ffffff\", \"#e0e0e0\", \"#bababa\", \"#878787\", \"#4d4d4d\", \"#1a1a1a\"]\n      },\n      RdYlBu: {\n        3: [\"#fc8d59\", \"#ffffbf\", \"#91bfdb\"],\n        4: [\"#d7191c\", \"#fdae61\", \"#abd9e9\", \"#2c7bb6\"],\n        5: [\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#abd9e9\", \"#2c7bb6\"],\n        6: [\"#d73027\", \"#fc8d59\", \"#fee090\", \"#e0f3f8\", \"#91bfdb\", \"#4575b4\"],\n        7: [\"#d73027\", \"#fc8d59\", \"#fee090\", \"#ffffbf\", \"#e0f3f8\", \"#91bfdb\", \"#4575b4\"],\n        8: [\"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee090\", \"#e0f3f8\", \"#abd9e9\", \"#74add1\", \"#4575b4\"],\n        9: [\"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee090\", \"#ffffbf\", \"#e0f3f8\", \"#abd9e9\", \"#74add1\", \"#4575b4\"],\n        10: [\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee090\", \"#e0f3f8\", \"#abd9e9\", \"#74add1\", \"#4575b4\", \"#313695\"],\n        11: [\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee090\", \"#ffffbf\", \"#e0f3f8\", \"#abd9e9\", \"#74add1\", \"#4575b4\", \"#313695\"]\n      },\n      Spectral: {\n        3: [\"#fc8d59\", \"#ffffbf\", \"#99d594\"],\n        4: [\"#d7191c\", \"#fdae61\", \"#abdda4\", \"#2b83ba\"],\n        5: [\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#abdda4\", \"#2b83ba\"],\n        6: [\"#d53e4f\", \"#fc8d59\", \"#fee08b\", \"#e6f598\", \"#99d594\", \"#3288bd\"],\n        7: [\"#d53e4f\", \"#fc8d59\", \"#fee08b\", \"#ffffbf\", \"#e6f598\", \"#99d594\", \"#3288bd\"],\n        8: [\"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#e6f598\", \"#abdda4\", \"#66c2a5\", \"#3288bd\"],\n        9: [\"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#ffffbf\", \"#e6f598\", \"#abdda4\", \"#66c2a5\", \"#3288bd\"],\n        10: [\"#9e0142\", \"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#e6f598\", \"#abdda4\", \"#66c2a5\", \"#3288bd\", \"#5e4fa2\"],\n        11: [\"#9e0142\", \"#d53e4f\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#ffffbf\", \"#e6f598\", \"#abdda4\", \"#66c2a5\", \"#3288bd\", \"#5e4fa2\"]\n      },\n      RdYlGn: {\n        3: [\"#fc8d59\", \"#ffffbf\", \"#91cf60\"],\n        4: [\"#d7191c\", \"#fdae61\", \"#a6d96a\", \"#1a9641\"],\n        5: [\"#d7191c\", \"#fdae61\", \"#ffffbf\", \"#a6d96a\", \"#1a9641\"],\n        6: [\"#d73027\", \"#fc8d59\", \"#fee08b\", \"#d9ef8b\", \"#91cf60\", \"#1a9850\"],\n        7: [\"#d73027\", \"#fc8d59\", \"#fee08b\", \"#ffffbf\", \"#d9ef8b\", \"#91cf60\", \"#1a9850\"],\n        8: [\"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#d9ef8b\", \"#a6d96a\", \"#66bd63\", \"#1a9850\"],\n        9: [\"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#ffffbf\", \"#d9ef8b\", \"#a6d96a\", \"#66bd63\", \"#1a9850\"],\n        10: [\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#d9ef8b\", \"#a6d96a\", \"#66bd63\", \"#1a9850\", \"#006837\"],\n        11: [\"#a50026\", \"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#ffffbf\", \"#d9ef8b\", \"#a6d96a\", \"#66bd63\", \"#1a9850\", \"#006837\"]\n      },\n      Accent: {\n        3: [\"#7fc97f\", \"#beaed4\", \"#fdc086\"],\n        4: [\"#7fc97f\", \"#beaed4\", \"#fdc086\", \"#ffff99\"],\n        5: [\"#7fc97f\", \"#beaed4\", \"#fdc086\", \"#ffff99\", \"#386cb0\"],\n        6: [\"#7fc97f\", \"#beaed4\", \"#fdc086\", \"#ffff99\", \"#386cb0\", \"#f0027f\"],\n        7: [\"#7fc97f\", \"#beaed4\", \"#fdc086\", \"#ffff99\", \"#386cb0\", \"#f0027f\", \"#bf5b17\"],\n        8: [\"#7fc97f\", \"#beaed4\", \"#fdc086\", \"#ffff99\", \"#386cb0\", \"#f0027f\", \"#bf5b17\", \"#666666\"]\n      },\n      Dark2: {\n        3: [\"#1b9e77\", \"#d95f02\", \"#7570b3\"],\n        4: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\"],\n        5: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\"],\n        6: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\", \"#e6ab02\"],\n        7: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\", \"#e6ab02\", \"#a6761d\"],\n        8: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\", \"#e6ab02\", \"#a6761d\", \"#666666\"]\n      },\n      Paired: {\n        3: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\"],\n        4: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\"],\n        5: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\"],\n        6: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\"],\n        7: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\"],\n        8: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\"],\n        9: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\", \"#cab2d6\"],\n        10: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\", \"#cab2d6\", \"#6a3d9a\"],\n        11: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\", \"#cab2d6\", \"#6a3d9a\", \"#ffff99\"],\n        12: [\"#a6cee3\", \"#1f78b4\", \"#b2df8a\", \"#33a02c\", \"#fb9a99\", \"#e31a1c\", \"#fdbf6f\", \"#ff7f00\", \"#cab2d6\", \"#6a3d9a\", \"#ffff99\", \"#b15928\"]\n      },\n      Pastel1: {\n        3: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\"],\n        4: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\"],\n        5: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\", \"#fed9a6\"],\n        6: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\", \"#fed9a6\", \"#ffffcc\"],\n        7: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\", \"#fed9a6\", \"#ffffcc\", \"#e5d8bd\"],\n        8: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\", \"#fed9a6\", \"#ffffcc\", \"#e5d8bd\", \"#fddaec\"],\n        9: [\"#fbb4ae\", \"#b3cde3\", \"#ccebc5\", \"#decbe4\", \"#fed9a6\", \"#ffffcc\", \"#e5d8bd\", \"#fddaec\", \"#f2f2f2\"]\n      },\n      Pastel2: {\n        3: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\"],\n        4: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\", \"#f4cae4\"],\n        5: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\", \"#f4cae4\", \"#e6f5c9\"],\n        6: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\", \"#f4cae4\", \"#e6f5c9\", \"#fff2ae\"],\n        7: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\", \"#f4cae4\", \"#e6f5c9\", \"#fff2ae\", \"#f1e2cc\"],\n        8: [\"#b3e2cd\", \"#fdcdac\", \"#cbd5e8\", \"#f4cae4\", \"#e6f5c9\", \"#fff2ae\", \"#f1e2cc\", \"#cccccc\"]\n      },\n      Set1: {\n        3: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\"],\n        4: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\"],\n        5: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\"],\n        6: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\", \"#ffff33\"],\n        7: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\", \"#ffff33\", \"#a65628\"],\n        8: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\", \"#ffff33\", \"#a65628\", \"#f781bf\"],\n        9: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\", \"#984ea3\", \"#ff7f00\", \"#ffff33\", \"#a65628\", \"#f781bf\", \"#999999\"]\n      },\n      Set2: {\n        3: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\"],\n        4: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\"],\n        5: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\"],\n        6: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\", \"#ffd92f\"],\n        7: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\", \"#ffd92f\", \"#e5c494\"],\n        8: [\"#66c2a5\", \"#fc8d62\", \"#8da0cb\", \"#e78ac3\", \"#a6d854\", \"#ffd92f\", \"#e5c494\", \"#b3b3b3\"]\n      },\n      Set3: {\n        3: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\"],\n        4: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\"],\n        5: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\"],\n        6: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\"],\n        7: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\"],\n        8: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\"],\n        9: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\", \"#d9d9d9\"],\n        10: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\", \"#d9d9d9\", \"#bc80bd\"],\n        11: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\", \"#d9d9d9\", \"#bc80bd\", \"#ccebc5\"],\n        12: [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\", \"#d9d9d9\", \"#bc80bd\", \"#ccebc5\", \"#ffed6f\"]\n      }\n    }) ? n.call(t, r, t, e) : n) || (e.exports = a);\n  }, function (e, t, r) {\n    (function (t) {\n      \"pseudomap\" === t.env.npm_package_name && \"test\" === t.env.npm_lifecycle_script && (t.env.TEST_PSEUDOMAP = \"true\"), \"function\" != typeof Map || t.env.TEST_PSEUDOMAP ? e.exports = r(64) : e.exports = Map;\n    }).call(this, r(27));\n  }, function (e, t) {\n    var r = Object.prototype.hasOwnProperty;\n\n    function PseudoMap(e) {\n      if (!(this instanceof PseudoMap)) throw new TypeError(\"Constructor PseudoMap requires 'new'\");\n      if (this.clear(), e) if (e instanceof PseudoMap || \"function\" == typeof Map && e instanceof Map) e.forEach(function (e, t) {\n        this.set(t, e);\n      }, this);else {\n        if (!Array.isArray(e)) throw new TypeError(\"invalid argument\");\n        e.forEach(function (e) {\n          this.set(e[0], e[1]);\n        }, this);\n      }\n    }\n\n    function same(e, t) {\n      return e === t || e != e && t != t;\n    }\n\n    function find(e, t) {\n      for (var n = 0, a = \"_\" + t, i = a; r.call(e, i); i = a + n++) if (same(e[i].key, t)) return e[i];\n    }\n\n    e.exports = PseudoMap, PseudoMap.prototype.forEach = function (e, t) {\n      t = t || this, Object.keys(this._data).forEach(function (r) {\n        \"size\" !== r && e.call(t, this._data[r].value, this._data[r].key);\n      }, this);\n    }, PseudoMap.prototype.has = function (e) {\n      return !!find(this._data, e);\n    }, PseudoMap.prototype.get = function (e) {\n      var t = find(this._data, e);\n      return t && t.value;\n    }, PseudoMap.prototype.set = function (e, t) {\n      !function set(e, t, n) {\n        for (var a = 0, i = \"_\" + t, o = i; r.call(e, o); o = i + a++) if (same(e[o].key, t)) return void (e[o].value = n);\n\n        e.size++, e[o] = new function Entry(e, t, r) {\n          this.key = e, this.value = t, this._index = r;\n        }(t, n, o);\n      }(this._data, e, t);\n    }, PseudoMap.prototype.delete = function (e) {\n      var t = find(this._data, e);\n      t && (delete this._data[t._index], this._data.size--);\n    }, PseudoMap.prototype.clear = function () {\n      var e = Object.create(null);\n      e.size = 0, Object.defineProperty(this, \"_data\", {\n        value: e,\n        enumerable: !1,\n        configurable: !0,\n        writable: !1\n      });\n    }, Object.defineProperty(PseudoMap.prototype, \"size\", {\n      get: function () {\n        return this._data.size;\n      },\n      set: function (e) {},\n      enumerable: !0,\n      configurable: !0\n    }), PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function () {\n      throw new Error(\"iterators are not implemented in this version\");\n    };\n  }, function (e, t, r) {\n    (function (e, n) {\n      var a = /%[sdj%]/g;\n      t.format = function (e) {\n        if (!isString(e)) {\n          for (var t = [], r = 0; r < arguments.length; r++) t.push(inspect(arguments[r]));\n\n          return t.join(\" \");\n        }\n\n        r = 1;\n\n        for (var n = arguments, i = n.length, o = String(e).replace(a, function (e) {\n          if (\"%%\" === e) return \"%\";\n          if (r >= i) return e;\n\n          switch (e) {\n            case \"%s\":\n              return String(n[r++]);\n\n            case \"%d\":\n              return Number(n[r++]);\n\n            case \"%j\":\n              try {\n                return JSON.stringify(n[r++]);\n              } catch (e) {\n                return \"[Circular]\";\n              }\n\n            default:\n              return e;\n          }\n        }), u = n[r]; r < i; u = n[++r]) isNull(u) || !isObject(u) ? o += \" \" + u : o += \" \" + inspect(u);\n\n        return o;\n      }, t.deprecate = function (r, a) {\n        if (isUndefined(e.process)) return function () {\n          return t.deprecate(r, a).apply(this, arguments);\n        };\n        if (!0 === n.noDeprecation) return r;\n        var i = !1;\n        return function deprecated() {\n          if (!i) {\n            if (n.throwDeprecation) throw new Error(a);\n            n.traceDeprecation ? console.trace(a) : console.error(a), i = !0;\n          }\n\n          return r.apply(this, arguments);\n        };\n      };\n      var i,\n          o = {};\n\n      function inspect(e, r) {\n        var n = {\n          seen: [],\n          stylize: stylizeNoColor\n        };\n        return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), isBoolean(r) ? n.showHidden = r : r && t._extend(n, r), isUndefined(n.showHidden) && (n.showHidden = !1), isUndefined(n.depth) && (n.depth = 2), isUndefined(n.colors) && (n.colors = !1), isUndefined(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = stylizeWithColor), formatValue(n, e, n.depth);\n      }\n\n      function stylizeWithColor(e, t) {\n        var r = inspect.styles[t];\n        return r ? \"\u001b[\" + inspect.colors[r][0] + \"m\" + e + \"\u001b[\" + inspect.colors[r][1] + \"m\" : e;\n      }\n\n      function stylizeNoColor(e, t) {\n        return e;\n      }\n\n      function formatValue(e, r, n) {\n        if (e.customInspect && r && isFunction(r.inspect) && r.inspect !== t.inspect && (!r.constructor || r.constructor.prototype !== r)) {\n          var a = r.inspect(n, e);\n          return isString(a) || (a = formatValue(e, a, n)), a;\n        }\n\n        var i = function formatPrimitive(e, t) {\n          if (isUndefined(t)) return e.stylize(\"undefined\", \"undefined\");\n\n          if (isString(t)) {\n            var r = \"'\" + JSON.stringify(t).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n            return e.stylize(r, \"string\");\n          }\n\n          if (isNumber(t)) return e.stylize(\"\" + t, \"number\");\n          if (isBoolean(t)) return e.stylize(\"\" + t, \"boolean\");\n          if (isNull(t)) return e.stylize(\"null\", \"null\");\n        }(e, r);\n\n        if (i) return i;\n\n        var o = Object.keys(r),\n            u = function arrayToHash(e) {\n          var t = {};\n          return e.forEach(function (e, r) {\n            t[e] = !0;\n          }), t;\n        }(o);\n\n        if (e.showHidden && (o = Object.getOwnPropertyNames(r)), isError(r) && (o.indexOf(\"message\") >= 0 || o.indexOf(\"description\") >= 0)) return formatError(r);\n\n        if (0 === o.length) {\n          if (isFunction(r)) {\n            var s = r.name ? \": \" + r.name : \"\";\n            return e.stylize(\"[Function\" + s + \"]\", \"special\");\n          }\n\n          if (isRegExp(r)) return e.stylize(RegExp.prototype.toString.call(r), \"regexp\");\n          if (isDate(r)) return e.stylize(Date.prototype.toString.call(r), \"date\");\n          if (isError(r)) return formatError(r);\n        }\n\n        var c,\n            l = \"\",\n            f = !1,\n            h = [\"{\", \"}\"];\n        (isArray(r) && (f = !0, h = [\"[\", \"]\"]), isFunction(r)) && (l = \" [Function\" + (r.name ? \": \" + r.name : \"\") + \"]\");\n        return isRegExp(r) && (l = \" \" + RegExp.prototype.toString.call(r)), isDate(r) && (l = \" \" + Date.prototype.toUTCString.call(r)), isError(r) && (l = \" \" + formatError(r)), 0 !== o.length || f && 0 != r.length ? n < 0 ? isRegExp(r) ? e.stylize(RegExp.prototype.toString.call(r), \"regexp\") : e.stylize(\"[Object]\", \"special\") : (e.seen.push(r), c = f ? function formatArray(e, t, r, n, a) {\n          for (var i = [], o = 0, u = t.length; o < u; ++o) hasOwnProperty(t, String(o)) ? i.push(formatProperty(e, t, r, n, String(o), !0)) : i.push(\"\");\n\n          return a.forEach(function (a) {\n            a.match(/^\\d+$/) || i.push(formatProperty(e, t, r, n, a, !0));\n          }), i;\n        }(e, r, n, u, o) : o.map(function (t) {\n          return formatProperty(e, r, n, u, t, f);\n        }), e.seen.pop(), function reduceToSingleString(e, t, r) {\n          if (e.reduce(function (e, t) {\n            return 0, t.indexOf(\"\\n\") >= 0 && 0, e + t.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n          }, 0) > 60) return r[0] + (\"\" === t ? \"\" : t + \"\\n \") + \" \" + e.join(\",\\n  \") + \" \" + r[1];\n          return r[0] + t + \" \" + e.join(\", \") + \" \" + r[1];\n        }(c, l, h)) : h[0] + l + h[1];\n      }\n\n      function formatError(e) {\n        return \"[\" + Error.prototype.toString.call(e) + \"]\";\n      }\n\n      function formatProperty(e, t, r, n, a, i) {\n        var o, u, s;\n\n        if ((s = Object.getOwnPropertyDescriptor(t, a) || {\n          value: t[a]\n        }).get ? u = s.set ? e.stylize(\"[Getter/Setter]\", \"special\") : e.stylize(\"[Getter]\", \"special\") : s.set && (u = e.stylize(\"[Setter]\", \"special\")), hasOwnProperty(n, a) || (o = \"[\" + a + \"]\"), u || (e.seen.indexOf(s.value) < 0 ? (u = isNull(r) ? formatValue(e, s.value, null) : formatValue(e, s.value, r - 1)).indexOf(\"\\n\") > -1 && (u = i ? u.split(\"\\n\").map(function (e) {\n          return \"  \" + e;\n        }).join(\"\\n\").substr(2) : \"\\n\" + u.split(\"\\n\").map(function (e) {\n          return \"   \" + e;\n        }).join(\"\\n\")) : u = e.stylize(\"[Circular]\", \"special\")), isUndefined(o)) {\n          if (i && a.match(/^\\d+$/)) return u;\n          (o = JSON.stringify(\"\" + a)).match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/) ? (o = o.substr(1, o.length - 2), o = e.stylize(o, \"name\")) : (o = o.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), o = e.stylize(o, \"string\"));\n        }\n\n        return o + \": \" + u;\n      }\n\n      function isArray(e) {\n        return Array.isArray(e);\n      }\n\n      function isBoolean(e) {\n        return \"boolean\" == typeof e;\n      }\n\n      function isNull(e) {\n        return null === e;\n      }\n\n      function isNumber(e) {\n        return \"number\" == typeof e;\n      }\n\n      function isString(e) {\n        return \"string\" == typeof e;\n      }\n\n      function isUndefined(e) {\n        return void 0 === e;\n      }\n\n      function isRegExp(e) {\n        return isObject(e) && \"[object RegExp]\" === objectToString(e);\n      }\n\n      function isObject(e) {\n        return \"object\" == typeof e && null !== e;\n      }\n\n      function isDate(e) {\n        return isObject(e) && \"[object Date]\" === objectToString(e);\n      }\n\n      function isError(e) {\n        return isObject(e) && (\"[object Error]\" === objectToString(e) || e instanceof Error);\n      }\n\n      function isFunction(e) {\n        return \"function\" == typeof e;\n      }\n\n      function objectToString(e) {\n        return Object.prototype.toString.call(e);\n      }\n\n      function pad(e) {\n        return e < 10 ? \"0\" + e.toString(10) : e.toString(10);\n      }\n\n      t.debuglog = function (e) {\n        if (isUndefined(i) && (i = n.env.NODE_DEBUG || \"\"), e = e.toUpperCase(), !o[e]) if (new RegExp(\"\\\\b\" + e + \"\\\\b\", \"i\").test(i)) {\n          var r = n.pid;\n\n          o[e] = function () {\n            var n = t.format.apply(t, arguments);\n            console.error(\"%s %d: %s\", e, r, n);\n          };\n        } else o[e] = function () {};\n        return o[e];\n      }, t.inspect = inspect, inspect.colors = {\n        bold: [1, 22],\n        italic: [3, 23],\n        underline: [4, 24],\n        inverse: [7, 27],\n        white: [37, 39],\n        grey: [90, 39],\n        black: [30, 39],\n        blue: [34, 39],\n        cyan: [36, 39],\n        green: [32, 39],\n        magenta: [35, 39],\n        red: [31, 39],\n        yellow: [33, 39]\n      }, inspect.styles = {\n        special: \"cyan\",\n        number: \"yellow\",\n        boolean: \"yellow\",\n        undefined: \"grey\",\n        null: \"bold\",\n        string: \"green\",\n        date: \"magenta\",\n        regexp: \"red\"\n      }, t.isArray = isArray, t.isBoolean = isBoolean, t.isNull = isNull, t.isNullOrUndefined = function isNullOrUndefined(e) {\n        return null == e;\n      }, t.isNumber = isNumber, t.isString = isString, t.isSymbol = function isSymbol(e) {\n        return \"symbol\" == typeof e;\n      }, t.isUndefined = isUndefined, t.isRegExp = isRegExp, t.isObject = isObject, t.isDate = isDate, t.isError = isError, t.isFunction = isFunction, t.isPrimitive = function isPrimitive(e) {\n        return null === e || \"boolean\" == typeof e || \"number\" == typeof e || \"string\" == typeof e || \"symbol\" == typeof e || void 0 === e;\n      }, t.isBuffer = r(67);\n      var u = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n      function hasOwnProperty(e, t) {\n        return Object.prototype.hasOwnProperty.call(e, t);\n      }\n\n      t.log = function () {\n        console.log(\"%s - %s\", function timestamp() {\n          var e = new Date(),\n              t = [pad(e.getHours()), pad(e.getMinutes()), pad(e.getSeconds())].join(\":\");\n          return [e.getDate(), u[e.getMonth()], t].join(\" \");\n        }(), t.format.apply(t, arguments));\n      }, t.inherits = r(68), t._extend = function (e, t) {\n        if (!t || !isObject(t)) return e;\n\n        for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];\n\n        return e;\n      };\n    }).call(this, r(66), r(27));\n  }, function (e, t) {\n    var r;\n\n    r = function () {\n      return this;\n    }();\n\n    try {\n      r = r || Function(\"return this\")() || (0, eval)(\"this\");\n    } catch (e) {\n      \"object\" == typeof window && (r = window);\n    }\n\n    e.exports = r;\n  }, function (e, t) {\n    e.exports = function isBuffer(e) {\n      return e && \"object\" == typeof e && \"function\" == typeof e.copy && \"function\" == typeof e.fill && \"function\" == typeof e.readUInt8;\n    };\n  }, function (e, t) {\n    \"function\" == typeof Object.create ? e.exports = function inherits(e, t) {\n      e.super_ = t, e.prototype = Object.create(t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      });\n    } : e.exports = function inherits(e, t) {\n      e.super_ = t;\n\n      var r = function () {};\n\n      r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;\n    };\n  }, function (e, t) {\n    function Yallist(e) {\n      var t = this;\n      if (t instanceof Yallist || (t = new Yallist()), t.tail = null, t.head = null, t.length = 0, e && \"function\" == typeof e.forEach) e.forEach(function (e) {\n        t.push(e);\n      });else if (arguments.length > 0) for (var r = 0, n = arguments.length; r < n; r++) t.push(arguments[r]);\n      return t;\n    }\n\n    function push(e, t) {\n      e.tail = new Node(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;\n    }\n\n    function unshift(e, t) {\n      e.head = new Node(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;\n    }\n\n    function Node(e, t, r, n) {\n      if (!(this instanceof Node)) return new Node(e, t, r, n);\n      this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;\n    }\n\n    e.exports = Yallist, Yallist.Node = Node, Yallist.create = Yallist, Yallist.prototype.removeNode = function (e) {\n      if (e.list !== this) throw new Error(\"removing node which does not belong to this list\");\n      var t = e.next,\n          r = e.prev;\n      t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null;\n    }, Yallist.prototype.unshiftNode = function (e) {\n      if (e !== this.head) {\n        e.list && e.list.removeNode(e);\n        var t = this.head;\n        e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;\n      }\n    }, Yallist.prototype.pushNode = function (e) {\n      if (e !== this.tail) {\n        e.list && e.list.removeNode(e);\n        var t = this.tail;\n        e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;\n      }\n    }, Yallist.prototype.push = function () {\n      for (var e = 0, t = arguments.length; e < t; e++) push(this, arguments[e]);\n\n      return this.length;\n    }, Yallist.prototype.unshift = function () {\n      for (var e = 0, t = arguments.length; e < t; e++) unshift(this, arguments[e]);\n\n      return this.length;\n    }, Yallist.prototype.pop = function () {\n      if (this.tail) {\n        var e = this.tail.value;\n        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;\n      }\n    }, Yallist.prototype.shift = function () {\n      if (this.head) {\n        var e = this.head.value;\n        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;\n      }\n    }, Yallist.prototype.forEach = function (e, t) {\n      t = t || this;\n\n      for (var r = this.head, n = 0; null !== r; n++) e.call(t, r.value, n, this), r = r.next;\n    }, Yallist.prototype.forEachReverse = function (e, t) {\n      t = t || this;\n\n      for (var r = this.tail, n = this.length - 1; null !== r; n--) e.call(t, r.value, n, this), r = r.prev;\n    }, Yallist.prototype.get = function (e) {\n      for (var t = 0, r = this.head; null !== r && t < e; t++) r = r.next;\n\n      if (t === e && null !== r) return r.value;\n    }, Yallist.prototype.getReverse = function (e) {\n      for (var t = 0, r = this.tail; null !== r && t < e; t++) r = r.prev;\n\n      if (t === e && null !== r) return r.value;\n    }, Yallist.prototype.map = function (e, t) {\n      t = t || this;\n\n      for (var r = new Yallist(), n = this.head; null !== n;) r.push(e.call(t, n.value, this)), n = n.next;\n\n      return r;\n    }, Yallist.prototype.mapReverse = function (e, t) {\n      t = t || this;\n\n      for (var r = new Yallist(), n = this.tail; null !== n;) r.push(e.call(t, n.value, this)), n = n.prev;\n\n      return r;\n    }, Yallist.prototype.reduce = function (e, t) {\n      var r,\n          n = this.head;\n      if (arguments.length > 1) r = t;else {\n        if (!this.head) throw new TypeError(\"Reduce of empty list with no initial value\");\n        n = this.head.next, r = this.head.value;\n      }\n\n      for (var a = 0; null !== n; a++) r = e(r, n.value, a), n = n.next;\n\n      return r;\n    }, Yallist.prototype.reduceReverse = function (e, t) {\n      var r,\n          n = this.tail;\n      if (arguments.length > 1) r = t;else {\n        if (!this.tail) throw new TypeError(\"Reduce of empty list with no initial value\");\n        n = this.tail.prev, r = this.tail.value;\n      }\n\n      for (var a = this.length - 1; null !== n; a--) r = e(r, n.value, a), n = n.prev;\n\n      return r;\n    }, Yallist.prototype.toArray = function () {\n      for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) e[t] = r.value, r = r.next;\n\n      return e;\n    }, Yallist.prototype.toArrayReverse = function () {\n      for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) e[t] = r.value, r = r.prev;\n\n      return e;\n    }, Yallist.prototype.slice = function (e, t) {\n      (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);\n      var r = new Yallist();\n      if (t < e || t < 0) return r;\n      e < 0 && (e = 0), t > this.length && (t = this.length);\n\n      for (var n = 0, a = this.head; null !== a && n < e; n++) a = a.next;\n\n      for (; null !== a && n < t; n++, a = a.next) r.push(a.value);\n\n      return r;\n    }, Yallist.prototype.sliceReverse = function (e, t) {\n      (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);\n      var r = new Yallist();\n      if (t < e || t < 0) return r;\n      e < 0 && (e = 0), t > this.length && (t = this.length);\n\n      for (var n = this.length, a = this.tail; null !== a && n > t; n--) a = a.prev;\n\n      for (; null !== a && n > e; n--, a = a.prev) r.push(a.value);\n\n      return r;\n    }, Yallist.prototype.reverse = function () {\n      for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {\n        var n = r.prev;\n        r.prev = r.next, r.next = n;\n      }\n\n      return this.head = t, this.tail = e, this;\n    };\n  }, function (e, t, r) {\n    \"use strict\";\n\n    var n = window.URL || window.webkitURL;\n\n    e.exports = function (e, t) {\n      try {\n        try {\n          var r;\n\n          try {\n            (r = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder)()).append(e), r = r.getBlob();\n          } catch (t) {\n            r = new Blob([e]);\n          }\n\n          return new Worker(n.createObjectURL(r));\n        } catch (t) {\n          return new Worker(\"data:application/javascript,\" + encodeURIComponent(e));\n        }\n      } catch (e) {\n        if (!t) throw Error(\"Inline worker is not supported\");\n        return new Worker(t);\n      }\n    };\n  }, function (e, t, r) {\n    \"use strict\";\n\n    r.r(t);\n    var n = {};\n    r.r(n), r.d(n, \"create\", function () {\n      return create;\n    }), r.d(n, \"clone\", function () {\n      return clone;\n    }), r.d(n, \"copy\", function () {\n      return mat4_copy;\n    }), r.d(n, \"fromValues\", function () {\n      return fromValues;\n    }), r.d(n, \"set\", function () {\n      return mat4_set;\n    }), r.d(n, \"identity\", function () {\n      return identity;\n    }), r.d(n, \"transpose\", function () {\n      return transpose;\n    }), r.d(n, \"invert\", function () {\n      return invert;\n    }), r.d(n, \"adjoint\", function () {\n      return adjoint;\n    }), r.d(n, \"determinant\", function () {\n      return determinant;\n    }), r.d(n, \"multiply\", function () {\n      return multiply;\n    }), r.d(n, \"translate\", function () {\n      return mat4_translate;\n    }), r.d(n, \"scale\", function () {\n      return mat4_scale;\n    }), r.d(n, \"rotate\", function () {\n      return mat4_rotate;\n    }), r.d(n, \"rotateX\", function () {\n      return rotateX;\n    }), r.d(n, \"rotateY\", function () {\n      return rotateY;\n    }), r.d(n, \"rotateZ\", function () {\n      return rotateZ;\n    }), r.d(n, \"fromTranslation\", function () {\n      return fromTranslation;\n    }), r.d(n, \"fromScaling\", function () {\n      return fromScaling;\n    }), r.d(n, \"fromRotation\", function () {\n      return fromRotation;\n    }), r.d(n, \"fromXRotation\", function () {\n      return fromXRotation;\n    }), r.d(n, \"fromYRotation\", function () {\n      return fromYRotation;\n    }), r.d(n, \"fromZRotation\", function () {\n      return fromZRotation;\n    }), r.d(n, \"fromRotationTranslation\", function () {\n      return fromRotationTranslation;\n    }), r.d(n, \"fromQuat2\", function () {\n      return fromQuat2;\n    }), r.d(n, \"getTranslation\", function () {\n      return getTranslation;\n    }), r.d(n, \"getScaling\", function () {\n      return getScaling;\n    }), r.d(n, \"getRotation\", function () {\n      return getRotation;\n    }), r.d(n, \"fromRotationTranslationScale\", function () {\n      return fromRotationTranslationScale;\n    }), r.d(n, \"fromRotationTranslationScaleOrigin\", function () {\n      return fromRotationTranslationScaleOrigin;\n    }), r.d(n, \"fromQuat\", function () {\n      return fromQuat;\n    }), r.d(n, \"frustum\", function () {\n      return frustum;\n    }), r.d(n, \"perspective\", function () {\n      return perspective;\n    }), r.d(n, \"perspectiveFromFieldOfView\", function () {\n      return perspectiveFromFieldOfView;\n    }), r.d(n, \"ortho\", function () {\n      return ortho;\n    }), r.d(n, \"lookAt\", function () {\n      return lookAt;\n    }), r.d(n, \"targetTo\", function () {\n      return targetTo;\n    }), r.d(n, \"str\", function () {\n      return mat4_str;\n    }), r.d(n, \"frob\", function () {\n      return frob;\n    }), r.d(n, \"add\", function () {\n      return mat4_add;\n    }), r.d(n, \"subtract\", function () {\n      return subtract;\n    }), r.d(n, \"multiplyScalar\", function () {\n      return multiplyScalar;\n    }), r.d(n, \"multiplyScalarAndAdd\", function () {\n      return multiplyScalarAndAdd;\n    }), r.d(n, \"exactEquals\", function () {\n      return exactEquals;\n    }), r.d(n, \"equals\", function () {\n      return mat4_equals;\n    }), r.d(n, \"mul\", function () {\n      return te;\n    }), r.d(n, \"sub\", function () {\n      return re;\n    });\n    var a = {};\n    r.r(a), r.d(a, \"create\", function () {\n      return vec4_create;\n    }), r.d(a, \"clone\", function () {\n      return vec4_clone;\n    }), r.d(a, \"fromValues\", function () {\n      return vec4_fromValues;\n    }), r.d(a, \"copy\", function () {\n      return vec4_copy;\n    }), r.d(a, \"set\", function () {\n      return vec4_set;\n    }), r.d(a, \"add\", function () {\n      return vec4_add;\n    }), r.d(a, \"subtract\", function () {\n      return vec4_subtract;\n    }), r.d(a, \"multiply\", function () {\n      return vec4_multiply;\n    }), r.d(a, \"divide\", function () {\n      return divide;\n    }), r.d(a, \"ceil\", function () {\n      return vec4_ceil;\n    }), r.d(a, \"floor\", function () {\n      return vec4_floor;\n    }), r.d(a, \"min\", function () {\n      return vec4_min;\n    }), r.d(a, \"max\", function () {\n      return vec4_max;\n    }), r.d(a, \"round\", function () {\n      return round;\n    }), r.d(a, \"scale\", function () {\n      return vec4_scale;\n    }), r.d(a, \"scaleAndAdd\", function () {\n      return scaleAndAdd;\n    }), r.d(a, \"distance\", function () {\n      return distance;\n    }), r.d(a, \"squaredDistance\", function () {\n      return squaredDistance;\n    }), r.d(a, \"length\", function () {\n      return vec4_length;\n    }), r.d(a, \"squaredLength\", function () {\n      return squaredLength;\n    }), r.d(a, \"negate\", function () {\n      return negate;\n    }), r.d(a, \"inverse\", function () {\n      return inverse;\n    }), r.d(a, \"normalize\", function () {\n      return vec4_normalize;\n    }), r.d(a, \"dot\", function () {\n      return dot;\n    }), r.d(a, \"lerp\", function () {\n      return lerp;\n    }), r.d(a, \"random\", function () {\n      return random;\n    }), r.d(a, \"transformMat4\", function () {\n      return transformMat4;\n    }), r.d(a, \"transformQuat\", function () {\n      return transformQuat;\n    }), r.d(a, \"str\", function () {\n      return vec4_str;\n    }), r.d(a, \"exactEquals\", function () {\n      return vec4_exactEquals;\n    }), r.d(a, \"equals\", function () {\n      return vec4_equals;\n    }), r.d(a, \"sub\", function () {\n      return ne;\n    }), r.d(a, \"mul\", function () {\n      return ae;\n    }), r.d(a, \"div\", function () {\n      return ie;\n    }), r.d(a, \"dist\", function () {\n      return oe;\n    }), r.d(a, \"sqrDist\", function () {\n      return ue;\n    }), r.d(a, \"len\", function () {\n      return se;\n    }), r.d(a, \"sqrLen\", function () {\n      return ce;\n    }), r.d(a, \"forEach\", function () {\n      return le;\n    });\n    var i = {};\n    r.r(i), r.d(i, \"colorShaderGLSL\", function () {\n      return qe;\n    }), r.d(i, \"filterShaderGLSL\", function () {\n      return je;\n    }), r.d(i, \"widthShaderGLSL\", function () {\n      return We;\n    });\n    var o = {};\n    r.r(o), r.d(o, \"symbolShaderGLSL\", function () {\n      return Xe;\n    });\n    var u = {};\n    r.r(u), r.d(u, \"number\", function () {\n      return ba;\n    }), r.d(u, \"category\", function () {\n      return xa;\n    }), r.d(u, \"list\", function () {\n      return ka;\n    }), r.d(u, \"rgb\", function () {\n      return Ta;\n    }), r.d(u, \"rgba\", function () {\n      return wa;\n    }), r.d(u, \"transition\", function () {\n      return Ca;\n    }), r.d(u, \"nin\", function () {\n      return Ma;\n    }), r.d(u, \"in\", function () {\n      return Ea;\n    }), r.d(u, \"between\", function () {\n      return Aa;\n    }), r.d(u, \"mul\", function () {\n      return Sa;\n    }), r.d(u, \"div\", function () {\n      return Pa;\n    }), r.d(u, \"add\", function () {\n      return Ia;\n    }), r.d(u, \"sub\", function () {\n      return Na;\n    }), r.d(u, \"pow\", function () {\n      return Da;\n    }), r.d(u, \"mod\", function () {\n      return Ra;\n    }), r.d(u, \"greaterThan\", function () {\n      return Fa;\n    }), r.d(u, \"greaterThanOrEqualTo\", function () {\n      return Oa;\n    }), r.d(u, \"lessThan\", function () {\n      return La;\n    }), r.d(u, \"lessThanOrEqualTo\", function () {\n      return Ba;\n    }), r.d(u, \"equals\", function () {\n      return Va;\n    }), r.d(u, \"notEquals\", function () {\n      return Ga;\n    }), r.d(u, \"and\", function () {\n      return Ua;\n    }), r.d(u, \"or\", function () {\n      return za;\n    }), r.d(u, \"gt\", function () {\n      return qa;\n    }), r.d(u, \"gte\", function () {\n      return ja;\n    }), r.d(u, \"lt\", function () {\n      return Wa;\n    }), r.d(u, \"lte\", function () {\n      return Ha;\n    }), r.d(u, \"eq\", function () {\n      return Ya;\n    }), r.d(u, \"neq\", function () {\n      return Za;\n    }), r.d(u, \"blend\", function () {\n      return Xa;\n    }), r.d(u, \"buckets\", function () {\n      return Qa;\n    }), r.d(u, \"cielab\", function () {\n      return $a;\n    }), r.d(u, \"clusterAvg\", function () {\n      return Ja;\n    }), r.d(u, \"clusterMax\", function () {\n      return Ka;\n    }), r.d(u, \"clusterMin\", function () {\n      return ei;\n    }), r.d(u, \"clusterMode\", function () {\n      return ti;\n    }), r.d(u, \"clusterSum\", function () {\n      return ri;\n    }), r.d(u, \"clusterCount\", function () {\n      return ni;\n    }), r.d(u, \"clusterTime\", function () {\n      return ai;\n    }), r.d(u, \"constant\", function () {\n      return ii;\n    }), r.d(u, \"image\", function () {\n      return oi;\n    }), r.d(u, \"svg\", function () {\n      return ui;\n    }), r.d(u, \"hex\", function () {\n      return si;\n    }), r.d(u, \"hsl\", function () {\n      return ci;\n    }), r.d(u, \"hsla\", function () {\n      return li;\n    }), r.d(u, \"hsv\", function () {\n      return fi;\n    }), r.d(u, \"hsva\", function () {\n      return hi;\n    }), r.d(u, \"cubic\", function () {\n      return di;\n    }), r.d(u, \"ilinear\", function () {\n      return pi;\n    }), r.d(u, \"linear\", function () {\n      return mi;\n    }), r.d(u, \"namedColor\", function () {\n      return vi;\n    }), r.d(u, \"now\", function () {\n      return yi;\n    }), r.d(u, \"opacity\", function () {\n      return gi;\n    }), r.d(u, \"asc\", function () {\n      return _i;\n    }), r.d(u, \"desc\", function () {\n      return bi;\n    }), r.d(u, \"noOrder\", function () {\n      return xi;\n    }), r.d(u, \"width\", function () {\n      return ki;\n    }), r.d(u, \"reverse\", function () {\n      return Ti;\n    }), r.d(u, \"property\", function () {\n      return wi;\n    }), r.d(u, \"prop\", function () {\n      return wi;\n    }), r.d(u, \"globalQuantiles\", function () {\n      return Ci;\n    }), r.d(u, \"viewportQuantiles\", function () {\n      return Ei;\n    }), r.d(u, \"globalEqIntervals\", function () {\n      return Mi;\n    }), r.d(u, \"viewportEqIntervals\", function () {\n      return Ai;\n    }), r.d(u, \"globalStandardDev\", function () {\n      return Si;\n    }), r.d(u, \"viewportStandardDev\", function () {\n      return Pi;\n    }), r.d(u, \"ramp\", function () {\n      return Ii;\n    }), r.d(u, \"time\", function () {\n      return Ni;\n    }), r.d(u, \"date\", function () {\n      return Ni;\n    }), r.d(u, \"timeRange\", function () {\n      return Di;\n    }), r.d(u, \"top\", function () {\n      return Ri;\n    }), r.d(u, \"fade\", function () {\n      return Fi;\n    }), r.d(u, \"animation\", function () {\n      return Oi;\n    }), r.d(u, \"log\", function () {\n      return Li;\n    }), r.d(u, \"sqrt\", function () {\n      return Bi;\n    }), r.d(u, \"sin\", function () {\n      return Vi;\n    }), r.d(u, \"cos\", function () {\n      return Gi;\n    }), r.d(u, \"tan\", function () {\n      return Ui;\n    }), r.d(u, \"sign\", function () {\n      return zi;\n    }), r.d(u, \"abs\", function () {\n      return qi;\n    }), r.d(u, \"isNull\", function () {\n      return ji;\n    }), r.d(u, \"not\", function () {\n      return Wi;\n    }), r.d(u, \"floor\", function () {\n      return Hi;\n    }), r.d(u, \"ceil\", function () {\n      return Yi;\n    }), r.d(u, \"variable\", function () {\n      return Zi;\n    }), r.d(u, \"var\", function () {\n      return Zi;\n    }), r.d(u, \"viewportAvg\", function () {\n      return Xi;\n    }), r.d(u, \"viewportMax\", function () {\n      return Qi;\n    }), r.d(u, \"viewportMin\", function () {\n      return $i;\n    }), r.d(u, \"viewportSum\", function () {\n      return Ji;\n    }), r.d(u, \"viewportCount\", function () {\n      return Ki;\n    }), r.d(u, \"viewportPercentile\", function () {\n      return eo;\n    }), r.d(u, \"viewportHistogram\", function () {\n      return to;\n    }), r.d(u, \"viewportFeatures\", function () {\n      return ro;\n    }), r.d(u, \"globalAvg\", function () {\n      return no;\n    }), r.d(u, \"globalMax\", function () {\n      return ao;\n    }), r.d(u, \"globalMin\", function () {\n      return io;\n    }), r.d(u, \"globalSum\", function () {\n      return oo;\n    }), r.d(u, \"globalCount\", function () {\n      return uo;\n    }), r.d(u, \"globalPercentile\", function () {\n      return so;\n    }), r.d(u, \"globalHistogram\", function () {\n      return co;\n    }), r.d(u, \"zoom\", function () {\n      return lo;\n    }), r.d(u, \"scaled\", function () {\n      return fo;\n    }), r.d(u, \"zoomrange\", function () {\n      return ho;\n    }), r.d(u, \"placement\", function () {\n      return po;\n    }), r.d(u, \"translate\", function () {\n      return mo;\n    }), r.d(u, \"rotate\", function () {\n      return vo;\n    }), r.d(u, \"alphaNormalize\", function () {\n      return yo;\n    }), r.d(u, \"HOLD\", function () {\n      return go;\n    }), r.d(u, \"TRUE\", function () {\n      return _o;\n    }), r.d(u, \"FALSE\", function () {\n      return bo;\n    }), r.d(u, \"PI\", function () {\n      return xo;\n    }), r.d(u, \"E\", function () {\n      return ko;\n    }), r.d(u, \"BICYCLE\", function () {\n      return To;\n    }), r.d(u, \"BUILDING\", function () {\n      return wo;\n    }), r.d(u, \"BUS\", function () {\n      return Co;\n    }), r.d(u, \"CAR\", function () {\n      return Eo;\n    }), r.d(u, \"CIRCLE\", function () {\n      return Mo;\n    }), r.d(u, \"CIRCLE_OUTLINE\", function () {\n      return Ao;\n    }), r.d(u, \"CROSS\", function () {\n      return So;\n    }), r.d(u, \"FLAG\", function () {\n      return Po;\n    }), r.d(u, \"HOUSE\", function () {\n      return Io;\n    }), r.d(u, \"MARKER\", function () {\n      return No;\n    }), r.d(u, \"MARKER_OUTLINE\", function () {\n      return Do;\n    }), r.d(u, \"PLUS\", function () {\n      return Ro;\n    }), r.d(u, \"SQUARE\", function () {\n      return Fo;\n    }), r.d(u, \"SQUARE_OUTLINE\", function () {\n      return Oo;\n    }), r.d(u, \"STAR\", function () {\n      return Lo;\n    }), r.d(u, \"STAR_OUTLINE\", function () {\n      return Bo;\n    }), r.d(u, \"TRIANGLE\", function () {\n      return Vo;\n    }), r.d(u, \"TRIANGLE_OUTLINE\", function () {\n      return Go;\n    }), r.d(u, \"ALIGN_CENTER\", function () {\n      return Uo;\n    }), r.d(u, \"ALIGN_BOTTOM\", function () {\n      return zo;\n    }), r.d(u, \"palettes\", function () {\n      return jr;\n    }), r.d(u, \"Asc\", function () {\n      return Rr;\n    }), r.d(u, \"Desc\", function () {\n      return Fr;\n    });\n    var s = {};\n    r.r(s), r.d(s, \"voyager\", function () {\n      return As;\n    }), r.d(s, \"darkmatter\", function () {\n      return Ss;\n    }), r.d(s, \"positron\", function () {\n      return Ps;\n    });\n    var c = r(7),\n        l = r.n(c),\n        f = r(13),\n        h = r.n(f),\n        d = r(1),\n        p = r.n(d),\n        m = r(4),\n        v = r.n(m),\n        y = r(9),\n        g = r.n(y),\n        _ = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"],\n        b = [1, 1, 1, 0, 0, 0],\n        x = 0,\n        k = 1,\n        T = 2,\n        w = 3,\n        C = 4,\n        E = 5,\n        M = 864e5,\n        A = 36e5,\n        S = 6e4,\n        P = 1e3;\n\n    function startLevel(e) {\n      for (var t = _.length - 1; t > 0 && e[_[t]] === b[t];) --t;\n\n      return t;\n    }\n\n    function pad(e, t) {\n      return e.toString().padStart(t, \"0\");\n    }\n\n    function parsedValue(e) {\n      var t = msToDate(e);\n      return {\n        year: t.getUTCFullYear(),\n        month: t.getUTCMonth() + 1,\n        day: t.getUTCDate(),\n        hour: t.getUTCHours(),\n        minute: t.getUTCMinutes(),\n        second: t.getUTCSeconds()\n      };\n    }\n\n    function invalidPeriod(e, t) {\n      throw new Error(\"Invalid period of \".concat(t, \" between \").concat(e.v1, \" and \").concat(e.v2));\n    }\n\n    function yearWeek(e, t) {\n      var r = function isoDow(e, t, r) {\n        var n = new Date(e, t - 1, r).getDay();\n        return 0 === n ? 7 : n;\n      }(e, 1, 1),\n          n = r > 4 ? 9 - r : 2 - r;\n\n      return Math.abs(t - n) % 7 != 0 ? [] : t < n ? yearWeek(e - 1, t += Math.round((Date.UTC(e, 0, 1) - Date.UTC(e - 1, 0, 1)) / M)) : Date.UTC(e, 0, 1) + (t - 1 + 3) * M >= Date.UTC(e + 1, 0, 1) ? yearWeek(e + 1, t -= Math.round((Date.UTC(e + 1, 0, 1) - Date.UTC(e, 0, 1)) / M)) : [e, 1 + Math.round((t - n) / 7)];\n    }\n\n    function periodISO(e, t) {\n      var r = parsedValue(e),\n          n = parsedValue(t),\n          a = startLevel(r),\n          i = startLevel(n),\n          o = {\n        v1: e,\n        v2: t,\n        t1: r,\n        t2: n\n      };\n      return Math.max(a, i) === x ? function yearsPeriod(e) {\n        var t = e.t2.year - e.t1.year;\n        return 1e3 === t && (e.t1.year - 1) % 1e3 == 0 ? \"M\".concat(1 + (e.t1.year - 1) / 1e3) : 100 === t && (e.t1.year - 1) % 100 == 0 ? \"C\".concat(1 + (e.t1.year - 1) / 100) : 10 === t && e.t1.year % 10 == 0 ? \"D\".concat(e.t1.year / 10) : 1 === t ? pad(e.t1.year, 4) : void invalidPeriod(\"\".concat(t, \" years\"));\n      }(o) : Math.max(a, i) === k ? function monthsPeriod(e) {\n        var t = 12 * e.t2.year + e.t2.month - 12 * e.t1.year - e.t1.month;\n        return 6 === t && (e.t1.month - 1) % 6 == 0 ? \"\".concat(pad(e.t1.year, 4), \"S\").concat(1 + (e.t1.month - 1) / 6) : 4 === t ? \"\".concat(pad(e.t1.year, 4), \"t\").concat(1 + (e.t1.month - 1) / 4) : 3 === t ? \"\".concat(pad(e.t1.year, 4), \"-Q\").concat(1 + (e.t1.month - 1) / 3) : 1 === t ? \"\".concat(pad(e.t1.year, 4), \"-\").concat(pad(e.t1.month, 2)) : void invalidPeriod(\"\".concat(t, \" months\"));\n      }(o) : Math.max(a, i) === T ? function daysPeriod(e) {\n        var t = Math.round((e.v2 - e.v1) / M);\n        if (1 === t) return \"\".concat(pad(e.t1.year, 4), \"-\").concat(pad(e.t1.month, 2), \"-\").concat(pad(e.t1.day, 2));\n\n        if (7 === t) {\n          var r = e.t1.year,\n              n = Date.UTC(r, 0, 1),\n              a = yearWeek(r, 1 + Math.round((e.v1 - n) / M)),\n              i = g()(a, 2),\n              o = i[0],\n              u = i[1];\n          if (o && u) return \"\".concat(pad(o, 4), \"-W\").concat(pad(u, 2));\n          invalidPeriod(\"7 days\");\n        } else invalidPeriod(\"\".concat(t, \" days\"));\n      }(o) : Math.max(a, i) === w ? function hoursPeriod(e) {\n        var t = Math.round((e.v2 - e.v1) / A);\n        if (1 === t) return \"\".concat(pad(e.t1.year, 4), \"-\").concat(pad(e.t1.month, 2), \"-\").concat(pad(e.t1.day, 2), \"T\").concat(pad(e.t1.hour, 2));\n        invalidPeriod(\"\".concat(t, \" hours\"));\n      }(o) : Math.max(a, i) === C ? function minutesPeriod(e) {\n        var t = Math.round((e.v2 - e.v1) / S);\n        if (1 === t) return \"\".concat(pad(e.t1.year, 4), \"-\").concat(pad(e.t1.month, 2), \"-\").concat(pad(e.t1.day, 2), \"T\").concat(pad(e.t1.hour, 2), \":\").concat(pad(e.t1.minute, 2));\n        invalidPeriod(\"\".concat(t, \" minutes\"));\n      }(o) : Math.max(a, i) === E ? function secondsPeriod(e) {\n        var t = Math.round((e.v2 - e.v1) / P);\n        if (1 === t) return \"\".concat(pad(e.t1.year, 4), \"-\").concat(pad(e.t1.month, 2), \"-\").concat(pad(e.t1.day, 2), \"T\").concat(pad(e.t1.hour, 2), \":\").concat(pad(e.t1.minute, 2), \":\").concat(pad(e.t1.second, 2));\n        invalidPeriod(\"\".concat(t, \" seconds\"));\n      }(o) : void invalidPeriod(o, \"fractional seconds\");\n    }\n\n    var I = r(2),\n        N = r.n(I),\n        D = r(0),\n        R = r.n(D),\n        F = r(3),\n        O = r.n(F),\n        L = r(28),\n        B = function (e) {\n      function CartoError(e) {\n        var t;\n        if (p()(this, CartoError), !e) throw Error(\"Invalid CartoError, a message is mandatory\");\n        if (!e.message) throw Error(\"Invalid CartoError, a message is mandatory\");\n        if (!e.type) throw Error(\"Invalid CartoError, a type is mandatory\");\n        return (t = N()(this, R()(CartoError).call(this, \"\".concat(e.type, \" \").concat(e.message)))).name = \"CartoError\", t.type = e.type, t.originalError = e, t;\n      }\n\n      return O()(CartoError, e), CartoError;\n    }(r.n(L)()(Error)),\n        V = function (e) {\n      function CartoParsingError(e) {\n        var t;\n        p()(this, CartoParsingError);\n        return (t = N()(this, R()(CartoParsingError).call(this, {\n          message: e,\n          type: \"[Error]\"\n        }))).name = \"CartoParsingError\", t;\n      }\n\n      return O()(CartoParsingError, e), CartoParsingError;\n    }(B),\n        G = function () {\n      function IsoParser(e) {\n        p()(this, IsoParser), this._format = e;\n      }\n\n      return v()(IsoParser, [{\n        key: \"check\",\n        value: function check(e) {\n          return e.match(this._format);\n        }\n      }]), IsoParser;\n    }();\n\n    function fieldDefault(e, t) {\n      return void 0 === e ? t : Number(e);\n    }\n\n    function dateFields(e) {\n      return {\n        year: fieldDefault(e.year, 1),\n        month: fieldDefault(e.month, 1),\n        day: fieldDefault(e.day, 1),\n        hour: fieldDefault(e.hour, 0),\n        minute: fieldDefault(e.minute, 0),\n        second: fieldDefault(e.second, 0)\n      };\n    }\n\n    function fieldsFromMatch(e) {\n      return dateFields({\n        year: e[1],\n        month: e[2],\n        day: e[3],\n        hour: e[4],\n        minute: e[5],\n        second: e[6]\n      });\n    }\n\n    var U = function (e) {\n      function YMDHMSParser() {\n        return p()(this, YMDHMSParser), N()(this, R()(YMDHMSParser).call(this, /^(\\d\\d\\d\\d)(?:\\-?(\\d\\d)(?:\\-?(\\d\\d)(?:[T\\s]?(\\d\\d)(?:\\:(\\d\\d)(?:\\:(\\d\\d))?)?)?)?)?$/));\n      }\n\n      return O()(YMDHMSParser, e), v()(YMDHMSParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e) || [],\n              r = t.slice(),\n              n = [1, 2, 3, 4, 5, 6].find(function (e) {\n            return void 0 === r[e];\n          }) || 7;\n          return 1 === n ? r[1] = 2 : r[n - 1] = Number(r[n - 1]) + 1, [fieldsFromMatch(t), fieldsFromMatch(r)];\n        }\n      }]), YMDHMSParser;\n    }(G),\n        z = function (e) {\n      function MillenniumParser() {\n        return p()(this, MillenniumParser), N()(this, R()(MillenniumParser).call(this, /^M(\\d+)$/));\n      }\n\n      return O()(MillenniumParser, e), v()(MillenniumParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = function year(e) {\n            return 1e3 * (e - 1) + 1;\n          };\n\n          return [dateFields({\n            year: n(r)\n          }), dateFields({\n            year: n(r + 1)\n          })];\n        }\n      }]), MillenniumParser;\n    }(G),\n        q = function (e) {\n      function CenturyParser() {\n        return p()(this, CenturyParser), N()(this, R()(CenturyParser).call(this, /^C(\\d+)$/));\n      }\n\n      return O()(CenturyParser, e), v()(CenturyParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = function year(e) {\n            return 100 * (e - 1) + 1;\n          };\n\n          return [dateFields({\n            year: n(r)\n          }), dateFields({\n            year: n(r + 1)\n          })];\n        }\n      }]), CenturyParser;\n    }(G),\n        j = function (e) {\n      function DecadeParser() {\n        return p()(this, DecadeParser), N()(this, R()(DecadeParser).call(this, /^D(\\d+)$/));\n      }\n\n      return O()(DecadeParser, e), v()(DecadeParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = function year(e) {\n            return 10 * e;\n          };\n\n          return [dateFields({\n            year: n(r)\n          }), dateFields({\n            year: n(r + 1)\n          })];\n        }\n      }]), DecadeParser;\n    }(G),\n        W = function (e) {\n      function SemesterParser() {\n        return p()(this, SemesterParser), N()(this, R()(SemesterParser).call(this, /^(\\d\\d\\d\\d)S(\\d)$/));\n      }\n\n      return O()(SemesterParser, e), v()(SemesterParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = Number(t[2]),\n              a = function month(e) {\n            return 6 * (e - 1) + 1;\n          };\n\n          return [dateFields({\n            year: r,\n            month: a(n)\n          }), dateFields({\n            year: r,\n            month: a(n + 1)\n          })];\n        }\n      }]), SemesterParser;\n    }(G),\n        H = function (e) {\n      function TrimesterParser() {\n        return p()(this, TrimesterParser), N()(this, R()(TrimesterParser).call(this, /^(\\d\\d\\d\\d)t(\\d)$/));\n      }\n\n      return O()(TrimesterParser, e), v()(TrimesterParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = Number(t[2]),\n              a = function month(e) {\n            return 4 * (e - 1) + 1;\n          };\n\n          return [dateFields({\n            year: r,\n            month: a(n)\n          }), dateFields({\n            year: r,\n            month: a(n + 1)\n          })];\n        }\n      }]), TrimesterParser;\n    }(G),\n        Y = function (e) {\n      function QuarterParser() {\n        return p()(this, QuarterParser), N()(this, R()(QuarterParser).call(this, /^(\\d\\d\\d\\d)\\-?Q(\\d)$/));\n      }\n\n      return O()(QuarterParser, e), v()(QuarterParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = Number(t[2]),\n              a = function month(e) {\n            return 3 * (e - 1) + 1;\n          };\n\n          return [dateFields({\n            year: r,\n            month: a(n)\n          }), dateFields({\n            year: r,\n            month: a(n + 1)\n          })];\n        }\n      }]), QuarterParser;\n    }(G);\n\n    function startOfIsoWeek(e, t) {\n      var r = function parseISO_isoDow(e, t, r) {\n        var n = new Date(e, t - 1, r).getDay();\n        return 0 === n ? 7 : n;\n      }(e, 1, 1);\n\n      return function addDays(e, t) {\n        var r = new Date(e.valueOf());\n        return r.setDate(r.getDate() + t), r;\n      }(new Date(e, 0, r > 4 ? 9 - r : 2 - r), 7 * (t - 1));\n    }\n\n    var Z = function (e) {\n      function WeekParser() {\n        return p()(this, WeekParser), N()(this, R()(WeekParser).call(this, /^(\\d\\d\\d\\d)\\-?W(\\d\\d)$/));\n      }\n\n      return O()(WeekParser, e), v()(WeekParser, [{\n        key: \"parse\",\n        value: function parse(e) {\n          var t = this.check(e),\n              r = Number(t[1]),\n              n = Number(t[2]),\n              a = startOfIsoWeek(r, n),\n              i = startOfIsoWeek(r, n + 1),\n              o = function fields(e) {\n            return {\n              year: e.getFullYear(),\n              month: e.getMonth() + 1,\n              day: e.getDate()\n            };\n          };\n\n          return [dateFields(o(a)), dateFields(o(i))];\n        }\n      }]), WeekParser;\n    }(G),\n        X = [new z(), new q(), new j(), new W(), new H(), new Y(), new Z(), new U()];\n\n    function parseISO(e) {\n      var t = function findParser(e) {\n        return X.find(function (t) {\n          return t.check(e);\n        });\n      }(e = e || \"\");\n\n      if (!t) throw new V(\"No date parser found for \".concat(e));\n      return t.parse(e);\n    }\n\n    var Q = function () {\n      function TimeZoneDate(e, t) {\n        p()(this, TimeZoneDate), this._value = e, this._date = msToDate(e), this._timeZone = t;\n      }\n\n      return v()(TimeZoneDate, [{\n        key: \"year\",\n        get: function get() {\n          return this._date.getUTCFullYear();\n        }\n      }, {\n        key: \"month\",\n        get: function get() {\n          return this._date.getUTCMonth() + 1;\n        }\n      }, {\n        key: \"day\",\n        get: function get() {\n          return this._date.getUTCDate();\n        }\n      }, {\n        key: \"hour\",\n        get: function get() {\n          return this._date.getUTCHours();\n        }\n      }, {\n        key: \"minute\",\n        get: function get() {\n          return this._date.getUTCMinutes();\n        }\n      }, {\n        key: \"second\",\n        get: function get() {\n          return this._date.getUTCSeconds();\n        }\n      }, {\n        key: \"text\",\n        get: function get() {\n          return periodISO(this._date.getTime(), this._date.getTime() + 1e3);\n        }\n      }, {\n        key: \"timeZone\",\n        get: function get() {\n          return this._timeZone;\n        }\n      }], [{\n        key: \"fromValue\",\n        value: function fromValue(e, t) {\n          return new TimeZoneDate(e, t);\n        }\n      }, {\n        key: \"from\",\n        value: function from(e, t, r, n, a, i, o) {\n          return this.fromValue(Date.UTC(e, (t || 1) - 1, r, n, a, i), o);\n        }\n      }]), TimeZoneDate;\n    }(),\n        $ = function () {\n      function TimeRange(e, t, r, n) {\n        if (p()(this, TimeRange), this._startValue = r, this._endValue = n, r && n) this._iso = periodISO(r, n);else if (!r && !n && t) {\n          var a = function _startEndTimeValues(e) {\n            return parseISO(e).map(_timeValue);\n          }(t);\n\n          this._iso = t, this._startValue = a[0], this._endValue = a[1];\n        }\n        this._timeZone = e;\n      }\n\n      return v()(TimeRange, [{\n        key: \"timeZone\",\n        get: function get() {\n          return this._timeZone;\n        }\n      }, {\n        key: \"iso\",\n        get: function get() {\n          return this._iso;\n        }\n      }, {\n        key: \"startValue\",\n        get: function get() {\n          return this._startValue;\n        }\n      }, {\n        key: \"endValue\",\n        get: function get() {\n          return this._endValue;\n        }\n      }, {\n        key: \"startDate\",\n        get: function get() {\n          return Q.fromValue(this._startValue, this._timeZone);\n        }\n      }, {\n        key: \"endDate\",\n        get: function get() {\n          return Q.fromValue(this._endValue, this._timeZone);\n        }\n      }]), TimeRange;\n    }();\n\n    function _timeValue(e) {\n      return Date.UTC(e.year, e.month - 1, e.day, e.hour, e.minute, e.second);\n    }\n\n    var J = 1e-6,\n        K = \"undefined\" != typeof Float32Array ? Float32Array : Array,\n        ee = Math.random;\n    Math.PI;\n\n    function create() {\n      var e = new K(16);\n      return K != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e;\n    }\n\n    function clone(e) {\n      var t = new K(16);\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }\n\n    function mat4_copy(e, t) {\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }\n\n    function fromValues(e, t, r, n, a, i, o, u, s, c, l, f, h, d, p, m) {\n      var v = new K(16);\n      return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = a, v[5] = i, v[6] = o, v[7] = u, v[8] = s, v[9] = c, v[10] = l, v[11] = f, v[12] = h, v[13] = d, v[14] = p, v[15] = m, v;\n    }\n\n    function mat4_set(e, t, r, n, a, i, o, u, s, c, l, f, h, d, p, m, v) {\n      return e[0] = t, e[1] = r, e[2] = n, e[3] = a, e[4] = i, e[5] = o, e[6] = u, e[7] = s, e[8] = c, e[9] = l, e[10] = f, e[11] = h, e[12] = d, e[13] = p, e[14] = m, e[15] = v, e;\n    }\n\n    function identity(e) {\n      return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n    }\n\n    function transpose(e, t) {\n      if (e === t) {\n        var r = t[1],\n            n = t[2],\n            a = t[3],\n            i = t[6],\n            o = t[7],\n            u = t[11];\n        e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = i, e[11] = t[14], e[12] = a, e[13] = o, e[14] = u;\n      } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];\n\n      return e;\n    }\n\n    function invert(e, t) {\n      var r = t[0],\n          n = t[1],\n          a = t[2],\n          i = t[3],\n          o = t[4],\n          u = t[5],\n          s = t[6],\n          c = t[7],\n          l = t[8],\n          f = t[9],\n          h = t[10],\n          d = t[11],\n          p = t[12],\n          m = t[13],\n          v = t[14],\n          y = t[15],\n          g = r * u - n * o,\n          _ = r * s - a * o,\n          b = r * c - i * o,\n          x = n * s - a * u,\n          k = n * c - i * u,\n          T = a * c - i * s,\n          w = l * m - f * p,\n          C = l * v - h * p,\n          E = l * y - d * p,\n          M = f * v - h * m,\n          A = f * y - d * m,\n          S = h * y - d * v,\n          P = g * S - _ * A + b * M + x * E - k * C + T * w;\n\n      return P ? (P = 1 / P, e[0] = (u * S - s * A + c * M) * P, e[1] = (a * A - n * S - i * M) * P, e[2] = (m * T - v * k + y * x) * P, e[3] = (h * k - f * T - d * x) * P, e[4] = (s * E - o * S - c * C) * P, e[5] = (r * S - a * E + i * C) * P, e[6] = (v * b - p * T - y * _) * P, e[7] = (l * T - h * b + d * _) * P, e[8] = (o * A - u * E + c * w) * P, e[9] = (n * E - r * A - i * w) * P, e[10] = (p * k - m * b + y * g) * P, e[11] = (f * b - l * k - d * g) * P, e[12] = (u * C - o * M - s * w) * P, e[13] = (r * M - n * C + a * w) * P, e[14] = (m * _ - p * x - v * g) * P, e[15] = (l * x - f * _ + h * g) * P, e) : null;\n    }\n\n    function adjoint(e, t) {\n      var r = t[0],\n          n = t[1],\n          a = t[2],\n          i = t[3],\n          o = t[4],\n          u = t[5],\n          s = t[6],\n          c = t[7],\n          l = t[8],\n          f = t[9],\n          h = t[10],\n          d = t[11],\n          p = t[12],\n          m = t[13],\n          v = t[14],\n          y = t[15];\n      return e[0] = u * (h * y - d * v) - f * (s * y - c * v) + m * (s * d - c * h), e[1] = -(n * (h * y - d * v) - f * (a * y - i * v) + m * (a * d - i * h)), e[2] = n * (s * y - c * v) - u * (a * y - i * v) + m * (a * c - i * s), e[3] = -(n * (s * d - c * h) - u * (a * d - i * h) + f * (a * c - i * s)), e[4] = -(o * (h * y - d * v) - l * (s * y - c * v) + p * (s * d - c * h)), e[5] = r * (h * y - d * v) - l * (a * y - i * v) + p * (a * d - i * h), e[6] = -(r * (s * y - c * v) - o * (a * y - i * v) + p * (a * c - i * s)), e[7] = r * (s * d - c * h) - o * (a * d - i * h) + l * (a * c - i * s), e[8] = o * (f * y - d * m) - l * (u * y - c * m) + p * (u * d - c * f), e[9] = -(r * (f * y - d * m) - l * (n * y - i * m) + p * (n * d - i * f)), e[10] = r * (u * y - c * m) - o * (n * y - i * m) + p * (n * c - i * u), e[11] = -(r * (u * d - c * f) - o * (n * d - i * f) + l * (n * c - i * u)), e[12] = -(o * (f * v - h * m) - l * (u * v - s * m) + p * (u * h - s * f)), e[13] = r * (f * v - h * m) - l * (n * v - a * m) + p * (n * h - a * f), e[14] = -(r * (u * v - s * m) - o * (n * v - a * m) + p * (n * s - a * u)), e[15] = r * (u * h - s * f) - o * (n * h - a * f) + l * (n * s - a * u), e;\n    }\n\n    function determinant(e) {\n      var t = e[0],\n          r = e[1],\n          n = e[2],\n          a = e[3],\n          i = e[4],\n          o = e[5],\n          u = e[6],\n          s = e[7],\n          c = e[8],\n          l = e[9],\n          f = e[10],\n          h = e[11],\n          d = e[12],\n          p = e[13],\n          m = e[14],\n          v = e[15];\n      return (t * o - r * i) * (f * v - h * m) - (t * u - n * i) * (l * v - h * p) + (t * s - a * i) * (l * m - f * p) + (r * u - n * o) * (c * v - h * d) - (r * s - a * o) * (c * m - f * d) + (n * s - a * u) * (c * p - l * d);\n    }\n\n    function multiply(e, t, r) {\n      var n = t[0],\n          a = t[1],\n          i = t[2],\n          o = t[3],\n          u = t[4],\n          s = t[5],\n          c = t[6],\n          l = t[7],\n          f = t[8],\n          h = t[9],\n          d = t[10],\n          p = t[11],\n          m = t[12],\n          v = t[13],\n          y = t[14],\n          g = t[15],\n          _ = r[0],\n          b = r[1],\n          x = r[2],\n          k = r[3];\n      return e[0] = _ * n + b * u + x * f + k * m, e[1] = _ * a + b * s + x * h + k * v, e[2] = _ * i + b * c + x * d + k * y, e[3] = _ * o + b * l + x * p + k * g, _ = r[4], b = r[5], x = r[6], k = r[7], e[4] = _ * n + b * u + x * f + k * m, e[5] = _ * a + b * s + x * h + k * v, e[6] = _ * i + b * c + x * d + k * y, e[7] = _ * o + b * l + x * p + k * g, _ = r[8], b = r[9], x = r[10], k = r[11], e[8] = _ * n + b * u + x * f + k * m, e[9] = _ * a + b * s + x * h + k * v, e[10] = _ * i + b * c + x * d + k * y, e[11] = _ * o + b * l + x * p + k * g, _ = r[12], b = r[13], x = r[14], k = r[15], e[12] = _ * n + b * u + x * f + k * m, e[13] = _ * a + b * s + x * h + k * v, e[14] = _ * i + b * c + x * d + k * y, e[15] = _ * o + b * l + x * p + k * g, e;\n    }\n\n    function mat4_translate(e, t, r) {\n      var n = r[0],\n          a = r[1],\n          i = r[2],\n          o = void 0,\n          u = void 0,\n          s = void 0,\n          c = void 0,\n          l = void 0,\n          f = void 0,\n          h = void 0,\n          d = void 0,\n          p = void 0,\n          m = void 0,\n          v = void 0,\n          y = void 0;\n      return t === e ? (e[12] = t[0] * n + t[4] * a + t[8] * i + t[12], e[13] = t[1] * n + t[5] * a + t[9] * i + t[13], e[14] = t[2] * n + t[6] * a + t[10] * i + t[14], e[15] = t[3] * n + t[7] * a + t[11] * i + t[15]) : (o = t[0], u = t[1], s = t[2], c = t[3], l = t[4], f = t[5], h = t[6], d = t[7], p = t[8], m = t[9], v = t[10], y = t[11], e[0] = o, e[1] = u, e[2] = s, e[3] = c, e[4] = l, e[5] = f, e[6] = h, e[7] = d, e[8] = p, e[9] = m, e[10] = v, e[11] = y, e[12] = o * n + l * a + p * i + t[12], e[13] = u * n + f * a + m * i + t[13], e[14] = s * n + h * a + v * i + t[14], e[15] = c * n + d * a + y * i + t[15]), e;\n    }\n\n    function mat4_scale(e, t, r) {\n      var n = r[0],\n          a = r[1],\n          i = r[2];\n      return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * a, e[5] = t[5] * a, e[6] = t[6] * a, e[7] = t[7] * a, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }\n\n    function mat4_rotate(e, t, r, n) {\n      var a,\n          i,\n          o,\n          u,\n          s,\n          c,\n          l,\n          f,\n          h,\n          d,\n          p,\n          m,\n          v,\n          y,\n          g,\n          _,\n          b,\n          x,\n          k,\n          T,\n          w,\n          C,\n          E,\n          M,\n          A = n[0],\n          S = n[1],\n          P = n[2],\n          I = Math.sqrt(A * A + S * S + P * P);\n\n      return I < J ? null : (A *= I = 1 / I, S *= I, P *= I, a = Math.sin(r), o = 1 - (i = Math.cos(r)), u = t[0], s = t[1], c = t[2], l = t[3], f = t[4], h = t[5], d = t[6], p = t[7], m = t[8], v = t[9], y = t[10], g = t[11], _ = A * A * o + i, b = S * A * o + P * a, x = P * A * o - S * a, k = A * S * o - P * a, T = S * S * o + i, w = P * S * o + A * a, C = A * P * o + S * a, E = S * P * o - A * a, M = P * P * o + i, e[0] = u * _ + f * b + m * x, e[1] = s * _ + h * b + v * x, e[2] = c * _ + d * b + y * x, e[3] = l * _ + p * b + g * x, e[4] = u * k + f * T + m * w, e[5] = s * k + h * T + v * w, e[6] = c * k + d * T + y * w, e[7] = l * k + p * T + g * w, e[8] = u * C + f * E + m * M, e[9] = s * C + h * E + v * M, e[10] = c * C + d * E + y * M, e[11] = l * C + p * E + g * M, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);\n    }\n\n    function rotateX(e, t, r) {\n      var n = Math.sin(r),\n          a = Math.cos(r),\n          i = t[4],\n          o = t[5],\n          u = t[6],\n          s = t[7],\n          c = t[8],\n          l = t[9],\n          f = t[10],\n          h = t[11];\n      return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * a + c * n, e[5] = o * a + l * n, e[6] = u * a + f * n, e[7] = s * a + h * n, e[8] = c * a - i * n, e[9] = l * a - o * n, e[10] = f * a - u * n, e[11] = h * a - s * n, e;\n    }\n\n    function rotateY(e, t, r) {\n      var n = Math.sin(r),\n          a = Math.cos(r),\n          i = t[0],\n          o = t[1],\n          u = t[2],\n          s = t[3],\n          c = t[8],\n          l = t[9],\n          f = t[10],\n          h = t[11];\n      return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * a - c * n, e[1] = o * a - l * n, e[2] = u * a - f * n, e[3] = s * a - h * n, e[8] = i * n + c * a, e[9] = o * n + l * a, e[10] = u * n + f * a, e[11] = s * n + h * a, e;\n    }\n\n    function rotateZ(e, t, r) {\n      var n = Math.sin(r),\n          a = Math.cos(r),\n          i = t[0],\n          o = t[1],\n          u = t[2],\n          s = t[3],\n          c = t[4],\n          l = t[5],\n          f = t[6],\n          h = t[7];\n      return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * a + c * n, e[1] = o * a + l * n, e[2] = u * a + f * n, e[3] = s * a + h * n, e[4] = c * a - i * n, e[5] = l * a - o * n, e[6] = f * a - u * n, e[7] = h * a - s * n, e;\n    }\n\n    function fromTranslation(e, t) {\n      return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;\n    }\n\n    function fromScaling(e, t) {\n      return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n    }\n\n    function fromRotation(e, t, r) {\n      var n,\n          a,\n          i,\n          o = r[0],\n          u = r[1],\n          s = r[2],\n          c = Math.sqrt(o * o + u * u + s * s);\n      return c < J ? null : (o *= c = 1 / c, u *= c, s *= c, n = Math.sin(t), i = 1 - (a = Math.cos(t)), e[0] = o * o * i + a, e[1] = u * o * i + s * n, e[2] = s * o * i - u * n, e[3] = 0, e[4] = o * u * i - s * n, e[5] = u * u * i + a, e[6] = s * u * i + o * n, e[7] = 0, e[8] = o * s * i + u * n, e[9] = u * s * i - o * n, e[10] = s * s * i + a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);\n    }\n\n    function fromXRotation(e, t) {\n      var r = Math.sin(t),\n          n = Math.cos(t);\n      return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n    }\n\n    function fromYRotation(e, t) {\n      var r = Math.sin(t),\n          n = Math.cos(t);\n      return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n    }\n\n    function fromZRotation(e, t) {\n      var r = Math.sin(t),\n          n = Math.cos(t);\n      return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n    }\n\n    function fromRotationTranslation(e, t, r) {\n      var n = t[0],\n          a = t[1],\n          i = t[2],\n          o = t[3],\n          u = n + n,\n          s = a + a,\n          c = i + i,\n          l = n * u,\n          f = n * s,\n          h = n * c,\n          d = a * s,\n          p = a * c,\n          m = i * c,\n          v = o * u,\n          y = o * s,\n          g = o * c;\n      return e[0] = 1 - (d + m), e[1] = f + g, e[2] = h - y, e[3] = 0, e[4] = f - g, e[5] = 1 - (l + m), e[6] = p + v, e[7] = 0, e[8] = h + y, e[9] = p - v, e[10] = 1 - (l + d), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;\n    }\n\n    function fromQuat2(e, t) {\n      var r = new K(3),\n          n = -t[0],\n          a = -t[1],\n          i = -t[2],\n          o = t[3],\n          u = t[4],\n          s = t[5],\n          c = t[6],\n          l = t[7],\n          f = n * n + a * a + i * i + o * o;\n      return f > 0 ? (r[0] = 2 * (u * o + l * n + s * i - c * a) / f, r[1] = 2 * (s * o + l * a + c * n - u * i) / f, r[2] = 2 * (c * o + l * i + u * a - s * n) / f) : (r[0] = 2 * (u * o + l * n + s * i - c * a), r[1] = 2 * (s * o + l * a + c * n - u * i), r[2] = 2 * (c * o + l * i + u * a - s * n)), fromRotationTranslation(e, t, r), e;\n    }\n\n    function getTranslation(e, t) {\n      return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;\n    }\n\n    function getScaling(e, t) {\n      var r = t[0],\n          n = t[1],\n          a = t[2],\n          i = t[4],\n          o = t[5],\n          u = t[6],\n          s = t[8],\n          c = t[9],\n          l = t[10];\n      return e[0] = Math.sqrt(r * r + n * n + a * a), e[1] = Math.sqrt(i * i + o * o + u * u), e[2] = Math.sqrt(s * s + c * c + l * l), e;\n    }\n\n    function getRotation(e, t) {\n      var r = t[0] + t[5] + t[10],\n          n = 0;\n      return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = .25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = .25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = .25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = .25 * n), e;\n    }\n\n    function fromRotationTranslationScale(e, t, r, n) {\n      var a = t[0],\n          i = t[1],\n          o = t[2],\n          u = t[3],\n          s = a + a,\n          c = i + i,\n          l = o + o,\n          f = a * s,\n          h = a * c,\n          d = a * l,\n          p = i * c,\n          m = i * l,\n          v = o * l,\n          y = u * s,\n          g = u * c,\n          _ = u * l,\n          b = n[0],\n          x = n[1],\n          k = n[2];\n\n      return e[0] = (1 - (p + v)) * b, e[1] = (h + _) * b, e[2] = (d - g) * b, e[3] = 0, e[4] = (h - _) * x, e[5] = (1 - (f + v)) * x, e[6] = (m + y) * x, e[7] = 0, e[8] = (d + g) * k, e[9] = (m - y) * k, e[10] = (1 - (f + p)) * k, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;\n    }\n\n    function fromRotationTranslationScaleOrigin(e, t, r, n, a) {\n      var i = t[0],\n          o = t[1],\n          u = t[2],\n          s = t[3],\n          c = i + i,\n          l = o + o,\n          f = u + u,\n          h = i * c,\n          d = i * l,\n          p = i * f,\n          m = o * l,\n          v = o * f,\n          y = u * f,\n          g = s * c,\n          _ = s * l,\n          b = s * f,\n          x = n[0],\n          k = n[1],\n          T = n[2],\n          w = a[0],\n          C = a[1],\n          E = a[2],\n          M = (1 - (m + y)) * x,\n          A = (d + b) * x,\n          S = (p - _) * x,\n          P = (d - b) * k,\n          I = (1 - (h + y)) * k,\n          N = (v + g) * k,\n          D = (p + _) * T,\n          R = (v - g) * T,\n          F = (1 - (h + m)) * T;\n\n      return e[0] = M, e[1] = A, e[2] = S, e[3] = 0, e[4] = P, e[5] = I, e[6] = N, e[7] = 0, e[8] = D, e[9] = R, e[10] = F, e[11] = 0, e[12] = r[0] + w - (M * w + P * C + D * E), e[13] = r[1] + C - (A * w + I * C + R * E), e[14] = r[2] + E - (S * w + N * C + F * E), e[15] = 1, e;\n    }\n\n    function fromQuat(e, t) {\n      var r = t[0],\n          n = t[1],\n          a = t[2],\n          i = t[3],\n          o = r + r,\n          u = n + n,\n          s = a + a,\n          c = r * o,\n          l = n * o,\n          f = n * u,\n          h = a * o,\n          d = a * u,\n          p = a * s,\n          m = i * o,\n          v = i * u,\n          y = i * s;\n      return e[0] = 1 - f - p, e[1] = l + y, e[2] = h - v, e[3] = 0, e[4] = l - y, e[5] = 1 - c - p, e[6] = d + m, e[7] = 0, e[8] = h + v, e[9] = d - m, e[10] = 1 - c - f, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n    }\n\n    function frustum(e, t, r, n, a, i, o) {\n      var u = 1 / (r - t),\n          s = 1 / (a - n),\n          c = 1 / (i - o);\n      return e[0] = 2 * i * u, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * i * s, e[6] = 0, e[7] = 0, e[8] = (r + t) * u, e[9] = (a + n) * s, e[10] = (o + i) * c, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * i * 2 * c, e[15] = 0, e;\n    }\n\n    function perspective(e, t, r, n, a) {\n      var i = 1 / Math.tan(t / 2),\n          o = void 0;\n      return e[0] = i / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, null != a && a !== 1 / 0 ? (o = 1 / (n - a), e[10] = (a + n) * o, e[14] = 2 * a * n * o) : (e[10] = -1, e[14] = -2 * n), e;\n    }\n\n    function perspectiveFromFieldOfView(e, t, r, n) {\n      var a = Math.tan(t.upDegrees * Math.PI / 180),\n          i = Math.tan(t.downDegrees * Math.PI / 180),\n          o = Math.tan(t.leftDegrees * Math.PI / 180),\n          u = Math.tan(t.rightDegrees * Math.PI / 180),\n          s = 2 / (o + u),\n          c = 2 / (a + i);\n      return e[0] = s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = c, e[6] = 0, e[7] = 0, e[8] = -(o - u) * s * .5, e[9] = (a - i) * c * .5, e[10] = n / (r - n), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = n * r / (r - n), e[15] = 0, e;\n    }\n\n    function ortho(e, t, r, n, a, i, o) {\n      var u = 1 / (t - r),\n          s = 1 / (n - a),\n          c = 1 / (i - o);\n      return e[0] = -2 * u, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * c, e[11] = 0, e[12] = (t + r) * u, e[13] = (a + n) * s, e[14] = (o + i) * c, e[15] = 1, e;\n    }\n\n    function lookAt(e, t, r, n) {\n      var a = void 0,\n          i = void 0,\n          o = void 0,\n          u = void 0,\n          s = void 0,\n          c = void 0,\n          l = void 0,\n          f = void 0,\n          h = void 0,\n          d = void 0,\n          p = t[0],\n          m = t[1],\n          v = t[2],\n          y = n[0],\n          g = n[1],\n          _ = n[2],\n          b = r[0],\n          x = r[1],\n          k = r[2];\n      return Math.abs(p - b) < J && Math.abs(m - x) < J && Math.abs(v - k) < J ? identity(e) : (l = p - b, f = m - x, h = v - k, a = g * (h *= d = 1 / Math.sqrt(l * l + f * f + h * h)) - _ * (f *= d), i = _ * (l *= d) - y * h, o = y * f - g * l, (d = Math.sqrt(a * a + i * i + o * o)) ? (a *= d = 1 / d, i *= d, o *= d) : (a = 0, i = 0, o = 0), u = f * o - h * i, s = h * a - l * o, c = l * i - f * a, (d = Math.sqrt(u * u + s * s + c * c)) ? (u *= d = 1 / d, s *= d, c *= d) : (u = 0, s = 0, c = 0), e[0] = a, e[1] = u, e[2] = l, e[3] = 0, e[4] = i, e[5] = s, e[6] = f, e[7] = 0, e[8] = o, e[9] = c, e[10] = h, e[11] = 0, e[12] = -(a * p + i * m + o * v), e[13] = -(u * p + s * m + c * v), e[14] = -(l * p + f * m + h * v), e[15] = 1, e);\n    }\n\n    function targetTo(e, t, r, n) {\n      var a = t[0],\n          i = t[1],\n          o = t[2],\n          u = n[0],\n          s = n[1],\n          c = n[2],\n          l = a - r[0],\n          f = i - r[1],\n          h = o - r[2],\n          d = l * l + f * f + h * h;\n      d > 0 && (l *= d = 1 / Math.sqrt(d), f *= d, h *= d);\n      var p = s * h - c * f,\n          m = c * l - u * h,\n          v = u * f - s * l;\n      return (d = p * p + m * m + v * v) > 0 && (p *= d = 1 / Math.sqrt(d), m *= d, v *= d), e[0] = p, e[1] = m, e[2] = v, e[3] = 0, e[4] = f * v - h * m, e[5] = h * p - l * v, e[6] = l * m - f * p, e[7] = 0, e[8] = l, e[9] = f, e[10] = h, e[11] = 0, e[12] = a, e[13] = i, e[14] = o, e[15] = 1, e;\n    }\n\n    function mat4_str(e) {\n      return \"mat4(\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \", \" + e[4] + \", \" + e[5] + \", \" + e[6] + \", \" + e[7] + \", \" + e[8] + \", \" + e[9] + \", \" + e[10] + \", \" + e[11] + \", \" + e[12] + \", \" + e[13] + \", \" + e[14] + \", \" + e[15] + \")\";\n    }\n\n    function frob(e) {\n      return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2) + Math.pow(e[2], 2) + Math.pow(e[3], 2) + Math.pow(e[4], 2) + Math.pow(e[5], 2) + Math.pow(e[6], 2) + Math.pow(e[7], 2) + Math.pow(e[8], 2) + Math.pow(e[9], 2) + Math.pow(e[10], 2) + Math.pow(e[11], 2) + Math.pow(e[12], 2) + Math.pow(e[13], 2) + Math.pow(e[14], 2) + Math.pow(e[15], 2));\n    }\n\n    function mat4_add(e, t, r) {\n      return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;\n    }\n\n    function subtract(e, t, r) {\n      return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;\n    }\n\n    function multiplyScalar(e, t, r) {\n      return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;\n    }\n\n    function multiplyScalarAndAdd(e, t, r, n) {\n      return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;\n    }\n\n    function exactEquals(e, t) {\n      return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];\n    }\n\n    function mat4_equals(e, t) {\n      var r = e[0],\n          n = e[1],\n          a = e[2],\n          i = e[3],\n          o = e[4],\n          u = e[5],\n          s = e[6],\n          c = e[7],\n          l = e[8],\n          f = e[9],\n          h = e[10],\n          d = e[11],\n          p = e[12],\n          m = e[13],\n          v = e[14],\n          y = e[15],\n          g = t[0],\n          _ = t[1],\n          b = t[2],\n          x = t[3],\n          k = t[4],\n          T = t[5],\n          w = t[6],\n          C = t[7],\n          E = t[8],\n          M = t[9],\n          A = t[10],\n          S = t[11],\n          P = t[12],\n          I = t[13],\n          N = t[14],\n          D = t[15];\n      return Math.abs(r - g) <= J * Math.max(1, Math.abs(r), Math.abs(g)) && Math.abs(n - _) <= J * Math.max(1, Math.abs(n), Math.abs(_)) && Math.abs(a - b) <= J * Math.max(1, Math.abs(a), Math.abs(b)) && Math.abs(i - x) <= J * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(o - k) <= J * Math.max(1, Math.abs(o), Math.abs(k)) && Math.abs(u - T) <= J * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(s - w) <= J * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(c - C) <= J * Math.max(1, Math.abs(c), Math.abs(C)) && Math.abs(l - E) <= J * Math.max(1, Math.abs(l), Math.abs(E)) && Math.abs(f - M) <= J * Math.max(1, Math.abs(f), Math.abs(M)) && Math.abs(h - A) <= J * Math.max(1, Math.abs(h), Math.abs(A)) && Math.abs(d - S) <= J * Math.max(1, Math.abs(d), Math.abs(S)) && Math.abs(p - P) <= J * Math.max(1, Math.abs(p), Math.abs(P)) && Math.abs(m - I) <= J * Math.max(1, Math.abs(m), Math.abs(I)) && Math.abs(v - N) <= J * Math.max(1, Math.abs(v), Math.abs(N)) && Math.abs(y - D) <= J * Math.max(1, Math.abs(y), Math.abs(D));\n    }\n\n    var te = multiply,\n        re = subtract;\n\n    function vec4_create() {\n      var e = new K(4);\n      return K != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;\n    }\n\n    function vec4_clone(e) {\n      var t = new K(4);\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;\n    }\n\n    function vec4_fromValues(e, t, r, n) {\n      var a = new K(4);\n      return a[0] = e, a[1] = t, a[2] = r, a[3] = n, a;\n    }\n\n    function vec4_copy(e, t) {\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;\n    }\n\n    function vec4_set(e, t, r, n, a) {\n      return e[0] = t, e[1] = r, e[2] = n, e[3] = a, e;\n    }\n\n    function vec4_add(e, t, r) {\n      return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;\n    }\n\n    function vec4_subtract(e, t, r) {\n      return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;\n    }\n\n    function vec4_multiply(e, t, r) {\n      return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;\n    }\n\n    function divide(e, t, r) {\n      return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;\n    }\n\n    function vec4_ceil(e, t) {\n      return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;\n    }\n\n    function vec4_floor(e, t) {\n      return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;\n    }\n\n    function vec4_min(e, t, r) {\n      return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;\n    }\n\n    function vec4_max(e, t, r) {\n      return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;\n    }\n\n    function round(e, t) {\n      return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;\n    }\n\n    function vec4_scale(e, t, r) {\n      return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;\n    }\n\n    function scaleAndAdd(e, t, r, n) {\n      return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;\n    }\n\n    function distance(e, t) {\n      var r = t[0] - e[0],\n          n = t[1] - e[1],\n          a = t[2] - e[2],\n          i = t[3] - e[3];\n      return Math.sqrt(r * r + n * n + a * a + i * i);\n    }\n\n    function squaredDistance(e, t) {\n      var r = t[0] - e[0],\n          n = t[1] - e[1],\n          a = t[2] - e[2],\n          i = t[3] - e[3];\n      return r * r + n * n + a * a + i * i;\n    }\n\n    function vec4_length(e) {\n      var t = e[0],\n          r = e[1],\n          n = e[2],\n          a = e[3];\n      return Math.sqrt(t * t + r * r + n * n + a * a);\n    }\n\n    function squaredLength(e) {\n      var t = e[0],\n          r = e[1],\n          n = e[2],\n          a = e[3];\n      return t * t + r * r + n * n + a * a;\n    }\n\n    function negate(e, t) {\n      return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;\n    }\n\n    function inverse(e, t) {\n      return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;\n    }\n\n    function vec4_normalize(e, t) {\n      var r = t[0],\n          n = t[1],\n          a = t[2],\n          i = t[3],\n          o = r * r + n * n + a * a + i * i;\n      return o > 0 && (o = 1 / Math.sqrt(o), e[0] = r * o, e[1] = n * o, e[2] = a * o, e[3] = i * o), e;\n    }\n\n    function dot(e, t) {\n      return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];\n    }\n\n    function lerp(e, t, r, n) {\n      var a = t[0],\n          i = t[1],\n          o = t[2],\n          u = t[3];\n      return e[0] = a + n * (r[0] - a), e[1] = i + n * (r[1] - i), e[2] = o + n * (r[2] - o), e[3] = u + n * (r[3] - u), e;\n    }\n\n    function random(e, t) {\n      var r, n, a, i, o, u;\n      t = t || 1;\n\n      do {\n        o = (r = 2 * ee() - 1) * r + (n = 2 * ee() - 1) * n;\n      } while (o >= 1);\n\n      do {\n        u = (a = 2 * ee() - 1) * a + (i = 2 * ee() - 1) * i;\n      } while (u >= 1);\n\n      var s = Math.sqrt((1 - o) / u);\n      return e[0] = t * r, e[1] = t * n, e[2] = t * a * s, e[3] = t * i * s, e;\n    }\n\n    function transformMat4(e, t, r) {\n      var n = t[0],\n          a = t[1],\n          i = t[2],\n          o = t[3];\n      return e[0] = r[0] * n + r[4] * a + r[8] * i + r[12] * o, e[1] = r[1] * n + r[5] * a + r[9] * i + r[13] * o, e[2] = r[2] * n + r[6] * a + r[10] * i + r[14] * o, e[3] = r[3] * n + r[7] * a + r[11] * i + r[15] * o, e;\n    }\n\n    function transformQuat(e, t, r) {\n      var n = t[0],\n          a = t[1],\n          i = t[2],\n          o = r[0],\n          u = r[1],\n          s = r[2],\n          c = r[3],\n          l = c * n + u * i - s * a,\n          f = c * a + s * n - o * i,\n          h = c * i + o * a - u * n,\n          d = -o * n - u * a - s * i;\n      return e[0] = l * c + d * -o + f * -s - h * -u, e[1] = f * c + d * -u + h * -o - l * -s, e[2] = h * c + d * -s + l * -u - f * -o, e[3] = t[3], e;\n    }\n\n    function vec4_str(e) {\n      return \"vec4(\" + e[0] + \", \" + e[1] + \", \" + e[2] + \", \" + e[3] + \")\";\n    }\n\n    function vec4_exactEquals(e, t) {\n      return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];\n    }\n\n    function vec4_equals(e, t) {\n      var r = e[0],\n          n = e[1],\n          a = e[2],\n          i = e[3],\n          o = t[0],\n          u = t[1],\n          s = t[2],\n          c = t[3];\n      return Math.abs(r - o) <= J * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= J * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(a - s) <= J * Math.max(1, Math.abs(a), Math.abs(s)) && Math.abs(i - c) <= J * Math.max(1, Math.abs(i), Math.abs(c));\n    }\n\n    var ne = vec4_subtract,\n        ae = vec4_multiply,\n        ie = divide,\n        oe = distance,\n        ue = squaredDistance,\n        se = vec4_length,\n        ce = squaredLength,\n        le = function () {\n      var e = vec4_create();\n      return function (t, r, n, a, i, o) {\n        var u = void 0,\n            s = void 0;\n\n        for (r || (r = 4), n || (n = 0), s = a ? Math.min(a * r + n, t.length) : t.length, u = n; u < s; u += r) e[0] = t[u], e[1] = t[u + 1], e[2] = t[u + 2], e[3] = t[u + 3], i(e, e, o), t[u] = e[0], t[u + 1] = e[1], t[u + 2] = e[2], t[u + 3] = e[3];\n\n        return t;\n      };\n    }(),\n        fe = function average(e) {\n      for (var t = 0, r = 0; r < e.length; r++) t += e[r];\n\n      return t / e.length;\n    },\n        he = function (e) {\n      function CartoValidationError(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : de.DEFAULT;\n        return p()(this, CartoValidationError), (t = N()(this, R()(CartoValidationError).call(this, {\n          message: e,\n          type: r\n        }))).name = \"CartoValidationError\", t;\n      }\n\n      return O()(CartoValidationError, e), CartoValidationError;\n    }(B),\n        de = {\n      DEFAULT: \"[Error]\",\n      MISSING_REQUIRED: \"[Missing required property]\",\n      INCORRECT_TYPE: \"[Property with an incorrect type]\",\n      INCORRECT_VALUE: \"[Incorrect value]\",\n      TOO_MANY_ARGS: \"[Too many arguments]\",\n      NOT_ENOUGH_ARGS: \"[Not enough arguments]\",\n      WRONG_NUMBER_ARGS: \"[Wrong number of arguments]\"\n    },\n        pe = {\n      UNKNOWN: \"unknown\",\n      POINT: \"point\",\n      LINE: \"line\",\n      POLYGON: \"polygon\"\n    };\n\n    function getLineNormal(e, t) {\n      var r = function geometry_normalize(e, t) {\n        var r = Math.hypot(e, t);\n        return [e / r, t / r];\n      }(e[0] - t[0], e[1] - t[1]);\n\n      return [-r[1], r[0]];\n    }\n\n    function getJoinNormal(e, t) {\n      var r = [e[1], -e[0]],\n          n = [-t[1], t[0]],\n          a = n[0] * r[1] - n[1] * r[0],\n          i = n[0] * r[0] + n[1] * r[1],\n          o = Math.abs(a);\n      return {\n        turnLeft: a > 0,\n        joinNormal: !(o < .866 && i > .5) && neg([(r[0] + n[0]) / o, (r[1] + n[1]) / o])\n      };\n    }\n\n    function neg(e) {\n      return [-e[0], -e[1]];\n    }\n\n    function pointInTriangle(e, t, r, n) {\n      if (equalPoints(t, r) || equalPoints(r, n) || equalPoints(n, t)) return !1;\n      var a = halfPlaneSign(e, t, r) < 0,\n          i = halfPlaneSign(e, r, n) < 0,\n          o = halfPlaneSign(e, n, t) < 0;\n      return a === i && i === o;\n    }\n\n    function halfPlaneSign(e, t, r) {\n      return (e.x - r.x) * (t.y - r.y) - (t.x - r.x) * (e.y - r.y);\n    }\n\n    function equalPoints(e, t) {\n      return e.x === t.x && e.y === t.y;\n    }\n\n    function pointInCircle(e, t, r) {\n      var n = e.x - t.x,\n          a = e.y - t.y;\n      return n * n + a * a <= r * r;\n    }\n\n    function computeCentroids(e, t) {\n      switch (t) {\n        case pe.POINT:\n          return function _computeCentroidsForPoints(e) {\n            for (var t = [], r = 0; r < e.vertices.length / 6; r++) {\n              var n = 6 * r,\n                  a = n + 6,\n                  i = e.vertices.slice(n, a),\n                  o = g()(i, 6),\n                  u = o[4],\n                  s = o[5];\n              t.push({\n                x: u,\n                y: s\n              });\n            }\n\n            return t;\n          }(e);\n\n        case pe.LINE:\n        case pe.POLYGON:\n          return function _computeCentroidsForLinesOrPolygons(e, t) {\n            var r = [],\n                n = 0;\n            return e.breakpoints.forEach(function (a) {\n              var i = e.vertices.slice(n, a),\n                  o = null;\n              o = t === pe.LINE ? function _centroidForLines(e) {\n                for (var t = [], r = [], n = 0; n < e.length / 6; n++) {\n                  var a = 6 * n,\n                      i = a + 6,\n                      o = e.slice(a, i),\n                      u = g()(o, 6),\n                      s = u[0],\n                      c = u[1],\n                      l = u[2],\n                      f = u[3],\n                      h = u[4],\n                      d = u[5],\n                      p = s === l && c === f,\n                      m = l === h && f === d;\n\n                  if (!p || !m) {\n                    var v = [s, c],\n                        y = p ? [h, d] : [l, f];\n                    t.push(v[0]), t.push(y[0]), r.push(v[1]), r.push(y[1]);\n                  }\n                }\n\n                return {\n                  x: fe(t),\n                  y: fe(r)\n                };\n              }(i) : function _centroidForPolygons(e) {\n                for (var t = [], r = [], n = [], a = 0; a < e.length / 6; a++) {\n                  var i = 6 * a,\n                      o = i + 6,\n                      u = e.slice(i, o),\n                      s = g()(u, 6),\n                      c = s[0],\n                      l = s[1],\n                      f = s[2],\n                      h = s[3],\n                      d = s[4],\n                      p = s[5],\n                      m = [[c, l], [f, h], [d, p]],\n                      v = triangleArea(m);\n\n                  if (v > 0) {\n                    var y = fe([c, f, d]),\n                        _ = fe([l, h, p]);\n\n                    t.push(y * v), r.push(_ * v), n.push(v);\n                  }\n                }\n\n                var b = _sumArray(n);\n\n                return {\n                  x: _sumArray(t) / b,\n                  y: _sumArray(r) / b\n                };\n              }(i), r.push(o), n = a;\n            }), r;\n          }(e, t);\n\n        default:\n          throw new he(\"Invalid type argument, decoded geometry must have a point, line or polygon type.\", de.INCORRECT_VALUE);\n      }\n    }\n\n    function _sumArray(e) {\n      return e.reduce(function (e, t) {\n        return e + t;\n      }, 0);\n    }\n\n    function triangleArea(e) {\n      var t = g()(e[0], 2),\n          r = t[0],\n          n = t[1],\n          a = g()(e[1], 2),\n          i = a[0],\n          o = a[1],\n          u = g()(e[2], 2),\n          s = u[0],\n          c = u[1];\n      return Math.abs((r - s) * (o - n) - (r - i) * (c - n)) / 2;\n    }\n\n    function _updateAABBForGeometry(e, t, r) {\n      switch (r) {\n        case pe.LINE:\n          return function _updateAABBLine(e, t) {\n            for (var r = e, n = e.length, a = 0; a < n; a += 2) t.minx = Math.min(t.minx, r[a + 0]), t.miny = Math.min(t.miny, r[a + 1]), t.maxx = Math.max(t.maxx, r[a + 0]), t.maxy = Math.max(t.maxy, r[a + 1]);\n\n            return t;\n          }(e, t);\n\n        case pe.POLYGON:\n          return function _updateAABBPolygon(e, t) {\n            for (var r = [e.flat, e.holes[0] || e.flat.length / 2], n = r[0], a = r[1], i = 0; i < a; i++) t.minx = Math.min(t.minx, n[2 * i + 0]), t.miny = Math.min(t.miny, n[2 * i + 1]), t.maxx = Math.max(t.maxx, n[2 * i + 0]), t.maxy = Math.max(t.maxy, n[2 * i + 1]);\n\n            return t;\n          }(e, t);\n      }\n    }\n\n    var me = Math.PI / 180,\n        ve = 6378137,\n        ye = ve * Math.PI;\n\n    function isUndefined(e) {\n      return void 0 === e;\n    }\n\n    function isString(e) {\n      return \"string\" == typeof e;\n    }\n\n    function isObject(e) {\n      var t = h()(e);\n      return null !== e && (\"object\" === t || \"function\" === t);\n    }\n\n    function castDate(e) {\n      if (e instanceof Date) return e;\n      if (\"number\" == typeof e) return msToDate(e);\n      if (isString(e)) return new Date(e);\n      throw new he(\"Invalid Date type\", de.INCORRECT_TYPE);\n    }\n\n    function msToDate(e) {\n      return new Date(e);\n    }\n\n    function isSetsEqual(e, t) {\n      return e.size === t.size && l()(e).every(function (e) {\n        return t.has(e);\n      });\n    }\n\n    function computeViewportFromCameraMatrix(e) {\n      var t = n.invert([], e),\n          r = [[-1, -1], [-1, 1], [1, -1], [1, 1]].map(function (e) {\n        return function unproject(e, t, r) {\n          var n = a.transformMat4([], [t, r, 1, 1], e)[2],\n              i = (n - a.transformMat4([], [t, r, 2, 1], e)[2]) / -1,\n              o = -(n - 1 * i) / i;\n          return a.transformMat4([], [t, r, o, 1], e).map(function (e, t, r) {\n            return e / r[3];\n          });\n        }.apply(void 0, [t].concat(l()(e)));\n      }).map(function (e) {\n        return e.map(function (e) {\n          return 2 * e - 1;\n        });\n      }),\n          i = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n          o = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n      r.forEach(function (e) {\n        i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), o[0] = Math.max(o[0], e[0]), o[1] = Math.max(o[1], e[1]);\n      }), i[1] = -i[1], o[1] = -o[1];\n      var u = i[1];\n      return i[1] = o[1], o[1] = u, i.concat(o);\n    }\n\n    var ge,\n        _e,\n        be = {\n      WM_R: ye,\n      WM_2R: 2 * ye,\n      isUndefined: isUndefined,\n      isString: isString,\n      isNumber: function isNumber(e) {\n        return \"number\" == typeof e;\n      },\n      isObject: isObject,\n      castDate: castDate,\n      isSetsEqual: isSetsEqual,\n      equalArrays: function equalArrays(e, t) {\n        if (e && t && e.length === t.length) {\n          for (var r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n\n          return !0;\n        }\n      },\n      projectToWebMercator: function projectToWebMercator(e) {\n        var t = e.lat * me;\n        return {\n          x: e.lng * me * ve,\n          y: Math.log(Math.tan(t / 2 + Math.PI / 4)) * ve\n        };\n      },\n      computeMatrixZoom: function computeMatrixZoom(e) {\n        return -2 * e[15] / e[5];\n      },\n      computeMatrixCenter: function computeMatrixCenter(e) {\n        return {\n          x: -(1 + 2 * e[12] / e[0]),\n          y: +(1 + 2 * e[13] / e[5])\n        };\n      },\n      computeViewportFromCameraMatrix: computeViewportFromCameraMatrix\n    };\n\n    function castTimeRange(e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n      return void 0 === e || function isTimeRange(e) {\n        return e instanceof $;\n      }(e) ? e && t ? util_timeRange({\n        iso: e._iso,\n        timeZone: t\n      }) : e : \"string\" == typeof e ? util_timeRange({\n        iso: e,\n        timeZone: t\n      }) : void 0;\n    }\n\n    function util_timeRange(e) {\n      var t = e.start,\n          r = e.end,\n          n = e.iso,\n          a = e.timeZone;\n      return new $(a, n, t, r);\n    }\n\n    function setDefaultAuth(e) {\n      checkAuth(e), ge = e;\n    }\n\n    function checkAuth(e) {\n      if (isUndefined(e)) throw new he(\"'auth'\", de.MISSING_REQUIRED);\n      if (!isObject(e)) throw new he(\"'auth' property must be an object.\", de.INCORRECT_TYPE);\n      e.username = isUndefined(e.username) ? e.user : e.username, function checkApiKey(e) {\n        if (isUndefined(e)) throw new he(\"'apiKey'\", de.MISSING_REQUIRED);\n        if (!isString(e)) throw new he(\"'apiKey' property must be a string.\", de.INCORRECT_TYPE);\n        if (\"\" === e) throw new he(\"'apiKey' property must be not empty.\", de.INCORRECT_VALUE);\n      }(e.apiKey), function checkUsername(e) {\n        if (isUndefined(e)) throw new he(\"'username'\", de.MISSING_REQUIRED);\n        if (!isString(e)) throw new he(\"'username' property must be a string.\", de.INCORRECT_TYPE);\n        if (\"\" === e) throw new he(\"'username' property must be not empty.\", de.INCORRECT_VALUE);\n      }(e.username);\n    }\n\n    function setDefaultConfig(e) {\n      checkConfig(e), _e = e;\n    }\n\n    function checkConfig(e) {\n      if (e) {\n        if (!isObject(e)) throw new he(\"'config' property must be an object.\", de.INCORRECT_TYPE);\n        !function _checkServerURL(e) {\n          if (!isString(e)) throw new he(\"'serverURL' property must be a string.\", de.INCORRECT_TYPE);\n        }(e.serverURL);\n      }\n    }\n\n    var xe = \"aggregated\",\n        ke = \"unaggregated\",\n        Te = \"unknown\",\n        we = {};\n\n    function union(e, t) {\n      var r = {};\n      return new Set(Object.keys(e).concat(Object.keys(t))).forEach(function (n) {\n        var a = e[n] || [],\n            i = t[n] || [],\n            o = l()(a).concat(l()(i));\n        r[n] = o;\n      }), r;\n    }\n\n    function schema_equals(e, t) {\n      return !(!e || !t) && JSON.stringify(simplify(e)) === JSON.stringify(simplify(t));\n    }\n\n    function simplify(e) {\n      var t = {};\n      return Object.keys(e).sort().forEach(function (r) {\n        var n = l()(new Set(e[r].map(function (e) {\n          return JSON.stringify(e);\n        })));\n        n.sort(), n = n.map(function (e) {\n          return JSON.parse(e);\n        }), t[r] = n;\n      }), t;\n    }\n\n    var Ce = {\n      aggColumn: function aggColumn(e, t) {\n        return \"\".concat(\"_cdb_agg_\").concat(t, \"_\").concat(e);\n      },\n      dimColumn: function dimColumn(e, t) {\n        return \"\".concat(\"_cdb_dim_\").concat(t, \"_\").concat(e);\n      }\n    },\n        Ee = {\n      column: Ce,\n      equals: schema_equals,\n      notEquals: function schema_notEquals(e, t) {\n        return !schema_equals(e, t);\n      },\n      union: union,\n      IDENTITY: we,\n      simplify: simplify\n    },\n        Me = function () {\n      function Cache() {\n        p()(this, Cache), this.caches = new WeakMap();\n      }\n\n      return v()(Cache, [{\n        key: \"get\",\n        value: function get(e, t) {\n          if (this.caches.has(e)) return this.caches.get(e)[t];\n        }\n      }, {\n        key: \"set\",\n        value: function set(e, t, r) {\n          if (this.caches.has(e)) {\n            this.caches.get(e)[t] = r;\n          } else {\n            var n = {};\n            n[t] = r, this.caches.set(e, n);\n          }\n        }\n      }, {\n        key: \"has\",\n        value: function has(e, t) {\n          return void 0 !== this.get(e, t);\n        }\n      }]), Cache;\n    }(),\n        Ae = function (e) {\n      function CartoRuntimeError(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Se.DEFAULT;\n        return p()(this, CartoRuntimeError), (t = N()(this, R()(CartoRuntimeError).call(this, {\n          message: e,\n          type: r\n        }))).name = \"CartoRuntimeError\", t;\n      }\n\n      return O()(CartoRuntimeError, e), CartoRuntimeError;\n    }(B),\n        Se = {\n      DEFAULT: \"[Error]\",\n      NOT_SUPPORTED: \"[Not supported]\",\n      WEB_GL: \"[WebGL]\",\n      MVT: \"[MVT]\"\n    },\n        Pe = 1,\n        Ie = new Me(),\n        Ne = new Me();\n\n    function compileProgram(e, t, r) {\n      var n = t + r;\n      if (Ne.has(e, n)) return Ne.get(e, n);\n      var a = {},\n          i = utils_compileShader(e, t, e.VERTEX_SHADER),\n          o = utils_compileShader(e, r, e.FRAGMENT_SHADER);\n      if (a.program = e.createProgram(), e.attachShader(a.program, i), e.attachShader(a.program, o), e.linkProgram(a.program), e.deleteShader(i), e.deleteShader(o), !e.getProgramParameter(a.program, e.LINK_STATUS)) throw new Ae(\"Unable to link the shader program: \".concat(e.getProgramInfoLog(a.program), \".\"), Se.WEB_GL);\n      return a.programID = Pe++, Ne.set(e, n, a), a;\n    }\n\n    function utils_compileShader(e, t, r) {\n      if (Ie.has(e, t)) return Ie.get(e, t);\n      var n = e.createShader(r);\n\n      if (e.shaderSource(n, t), e.compileShader(n), !e.getShaderParameter(n, e.COMPILE_STATUS)) {\n        var a = e.getShaderInfoLog(n);\n        throw e.deleteShader(n), new Ae(\"An error occurred compiling the shaders: \".concat(a, \"\\nSource:\\n\").concat(t), Se.WEB_GL);\n      }\n\n      return Ie.set(e, t, n), n;\n    }\n\n    var De = r(34),\n        Re = r.n(De),\n        Fe = r(33),\n        Oe = r.n(Fe),\n        Le = r(35),\n        Be = r.n(Le),\n        Ve = r(20),\n        Ge = r.n(Ve),\n        Ue = r(19),\n        ze = r.n(Ue),\n        qe = {\n      vertexShader: \"\".concat(ze.a),\n      fragmentShader: \"\".concat(Ge.a).replace(\"$style_inline\", \"$color_inline\").replace(\"$style_preface\", \"$color_preface\")\n    },\n        je = {\n      vertexShader: \"\".concat(ze.a),\n      fragmentShader: \"\".concat(Ge.a).replace(\"$style_inline\", \"vec4($filter_inline)\").replace(\"$style_preface\", \"$filter_preface\")\n    },\n        We = {\n      vertexShader: \"\".concat(ze.a),\n      fragmentShader: \"\".concat(Ge.a).replace(\"$style_inline\", \"vec4(encodeWidth($width_inline), vec2(0.))\").replace(\"$style_preface\", \"\".concat(Be.a))\n    },\n        He = r(37),\n        Ye = r.n(He),\n        Ze = r(36),\n        Xe = {\n      vertexShader: \"\".concat(r.n(Ze).a),\n      fragmentShader: \"\".concat(Ye.a)\n    },\n        Qe = {\n      styler: i,\n      symbolizer: o,\n      AABlender: function AntiAliasingShader(e) {\n        p()(this, AntiAliasingShader), Object.assign(this, compileProgram(e, Oe.a, Re.a)), this.vertexAttribute = e.getAttribLocation(this.program, \"vertex\"), this.readTU = e.getUniformLocation(this.program, \"aaTex\");\n      }\n    },\n        $e = function () {\n      function IDGenerator() {\n        p()(this, IDGenerator), this._ids = new Map();\n      }\n\n      return v()(IDGenerator, [{\n        key: \"getID\",\n        value: function getID(e) {\n          if (this._ids.has(e)) return this._ids.get(e);\n          var t = this._ids.size;\n          return this._ids.set(e, t), t;\n        }\n      }]), IDGenerator;\n    }();\n\n    function compileShader(e, t, r) {\n      var n = {},\n          a = function getPropertyAccessCode(e) {\n        return void 0 === n[e] && (n[e] = Object.keys(n).length), \"texture2D(propertyTex\".concat(n[e], \", abs(featureID)).a\");\n      },\n          i = {},\n          o = new $e();\n\n      Object.keys(r).forEach(function (e) {\n        var t = r[e];\n\n        t._setUID(o);\n\n        var n = t._applyToShaderSource(a);\n\n        i[e + \"_preface\"] = n.preface, i[e + \"_inline\"] = n.inline;\n      }), i.propertyPreface = Object.keys(n).map(function (e) {\n        return \"uniform sampler2D propertyTex\".concat(n[e], \";\");\n      }).join(\"\\n\");\n\n      var u = function createShaderFromTemplate(e, t, r) {\n        var n = t.vertexShader,\n            a = t.fragmentShader;\n        Object.keys(r).forEach(function (e) {\n          n = n.replace(\"$\" + e, r[e]), a = a.replace(\"$\" + e, r[e]);\n        });\n        var i = compileProgram(e, n, a);\n        return i.vertexPositionAttribute = e.getAttribLocation(i.program, \"vertexPosition\"), i.featureIdAttr = e.getAttribLocation(i.program, \"featureID\"), i.normalAttr = e.getAttribLocation(i.program, \"normal\"), i.colorTexture = e.getUniformLocation(i.program, \"colorTex\"), i.strokeColorTexture = e.getUniformLocation(i.program, \"strokeColorTex\"), i.strokeWidthTexture = e.getUniformLocation(i.program, \"strokeWidthTex\"), i.widthTexture = e.getUniformLocation(i.program, \"widthTex\"), i.orderMinWidth = e.getUniformLocation(i.program, \"orderMinWidth\"), i.orderMaxWidth = e.getUniformLocation(i.program, \"orderMaxWidth\"), i.filterTexture = e.getUniformLocation(i.program, \"filterTex\"), i.normalScale = e.getUniformLocation(i.program, \"normalScale\"), i.resolution = e.getUniformLocation(i.program, \"resolution\"), i.matrix = e.getUniformLocation(i.program, \"matrix\"), i;\n      }(e, t, i);\n\n      return Object.keys(n).map(function (t) {\n        n[t] = e.getUniformLocation(u.program, \"propertyTex\".concat(n[t]));\n      }), Object.values(r).forEach(function (t) {\n        t._postShaderCompile(u.program, e);\n      }), {\n        shader: u,\n        textureIds: n,\n        _codes: i,\n        _template: t\n      };\n    }\n\n    var Je = r(6),\n        Ke = r.n(Je),\n        et = r(8),\n        tt = r.n(et),\n        rt = r(11),\n        nt = r.n(rt);\n\n    function sRGBToCielab(e) {\n      return function XYZToCieLab(e) {\n        var t = e.x,\n            r = e.y,\n            n = e.z,\n            a = e.a,\n            i = at,\n            o = it,\n            u = ot,\n            s = function f(e) {\n          return e >= .008856451679035631 ? Math.pow(e, .333333333333333) : 841 / 108 * e + 4 / 29;\n        };\n\n        return {\n          l: 116 * s(r / o) - 16,\n          a: 500 * (s(t / i) - s(r / o)),\n          b: 200 * (s(r / o) - s(n / u)),\n          alpha: a\n        };\n      }(function sRGBToXYZ(e) {\n        var t = function sRGBToLinearRGB(e) {\n          var t = e.r,\n              r = e.g,\n              n = e.b,\n              a = e.a,\n              i = function inverseGammaCorrection(e) {\n            return e <= .0404482362771076 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);\n          };\n\n          return {\n            r: i(t),\n            g: i(r),\n            b: i(n),\n            a: a\n          };\n        }(e),\n            r = t.r,\n            n = t.g,\n            a = t.b,\n            i = t.a;\n\n        return {\n          x: .41239558896741424 * r + .3575834307637148 * n + .18049264738170157 * a,\n          y: .21258623078559555 * r + .7151703037034108 * n + .07220049864333623 * a,\n          z: .019297215491746945 * r + .11918386458084854 * n + .9504971251315798 * a,\n          a: i\n        };\n      }(e));\n    }\n\n    function cielabToSRGB(e) {\n      return function XYZToSRGB(e) {\n        var t = e.x,\n            r = e.y,\n            n = e.z,\n            a = e.a,\n            i = utils_clamp(3.2406 * t - 1.5372 * r - .4986 * n, 0, 1),\n            o = utils_clamp(-.9689 * t + 1.8758 * r + .0415 * n, 0, 1),\n            u = utils_clamp(.0557 * t - .204 * r + 1.057 * n, 0, 1);\n        return function linearRGBToSRGB(e) {\n          var t = e.r,\n              r = e.g,\n              n = e.b,\n              a = e.a,\n              i = function gammaCorrection(e) {\n            return e <= .0031306684425005883 ? 12.92 * e : 1.055 * Math.pow(e, .4166666666666667) - .055;\n          };\n\n          return {\n            r: i(t),\n            g: i(r),\n            b: i(n),\n            a: a\n          };\n        }({\n          r: i,\n          g: o,\n          b: u,\n          a: a\n        });\n      }(function cielabToXYZ(e) {\n        var t = e.l,\n            r = e.a,\n            n = e.b,\n            a = e.alpha,\n            i = function f(e) {\n          return e >= .20689655172413793 ? e * e * e : 108 / 841 * (e - 4 / 29);\n        };\n\n        return {\n          x: at * i((t + 16) / 116 + r / 500),\n          y: it * i((t + 16) / 116),\n          z: ot * i((t + 16) / 116 - n / 200),\n          a: a\n        };\n      }(e));\n    }\n\n    var at = .950456,\n        it = 1,\n        ot = 1.088754;\n\n    function checkMaxArguments(e, t, r) {\n      if (e.length > t) throw new he(\"Expression '\".concat(r, \"' accepts just \").concat(t, \" arguments, but \").concat(e.length, \" were passed.\"), de.TOO_MANY_ARGS);\n    }\n\n    function checkMinArguments(e, t, r) {\n      if (e.length < t) throw new he(\"Expression '\".concat(r, \"' accepts at least \").concat(t, \" arguments, but \").concat(e.length, \" were passed.\"), de.NOT_ENOUGH_ARGS);\n    }\n\n    function checkExactNumberOfArguments(e, t, r) {\n      if (e.length !== t) throw new he(\"Expression '\".concat(r, \"' accepts exactly \").concat(t, \" arguments, but \").concat(e.length, \" were passed.\"), de.WRONG_NUMBER_ARGS);\n    }\n\n    function implicitCast(e) {\n      return _isNumber(e) ? ba(e) : \"string\" == typeof e ? xa(e) : Array.isArray(e) ? ka(e) : e;\n    }\n\n    function hexToRgb(e) {\n      var t = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(e);\n      if (t) return {\n        r: parseInt(t[1] + t[1], 16),\n        g: parseInt(t[2] + t[2], 16),\n        b: parseInt(t[3] + t[3], 16),\n        a: 1\n      };\n      if (t = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(e)) return {\n        r: parseInt(t[1] + t[1], 16),\n        g: parseInt(t[2] + t[2], 16),\n        b: parseInt(t[3] + t[3], 16),\n        a: parseInt(t[4] + t[4], 16) / 255\n      };\n      if (t = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e)) return {\n        r: parseInt(t[1], 16),\n        g: parseInt(t[2], 16),\n        b: parseInt(t[3], 16),\n        a: 1\n      };\n      if (t = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e)) return {\n        r: parseInt(t[1], 16),\n        g: parseInt(t[2], 16),\n        b: parseInt(t[3], 16),\n        a: parseInt(t[4], 16) / 255\n      };\n      throw new V(\"Invalid hexadecimal color\");\n    }\n\n    function noOverrideColor() {\n      return wa(255, 255, 255, 0);\n    }\n\n    function getOrdinalFromIndex(e) {\n      return {\n        1: \"first\",\n        2: \"second\",\n        3: \"third\",\n        4: \"fourth\"\n      }[e] || String(e);\n    }\n\n    function getStringErrorPreface(e, t, r) {\n      return \"\".concat(e, \"(): invalid \").concat(getOrdinalFromIndex(r + 1), \" parameter '\").concat(t, \"'\");\n    }\n\n    function throwInvalidType(e, t, r, n, a) {\n      throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n        expected type was '\").concat(n, \"', actual type was '\").concat(a, \"'\"), de.INCORRECT_TYPE);\n    }\n\n    function throwInvalidInstance(e, t, r, n) {\n      var a = Array.isArray(n) ? n.join(\", \") : n.name;\n      throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n    expected type was instance of '\").concat(a, \"'\"), de.INCORRECT_TYPE);\n    }\n\n    function throwInvalidString(e, t, r, n) {\n      throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n    expected type was 'string', but \").concat(n, \"' is not a string\"), de.INCORRECT_TYPE);\n    }\n\n    function checkExpression(e, t, r, n) {\n      if (!(n instanceof ut)) throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n        '\").concat(n, '\\' is not of type \"carto.expressions.Base\"'), de.INCORRECT_TYPE);\n    }\n\n    function checkType(e, t, r, n, a) {\n      if (checkExpression(e, t, r, a), Array.isArray(n)) {\n        if (!n.some(function (e) {\n          return a.type === e;\n        })) throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n            expected type was one of \").concat(n.join(), \", actual type was '\").concat(a.type, \"'\"), de.INCORRECT_TYPE);\n      } else a.type !== n && throwInvalidType(e, t, r, n, a.type);\n    }\n\n    function checkInstance(e, t, r, n, a) {\n      (checkExpression(e, t, r, a), Array.isArray(n)) ? n.some(function (e) {\n        return a.isA(e);\n      }) || throwInvalidInstance(e, t, r, n) : a.isA(n) || throwInvalidInstance(e, t, r, n);\n    }\n\n    function checkNumber(e, t, r, n) {\n      _isNumber(n) || function throwInvalidNumber(e, t, r, n) {\n        throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n    type of '\").concat(n, \"' is \").concat(h()(n), \", 'number' was expected\"), de.INCORRECT_TYPE);\n      }(e, t, r, n);\n    }\n\n    function checkString(e, t, r, n) {\n      \"string\" != typeof n && throwInvalidString(e, t, r, n);\n    }\n\n    function checkStringValue(e, t, r, n, a) {\n      \"string\" != typeof n ? throwInvalidString(e, t, r, n) : a.includes(n) || function throwInvalidStringValue(e, t, r, n, a) {\n        throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n    value '\").concat(n, \"' is not valid. It should be one of \").concat(a.map(function (e) {\n          return \"'\".concat(e, \"'\");\n        }).join(\", \")), de.INCORRECT_TYPE);\n      }(e, t, r, n, a);\n    }\n\n    function checkArray(e, t, r, n) {\n      Array.isArray(n) || function throwInvalidArray(e, t, r, n) {\n        throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n    '\").concat(n, \"' is not an array\"), de.INCORRECT_TYPE);\n      }(e, t, r, n);\n    }\n\n    function checkFeatureIndependent(e, t, r, n) {\n      if (n.isFeatureDependent()) throw new he(\"\".concat(getStringErrorPreface(e, t, r), \"\\n        parameter cannot be feature dependent\"), de.INCORRECT_VALUE);\n    }\n\n    function utils_clamp(e, t, r) {\n      return Math.min(Math.max(e, t), r);\n    }\n\n    function utils_mix(e, t, r) {\n      return \"number\" == typeof e ? _mixNumber(e, t, r) : e instanceof Date ? function _mixDate(e, t, r) {\n        var n = e.getTime(),\n            a = t.getTime(),\n            i = Math.abs(_mixNumber(n, a, r));\n        return new Date(i);\n      }(e, t, r) : function interpolateRGBAinCieLAB(e, t, r) {\n        var n = sRGBToCielab({\n          r: e.r / 255,\n          g: e.g / 255,\n          b: e.b / 255,\n          a: e.a\n        }),\n            a = sRGBToCielab({\n          r: t.r / 255,\n          g: t.g / 255,\n          b: t.b / 255,\n          a: t.a\n        }),\n            i = cielabToSRGB({\n          l: (1 - r) * n.l + r * a.l,\n          a: (1 - r) * n.a + r * a.a,\n          b: (1 - r) * n.b + r * a.b,\n          alpha: (1 - r) * n.alpha + r * a.alpha\n        });\n        return {\n          r: Math.round(255 * i.r),\n          g: Math.round(255 * i.g),\n          b: Math.round(255 * i.b),\n          a: i.a\n        };\n      }(e, t, r);\n    }\n\n    function _mixNumber(e, t, r) {\n      return e * (1 - r) + t * r;\n    }\n\n    function _isNumber(e) {\n      return Number.isFinite(e) || e === 1 / 0 || e === -1 / 0 || Number.isNaN(e);\n    }\n\n    var ut = function () {\n      function Base(e) {\n        p()(this, Base), this._initializeChildren(e), this.preface = \"\", this._shaderBindings = new Map(), this.expressionName = function _toCamelCase(e) {\n          if (e.toUpperCase() === e) return e.toLowerCase();\n          return e.charAt(0).toLowerCase() + e.slice(1);\n        }(this.constructor.name), this._variableName = null;\n      }\n\n      return v()(Base, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"(\").concat(this._getChildren().map(function (e) {\n            return e.toString();\n          }).join(\", \"), \")\");\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return this._getChildren().some(function (e) {\n            return e.isAnimated();\n          });\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return this._getChildren().some(function (e) {\n            return e.isPlaying();\n          });\n        }\n      }, {\n        key: \"blendTo\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee(e) {\n            var t,\n                r,\n                n,\n                a = arguments;\n            return tt.a.wrap(function _callee$(i) {\n              for (;;) switch (i.prev = i.next) {\n                case 0:\n                  t = a.length > 1 && void 0 !== a[1] ? a[1] : 500, e = implicitCast(e), this.keepDefaultsOnBlend && this.keepDefaultsOnBlend(), r = this.parent, n = Xa(this, e, Ca(t)), r.replaceChild(this, n), n.notify();\n\n                case 7:\n                case \"end\":\n                  return i.stop();\n              }\n            }, _callee, this);\n          }));\n          return function blendTo(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"isA\",\n        value: function isA(e) {\n          return this instanceof e;\n        }\n      }, {\n        key: \"notify\",\n        value: function notify() {\n          return this.parent.notify();\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          this._getChildren().forEach(function (t) {\n            return t.accumViewportAgg(e);\n          });\n        }\n      }, {\n        key: \"loadImages\",\n        value: function loadImages() {\n          return Promise.all(this._getChildren().map(function (e) {\n            return e.loadImages();\n          }));\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          return {\n            name: this.propertyName,\n            data: []\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this._getChildren().forEach(function (t) {\n            return t._bindMetadata(e);\n          });\n        }\n      }, {\n        key: \"_initializeChildren\",\n        value: function _initializeChildren(e) {\n          Array.isArray(e) ? this._initializeChildrenArray(e) : this._initializeChildrenObject(e), this._addParentToChildren();\n        }\n      }, {\n        key: \"_initializeChildrenArray\",\n        value: function _initializeChildrenArray(e) {\n          var t = this;\n          if (this.maxParameters && this.maxParameters < e.length) throw new he(\"Extra parameters, got \".concat(e.length, \" but maximum is \").concat(this.maxParameters), de.TOO_MANY_ARGS);\n          this.childrenNames = [], e.map(function (e, r) {\n            var n = \"\".concat(e.type, \"-\").concat(r);\n            t.childrenNames.push(n), t[n] = implicitCast(e);\n          });\n        }\n      }, {\n        key: \"_initializeChildrenObject\",\n        value: function _initializeChildrenObject(e) {\n          var t,\n              r = this;\n          if (void 0 === this.childrenNames && (this.childrenNames = []), (t = this.childrenNames).push.apply(t, l()(Object.keys(e))), this.maxParameters && this.maxParameters < this.childrenNames.length) throw new he(de.TOO_MANY_ARGS, \"Extra parameters, got \".concat(this.childrenNames.length, \" but maximum is \").concat(this.maxParameters));\n          Object.keys(e).map(function (t) {\n            r[t] = implicitCast(e[t]);\n          });\n        }\n      }, {\n        key: \"_addParentToChildren\",\n        value: function _addParentToChildren() {\n          var e = this;\n\n          this._getChildren().map(function (t) {\n            t.parent = e;\n          });\n        }\n      }, {\n        key: \"_setUID\",\n        value: function _setUID(e) {\n          this._uid = e.getID(this), this._getChildren().map(function (t) {\n            return t._setUID(e);\n          });\n        }\n      }, {\n        key: \"_dataReady\",\n        value: function _dataReady() {\n          this._getChildren().map(function (e) {\n            return e._dataReady();\n          });\n        }\n      }, {\n        key: \"isFeatureDependent\",\n        value: function isFeatureDependent() {\n          return this._getChildren().some(function (e) {\n            return e.isFeatureDependent();\n          });\n        }\n      }, {\n        key: \"_prefaceCode\",\n        value: function _prefaceCode(e) {\n          return e ? \"\\n\".concat(this._buildGLSLCode(e), \"\\n\") : \"\";\n        }\n      }, {\n        key: \"_buildGLSLCode\",\n        value: function _buildGLSLCode(e) {\n          return \"\\n            #ifndef DEF_\".concat(this._uid, \"\\n            #define DEF_\").concat(this._uid, \"\\n            \").concat(e, \"\\n            #endif\");\n        }\n      }, {\n        key: \"_getDependencies\",\n        value: function _getDependencies() {\n          return this._getChildren().map(function (e) {\n            return e._getDependencies();\n          }).reduce(function (e, t) {\n            return e.concat(t);\n          }, []);\n        }\n      }, {\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          this._getChildren().map(function (t) {\n            return t._resolveAliases(e);\n          });\n        }\n      }, {\n        key: \"_setGenericGLSL\",\n        value: function _setGenericGLSL(e, t) {\n          this.inlineMaker = e, this.preface = t || \"\";\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this,\n              r = this.childrenNames.map(function (r) {\n            return t[r]._applyToShaderSource(e);\n          }),\n              n = {};\n          return r.map(function (e, r) {\n            n[t.childrenNames[r]] = e.inline;\n          }), {\n            preface: this._prefaceCode(r.map(function (e) {\n              return e.preface;\n            }).reduce(function (e, t) {\n              return e + t;\n            }, \"\") + this.preface),\n            inline: this.inlineMaker(n, e)\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          var r = this;\n          this.childrenNames.forEach(function (n) {\n            return r[n]._postShaderCompile(e, t);\n          });\n        }\n      }, {\n        key: \"_getBinding\",\n        value: function _getBinding(e) {\n          return this._shaderBindings.has(e) || this._shaderBindings.set(e, {}), this._shaderBindings.get(e);\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg(e) {\n          this._getChildren().forEach(function (t) {\n            return t._resetViewportAgg(e);\n          });\n        }\n      }, {\n        key: \"_setTimestamp\",\n        value: function _setTimestamp(e) {\n          var t = this;\n          this.childrenNames.forEach(function (r) {\n            return t[r]._setTimestamp(e);\n          });\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw() {\n          for (var e = this, t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];\n\n          this.childrenNames.forEach(function (t) {\n            var n;\n            return (n = e[t])._preDraw.apply(n, r);\n          });\n        }\n      }, {\n        key: \"replaceChild\",\n        value: function replaceChild(e, t) {\n          var r = this;\n          this[this.childrenNames.find(function (t) {\n            return r[t] === e;\n          })] = t, t.parent = this, t.notify = e.notify, t.notify().catch(function () {});\n        }\n      }, {\n        key: \"_blendFrom\",\n        value: function _blendFrom(e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500,\n              r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;\n\n          if (!this.default || !e.default) {\n            e = implicitCast(e);\n            var n = this.parent,\n                a = Xa(e, this, Ca(t), r);\n            n.replaceChild(this, a), a.notify();\n          }\n        }\n      }, {\n        key: \"_getChildren\",\n        value: function _getChildren() {\n          var e = this;\n          return this.childrenNames.map(function (t) {\n            return e[t];\n          });\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return this._getChildren().map(function (e) {\n            return e._getMinimumNeededSchema();\n          }).reduce(union, we);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          throw new Ae(\"Must evaluate a feature using .eval(feature)\");\n        }\n      }, {\n        key: \"values\",\n        get: function get() {\n          return this.getLegendData().data;\n        }\n      }, {\n        key: \"propertyName\",\n        get: function get() {\n          return this._getChildren().map(function (e) {\n            return e.propertyName;\n          }).find(function (e) {\n            return !!e;\n          });\n        }\n      }]), Base;\n    }();\n\n    var st = function (e) {\n      function Transition(e) {\n        var t;\n\n        if (p()(this, Transition), checkMaxArguments(arguments, 1, \"transition\"), checkNumber(\"transition\", \"duration\", 0, e), e < 0) {\n          var r = getStringErrorPreface(\"transition\", \"duration\", 0);\n          throw new he(\"\".concat(r, \" 'duration' must be greater than or equal to 0.\"), de.INCORRECT_VALUE);\n        }\n\n        return (t = N()(this, R()(Transition).call(this, {}))).aTime = Date.now(), t.bTime = t.aTime + Number(e), t.type = \"number\", t;\n      }\n\n      return O()(Transition, e), v()(Transition, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !this.mix || this.mix <= 1;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return this.isAnimated();\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource() {\n          return {\n            preface: this._prefaceCode(\"uniform float anim\".concat(this._uid, \";\\n\")),\n            inline: \"anim\".concat(this._uid)\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._getBinding(e).uniformLocation = t.getUniformLocation(e, \"anim\".concat(this._uid));\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          var n = Date.now();\n          this.mix = (n - this.aTime) / (this.bTime - this.aTime), this.mix > 1 ? r.uniform1f(this._getBinding(e).uniformLocation, 1) : r.uniform1f(this._getBinding(e).uniformLocation, this.mix);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          var e = Date.now();\n          return this.mix = (e - this.aTime) / (this.bTime - this.aTime), Math.min(this.mix, 1);\n        }\n      }]), Transition;\n    }(ut),\n        ct = r(5),\n        lt = r.n(ct),\n        ft = generateBelongsExpression(\"in\", function IN_INLINE_MAKER(e) {\n      if (!e || 0 === e.length) return function () {\n        return \"0.\";\n      };\n      return function (t) {\n        return \"((\".concat(e.map(function (e, r) {\n          return \"(\".concat(t.input, \" == \").concat(t.list[r], \")\");\n        }).join(\" || \"), \")? 1.: 0.)\");\n      };\n    }, function (e, t) {\n      return t.some(function (t) {\n        return t === e;\n      }) ? 1 : 0;\n    });\n\n    var ht = generateBelongsExpression(\"nin\", function NIN_INLINE_MAKER(e) {\n      if (0 === e.length) return function () {\n        return \"1.\";\n      };\n      return function (t) {\n        return \"((\".concat(e.map(function (e, r) {\n          return \"(\".concat(t.input, \" != \").concat(t.list[r], \")\");\n        }).join(\" && \"), \")? 1.: 0.)\");\n      };\n    }, function (e, t) {\n      return t.some(function (t) {\n        return t === e;\n      }) ? 0 : 1;\n    });\n\n    function generateBelongsExpression(e, t, r) {\n      return function (n) {\n        function BelongExpression(t, r) {\n          var n;\n          return p()(this, BelongExpression), checkMaxArguments(arguments, 2, e), t = implicitCast(t), r = implicitCast(r), checkExpression(e, \"input\", 0, t), checkExpression(e, [\"list\", \"variable\"], 1, r), (n = N()(this, R()(BelongExpression).call(this, {\n            input: t,\n            list: r\n          }))).type = \"number\", n;\n        }\n\n        return O()(BelongExpression, n), v()(BelongExpression, [{\n          key: \"eval\",\n          value: function _eval(e) {\n            return r(this.input.eval(e), this.list.eval(e));\n          }\n        }, {\n          key: \"_bindMetadata\",\n          value: function _bindMetadata(r) {\n            lt()(R()(BelongExpression.prototype), \"_bindMetadata\", this).call(this, r), checkType(e, \"input\", 0, \"category\", this.input), checkType(e, \"list\", 1, \"category-list\", this.list), this.inlineMaker = t(this.list.elems);\n          }\n        }, {\n          key: \"value\",\n          get: function get() {\n            return r(this.input.value, this.list.value);\n          }\n        }]), BelongExpression;\n      }(ut);\n    }\n\n    var dt = function (e) {\n      function Between(e, t, r) {\n        var n;\n        return p()(this, Between), checkMaxArguments(arguments, 3, \"between\"), e = implicitCast(e), t = implicitCast(t), r = implicitCast(r), (n = N()(this, R()(Between).call(this, {\n          input: e,\n          lowerLimit: t,\n          upperLimit: r\n        }))).type = \"number\", n.inlineMaker = function (e) {\n          return \"((\".concat(e.input, \" >= \").concat(e.lowerLimit, \" &&  \").concat(e.input, \" <= \").concat(e.upperLimit, \") ? 1. : 0.)\");\n        }, n;\n      }\n\n      return O()(Between, e), v()(Between, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.input.eval(e),\n              r = this.lowerLimit.eval(e),\n              n = this.upperLimit.eval(e);\n          return t >= r && t <= n ? 1 : 0;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Between.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"between\", \"input\", 0, [\"number\", \"date\"], this.input), checkType(\"between\", \"lowerLimit\", 1, [\"number\", \"date\"], this.lowerLimit), checkType(\"between\", \"upperLimit\", 2, [\"number\", \"date\"], this.upperLimit);\n        }\n      }]), Between;\n    }(ut),\n        pt = 0,\n        mt = 1,\n        vt = 2,\n        yt = 4,\n        gt = 8,\n        _t = 16,\n        bt = 32,\n        xt = {\n      0: null,\n      1: \"number\",\n      2: \"color\",\n      4: \"color\",\n      8: \"number\",\n      16: \"image\",\n      32: \"date\"\n    },\n        kt = function (e) {\n      function BinaryOperation(e, t, r, n) {\n        var a;\n        return p()(this, BinaryOperation), checkMaxArguments(arguments, 4), Number.isFinite(e) && Number.isFinite(t) ? N()(a, ba(r[mt](e, t))) : (e = implicitCast(e), t = implicitCast(t), (a = N()(this, R()(BinaryOperation).call(this, {\n          a: e,\n          b: t\n        }))).signatureMethods = r, a._signature = getSignature(e, t), a.glsl = n, a.allowedSignature = pt, a.type = xt[a._signature], a.inlineMaker = function (e) {\n          return n(e.a, e.b);\n        }, a);\n      }\n\n      return O()(BinaryOperation, e), v()(BinaryOperation, [{\n        key: \"eval\",\n        value: function _eval() {\n          if (Number.isFinite(this.a) && Number.isFinite(this.b)) return this.operation(this.a.value, this.b.value);\n\n          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n          if (Number.isFinite(this.a)) return this.operation(this.a.value, this.b.eval(t[0]));\n          if (Number.isFinite(this.b)) return this.operation(this.a.eval(t[0]), this.b.value);\n\n          var n = this._getDependentFeatures(t),\n              a = n.featureA,\n              i = n.featureB,\n              o = this.a.eval(a),\n              u = this.b.eval(i);\n\n          return this.operation(o, u);\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          for (var t = this.a.getLegendData(e), r = this.b.getLegendData(e), n = t.data.length, a = r.data.length, i = [], o = 0; o < n; o++) for (var u = 0; u < a; u++) {\n            var s = this.operation(t.data[o].value, r.data[u].value);\n            i.push({\n              value: s\n            });\n          }\n\n          return {\n            n: n,\n            m: a,\n            data: i\n          };\n        }\n      }, {\n        key: \"_getDependentFeatures\",\n        value: function _getDependentFeatures(e) {\n          var t = e.length > 1 ? {\n            featureA: e[0],\n            featureB: e[1]\n          } : {\n            featureA: e[0],\n            featureB: e[0]\n          };\n          return {\n            featureA: t.featureA,\n            featureB: t.featureB\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(BinaryOperation.prototype), \"_bindMetadata\", this).call(this, e);\n          var t = [this.a, this.b],\n              r = t[0],\n              n = t[1];\n          if (this._signature = getSignature(r, n), this._signature === pt || !(this._signature & this.allowedSignature)) throw new he(\"\".concat(this.expressionName, \"(): invalid parameter types\\n'x' type was \").concat(r.type, \", 'y' type was \").concat(n.type), de.INCORRECT_TYPE);\n\n          this.type = function getReturnTypeFromSignature(e) {\n            switch (e) {\n              case mt:\n                return \"number\";\n\n              case vt:\n              case yt:\n                return \"color\";\n\n              case gt:\n                return \"number\";\n\n              case _t:\n                return \"image\";\n\n              default:\n                return;\n            }\n          }(this._signature);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.operation(this.a.value, this.b.value);\n        }\n      }, {\n        key: \"operation\",\n        get: function get() {\n          return this.signatureMethods[this._signature] || this.signatureMethods[mt];\n        }\n      }]), BinaryOperation;\n    }(ut);\n\n    function getSignature(e, t) {\n      return e.type && t.type ? \"date\" === e.type && \"date\" === t.type ? bt : \"number\" === e.type && \"number\" === t.type ? mt : \"number\" === e.type && \"color\" === t.type ? vt : \"color\" === e.type && \"number\" === t.type ? vt : \"color\" === e.type && \"color\" === t.type ? yt : \"category\" === e.type && \"category\" === t.type ? gt : \"image\" === e.type && \"color\" === t.type || \"image\" === e.type && \"color\" === t.type || \"image\" === e.type && \"image\" === t.type || \"color\" === e.type && \"image\" === t.type ? _t : pt : void 0;\n    }\n\n    var Tt = function (e) {\n      function Add(e, t) {\n        var r;\n        p()(this, Add), checkMaxArguments(arguments, 2);\n        var n = {\n          1: function _(e, t) {\n            return e + t;\n          },\n          4: _addColors\n        };\n        return (r = N()(this, R()(Add).call(this, e, t, n, function glsl(e, t) {\n          return \"(\".concat(e, \" + \").concat(t, \")\");\n        }))).allowedSignature = mt | yt | _t, r;\n      }\n\n      return O()(Add, e), Add;\n    }(kt);\n\n    function _addColors(e, t) {\n      return {\n        r: e.r + t.r < 255 ? e.r + t.r : 255,\n        g: e.g + t.g < 255 ? e.g + t.g : 255,\n        b: e.b + t.b < 255 ? e.b + t.b : 255,\n        a: e.a\n      };\n    }\n\n    var wt = function (e) {\n      function And(e, t) {\n        var r;\n        p()(this, And), checkMaxArguments(arguments, 2);\n        var n = {\n          1: function _(e, t) {\n            return Math.min(e * t, 1);\n          }\n        };\n        return e = implicitCast(e), t = implicitCast(t), (r = N()(this, R()(And).call(this, e, t, n, function glsl(e, t) {\n          return \"min(\".concat(e, \" * \").concat(t, \", 1.)\");\n        }))).allowedSignature = mt, r;\n      }\n\n      return O()(And, e), And;\n    }(kt),\n        Ct = function (e) {\n      function Div(e, t) {\n        var r;\n        if (p()(this, Div), checkMaxArguments(arguments, 2), Number.isFinite(e) && Number.isFinite(t)) return N()(r, ba(e / t));\n        var n = {\n          1: function _(e, t) {\n            return e / t;\n          },\n          2: _divNumberColor,\n          4: _divColors\n        };\n        return e = implicitCast(e), t = implicitCast(t), (r = N()(this, R()(Div).call(this, e, t, n, function glsl(e, t) {\n          return \"(\".concat(e, \" / \").concat(t, \")\");\n        }))).allowedSignature = mt | vt | yt | _t, r;\n      }\n\n      return O()(Div, e), Div;\n    }(kt);\n\n    function _divColors(e, t) {\n      return {\n        r: Math.round(e.r / t.r),\n        g: Math.round(e.g / t.g),\n        b: Math.round(e.b / t.b),\n        a: e.a\n      };\n    }\n\n    function _divNumberColor(e, t) {\n      var r = \"number\" == typeof e ? {\n        n: e,\n        color: t\n      } : {\n        n: t,\n        color: e\n      },\n          n = r.n,\n          a = r.color;\n      return {\n        r: Math.round(a.r / n),\n        g: Math.round(a.g / n),\n        b: Math.round(a.b / n),\n        a: a.a\n      };\n    }\n\n    var Et = function (e) {\n      function Equals(e, t) {\n        var r;\n        p()(this, Equals), checkMaxArguments(arguments, 2);\n        return (r = N()(this, R()(Equals).call(this, e, t, {\n          1: function _(e, t) {\n            return e === t ? 1 : 0;\n          },\n          8: function _(e, t) {\n            return e === t ? 1 : 0;\n          }\n        }, function glsl(e, t) {\n          return \"(\".concat(e, \"==\").concat(t, \"? 1.:0.)\");\n        }))).allowedSignature = mt | gt, r;\n      }\n\n      return O()(Equals, e), Equals;\n    }(kt),\n        Mt = function (e) {\n      function GreaterThan(e, t) {\n        var r;\n        p()(this, GreaterThan), checkMaxArguments(arguments, 2);\n        return (r = N()(this, R()(GreaterThan).call(this, e, t, {\n          1: function _(e, t) {\n            return e > t ? 1 : 0;\n          }\n        }, function glsl(e, t) {\n          return \"(\".concat(e, \">\").concat(t, \"? 1.:0.)\");\n        }))).allowedSignature = mt | bt, r;\n      }\n\n      return O()(GreaterThan, e), GreaterThan;\n    }(kt),\n        At = function (e) {\n      function GreaterThanOrEqualTo(e, t) {\n        var r;\n        p()(this, GreaterThanOrEqualTo), checkMaxArguments(arguments, 2);\n        return (r = N()(this, R()(GreaterThanOrEqualTo).call(this, e, t, {\n          1: function _(e, t) {\n            return e >= t ? 1 : 0;\n          }\n        }, function glsl(e, t) {\n          return \"(\".concat(e, \">=\").concat(t, \"? 1.:0.)\");\n        }))).allowedSignature = mt | bt, r;\n      }\n\n      return O()(GreaterThanOrEqualTo, e), GreaterThanOrEqualTo;\n    }(kt),\n        St = function (e) {\n      function LessThan(e, t) {\n        var r;\n        p()(this, LessThan), checkMaxArguments(arguments, 2);\n        return (r = N()(this, R()(LessThan).call(this, e, t, {\n          1: function _(e, t) {\n            return e < t ? 1 : 0;\n          }\n        }, function glsl(e, t) {\n          return \"(\".concat(e, \"<\").concat(t, \"? 1.:0.)\");\n        }))).allowedSignature = mt | bt, r;\n      }\n\n      return O()(LessThan, e), LessThan;\n    }(kt),\n        Pt = function (e) {\n      function LessThanOrEqualTo(e, t) {\n        var r;\n        p()(this, LessThanOrEqualTo), checkMaxArguments(arguments, 2);\n        return (r = N()(this, R()(LessThanOrEqualTo).call(this, e, t, {\n          1: function _(e, t) {\n            return e <= t ? 1 : 0;\n          }\n        }, function glsl(e, t) {\n          return \"(\".concat(e, \"<=\").concat(t, \"? 1.:0.)\");\n        }))).allowedSignature = mt | bt, r;\n      }\n\n      return O()(LessThanOrEqualTo, e), LessThanOrEqualTo;\n    }(kt),\n        It = function (e) {\n      function Mod(e, t) {\n        var r;\n        p()(this, Mod), checkMaxArguments(arguments, 2);\n        return e = implicitCast(e), t = implicitCast(t), (r = N()(this, R()(Mod).call(this, e, t, {\n          1: function _(e, t) {\n            return e % t;\n          }\n        }, function glsl(e, t) {\n          return \"mod(\".concat(e, \", \").concat(t, \")\");\n        }))).allowedSignature = mt | bt, r;\n      }\n\n      return O()(Mod, e), Mod;\n    }(kt),\n        Nt = function (e) {\n      function Mul(e, t) {\n        var r;\n        p()(this, Mul), checkMaxArguments(arguments, 2);\n        var n = {\n          1: function _(e, t) {\n            return e * t;\n          },\n          2: _mulNumberColor,\n          4: _mulColors\n        };\n        return (r = N()(this, R()(Mul).call(this, e, t, n, function glsl(e, t) {\n          return \"(\".concat(e, \" * \").concat(t, \")\");\n        }))).allowedSignature = mt | vt | yt | _t, r;\n      }\n\n      return O()(Mul, e), Mul;\n    }(kt);\n\n    function _mulColors(e, t) {\n      return {\n        r: Math.round(e.r * t.r / 255),\n        g: Math.round(e.g * t.g / 255),\n        b: Math.round(e.b * t.b / 255),\n        a: e.a\n      };\n    }\n\n    function _mulNumberColor(e, t) {\n      var r = \"number\" == typeof e ? {\n        n: e,\n        color: t\n      } : {\n        n: t,\n        color: e\n      },\n          n = r.n,\n          a = r.color;\n      return {\n        r: Math.round(n * a.r / 255),\n        g: Math.round(n * a.g / 255),\n        b: Math.round(n * a.b / 255),\n        a: a.a\n      };\n    }\n\n    var Dt = function (e) {\n      function NotEquals(e, t) {\n        var r;\n        p()(this, NotEquals), checkMaxArguments(arguments, 2);\n        return (r = N()(this, R()(NotEquals).call(this, e, t, {\n          1: function _(e, t) {\n            return e !== t ? 1 : 0;\n          },\n          8: function _(e, t) {\n            return e !== t ? 1 : 0;\n          }\n        }, function glsl(e, t) {\n          return \"(\".concat(e, \"!=\").concat(t, \"? 1.:0.)\");\n        }))).allowedSignature = mt | gt | bt, r;\n      }\n\n      return O()(NotEquals, e), NotEquals;\n    }(kt),\n        Rt = function (e) {\n      function Or(e, t) {\n        var r;\n        p()(this, Or), checkMaxArguments(arguments, 2);\n        var n = {\n          1: function _(e, t) {\n            return Math.min(e + t, 1);\n          }\n        };\n        return e = implicitCast(e), t = implicitCast(t), (r = N()(this, R()(Or).call(this, e, t, n, function glsl(e, t) {\n          return \"min(\".concat(e, \" + \").concat(t, \", 1.)\");\n        }))).allowedSignature = mt, r;\n      }\n\n      return O()(Or, e), Or;\n    }(kt),\n        Ft = function (e) {\n      function Pow(e, t) {\n        var r;\n        p()(this, Pow), checkMaxArguments(arguments, 2);\n        var n = {\n          1: function _(e, t) {\n            return Math.pow(e, t);\n          }\n        };\n        return (r = N()(this, R()(Pow).call(this, e, t, n, function glsl(e, t) {\n          return \"pow(\".concat(e, \", \").concat(t, \")\");\n        }))).allowedSignature = mt, r;\n      }\n\n      return O()(Pow, e), Pow;\n    }(kt),\n        Ot = function (e) {\n      function Sub(e, t) {\n        var r;\n        p()(this, Sub), checkMaxArguments(arguments, 2);\n        var n = {\n          1: function _(e, t) {\n            return e - t;\n          },\n          4: _subColors\n        };\n        return (r = N()(this, R()(Sub).call(this, e, t, n, function glsl(e, t) {\n          return \"(\".concat(e, \" - \").concat(t, \")\");\n        }))).allowedSignature = mt | yt | _t, r;\n      }\n\n      return O()(Sub, e), Sub;\n    }(kt);\n\n    function _subColors(e, t) {\n      return {\n        r: e.r - t.r > 0 ? e.r - t.r : 0,\n        g: e.g - t.g > 0 ? e.g - t.g : 0,\n        b: e.b - t.b > 0 ? e.b - t.b : 0,\n        a: e.a\n      };\n    }\n\n    var Lt = function (e) {\n      function Blend(e, t, r, n) {\n        var a;\n        p()(this, Blend), checkMaxArguments(arguments, 4, \"blend\"), e = implicitCast(e), t = implicitCast(t), r = implicitCast(r), checkExpression(\"blend\", \"a\", 0, e), checkExpression(\"blend\", \"b\", 1, t), checkExpression(\"blend\", \"mix\", 2, r);\n        var i = r;\n        return n && (r = n(r)), (a = N()(this, R()(Blend).call(this, {\n          a: e,\n          b: t,\n          mix: r\n        }))).originalMix = i, e.type && t.type && (a.type = e.type), a.inlineMaker = function (e) {\n          return \"mix(\".concat(e.a, \", \").concat(e.b, \", clamp(\").concat(e.mix, \", 0., 1.))\");\n        }, a;\n      }\n\n      return O()(Blend, e), v()(Blend, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = utils_clamp(this.mix.eval(e), 0, 1);\n          return utils_mix(this.a.eval(e), this.b.eval(e), t);\n        }\n      }, {\n        key: \"replaceChild\",\n        value: function replaceChild(e, t) {\n          e === this.mix && (this.originalMix = t), lt()(R()(Blend.prototype), \"replaceChild\", this).call(this, e, t);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Blend.prototype), \"_bindMetadata\", this).call(this, e), function abTypeCheck(e, t) {\n            if (e.type !== t.type || ![\"number\", \"color\", \"image\", \"placement\", \"date\"].includes(e.type)) throw new he(\"blend(): invalid parameter types\\n\\t'a' type was '\".concat(e.type, \"'\\n\\t'b' type was '\").concat(t.type, \"'\"), de.INCORRECT_TYPE);\n          }(this.a, this.b), checkType(\"blend\", \"mix\", 2, \"number\", this.mix), this.type = this.a.type;\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw() {\n          for (var e, t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];\n\n          (e = lt()(R()(Blend.prototype), \"_preDraw\", this)).call.apply(e, [this].concat(r)), this.originalMix.isA(st) && !this.originalMix.isAnimated() && this.parent.replaceChild(this, this.b);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          var e = utils_clamp(this.mix.value, 0, 1);\n          return utils_mix(this.a.value, this.b.value, e);\n        }\n      }]), Blend;\n    }(ut);\n\n    var Bt = r(12),\n        Vt = r.n(Bt),\n        Gt = \"DEFAULT_RAMP_OTHERS\",\n        Ut = 10,\n        zt = -1,\n        qt = \"CARTO_VL_OTHERS\",\n        jt = {\n      othersLabel: qt,\n      samples: Ut\n    },\n        Wt = -(1 << 24),\n        Ht = function () {\n      function BucketsGLSLHelper(e) {\n        p()(this, BucketsGLSLHelper), this.buckets = e;\n      }\n\n      return v()(BucketsGLSLHelper, [{\n        key: \"applyToShaderSource\",\n        value: function applyToShaderSource(e) {\n          var t = this,\n              r = {};\n          this.buckets.childrenNames.map(function (r) {\n            return t.buckets[r]._applyToShaderSource(e);\n          }).map(function (e, n) {\n            r[t.buckets.childrenNames[n]] = e;\n          });\n\n          var n = \"buckets\".concat(this.buckets._uid),\n              a = this._getComparisons(r),\n              i = this.buckets.list.elems.map(a).join(\"\"),\n              o = \"float \".concat(n, \"(float x){\\n            \").concat(i, \"\\n            return \").concat(\"category\" === this.buckets.input.type ? \"(-1.)\" : (this.buckets.numCategories - 1).toFixed(20), \";\\n        }\");\n\n          return {\n            preface: this.buckets._prefaceCode(r.input.preface + r.list.preface + o),\n            inline: \"\".concat(n, \"(\").concat(r.input.inline, \")\")\n          };\n        }\n      }, {\n        key: \"_getComparisons\",\n        value: function _getComparisons(e) {\n          var t = \"category\" === this.buckets.input.type ? \"==\" : \"<\",\n              r = this.buckets.numCategoriesWithoutOthers - 1 || 1;\n          return r <= 20 ? function elif(n, a) {\n            return \"\".concat(a > 0 ? \"else\" : \"\", \" if (x\").concat(t, \"(\").concat(e.list.inline[a], \")){\\n                return \").concat(a, \"./\").concat(r.toFixed(20), \";\\n            }\");\n          } : function elif(n, a) {\n            return \"if (x\".concat(t, \"(\").concat(e.list.inline[a], \")){\\n                return \").concat(a, \"./\").concat(r.toFixed(20), \";\\n            }\");\n          };\n        }\n      }]), BucketsGLSLHelper;\n    }(),\n        Yt = function (e) {\n      function Buckets(e, t) {\n        var r,\n            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : qt;\n        p()(this, Buckets), checkMaxArguments(arguments, 3, \"buckets\");\n        var a = {\n          input: e = implicitCast(e),\n          list: t = implicitCast(t),\n          othersLabel: n = implicitCast(n)\n        };\n        return (r = N()(this, R()(Buckets).call(this, a))).numCategories = null, r.numCategoriesWithoutOthers = null, r.type = \"category\", r._GLSLhelper = new Ht(Vt()(Vt()(r))), r;\n      }\n\n      return O()(Buckets, e), v()(Buckets, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.input.eval(e),\n              r = this.numCategoriesWithoutOthers - 1 || 1;\n\n          if (\"category\" === this.input.type) {\n            for (var n = 0; n < this.list.elems.length; n++) if (t === this.list.elems[n].eval(e)) return n / r;\n\n            return zt;\n          }\n\n          for (var a = 0; a < this.list.elems.length; a++) if (t < this.list.elems[a].eval(e)) return a / r;\n\n          return 1;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = this;\n          if (lt()(R()(Buckets.prototype), \"_bindMetadata\", this).call(this, e), \"number\" !== this.input.type && \"category\" !== this.input.type) throw new he(\"buckets(): invalid first parameter type\\n\\t'input' type was \".concat(this.input.type), de.INCORRECT_TYPE);\n\n          if (checkType(\"buckets\", \"list\", 1, [\"number-list\", \"category-list\"], this.list), checkType(\"buckets\", \"othersLabel\", 2, \"category\", this.othersLabel), checkFeatureIndependent(\"buckets\", \"othersLabel\", 2, this.othersLabel), this.list.elems.map(function (e, r) {\n            if (t.input.type !== e.type) throw new he(\"buckets(): invalid \".concat(getOrdinalFromIndex(r + 1), \" parameter type\") + \"\\n\\texpected type was \".concat(t.input.type, \"\\n\\tactual type was \").concat(e.type), de.INCORRECT_TYPE);\n            if (\"number\" !== e.type && \"category\" !== e.type) throw new he(\"buckets(): invalid \".concat(getOrdinalFromIndex(r + 1), \" parameter type\\n\\ttype was \").concat(e.type), de.INCORRECT_TYPE);\n          }), \"category\" === this.input.type) {\n            var r = e.properties[this.input.propertyName];\n            this._numDatasetCategories = r ? r.categories.length : this.list.elems.length - 1;\n          }\n\n          this.numCategories = this.list.elems.length + 1, this.numCategoriesWithoutOthers = \"category\" === this.input.type ? this.numCategories - 1 : this.numCategories;\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          return this._GLSLhelper.applyToShaderSource(e);\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          var t = this.toString(),\n              r = this.list.elems.map(function (e) {\n            return e.value;\n          }),\n              n = {\n            othersLabel: e && e.othersLabel ? e.othersLabel : this.othersLabel.value\n          };\n          return {\n            data: \"number\" === this.input.type ? function _getLegendDataNumeric(e) {\n              for (var t = [], r = 0; r <= e.length; r++) {\n                var n = r - 1 >= 0 ? e[r - 1] : Number.NEGATIVE_INFINITY,\n                    a = r < e.length ? e[r] : Number.POSITIVE_INFINITY,\n                    i = [n, a],\n                    o = r / e.length;\n                t.push({\n                  key: i,\n                  value: o\n                });\n              }\n\n              return t;\n            }(r) : function _getLegendDataCategory(e, t, r) {\n              var n = e.length - 1 || 1,\n                  a = e.map(function (e, t) {\n                var r = e,\n                    a = t / n;\n                return {\n                  key: r,\n                  value: a\n                };\n              });\n              t > e.length && a.push({\n                key: r.othersLabel,\n                value: zt\n              });\n              return a;\n            }(r, this._numDatasetCategories, n),\n            name: t\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval();\n        }\n      }]), Buckets;\n    }(ut);\n\n    var Zt = function (e) {\n      function BaseCategory(e) {\n        var t;\n        return p()(this, BaseCategory), checkMaxArguments(arguments, 1, \"category\"), checkString(\"category\", \"categoryName\", 0, e), (t = N()(this, R()(BaseCategory).call(this, {})))._value = e, t.type = \"category\", t;\n      }\n\n      return O()(BaseCategory, e), v()(BaseCategory, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !1;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return !1;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this._metadata = e;\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource() {\n          return {\n            preface: this._prefaceCode(\"uniform float cat\".concat(this._uid, \";\\n\")),\n            inline: \"cat\".concat(this._uid)\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._getBinding(e).uniformLocation = t.getUniformLocation(e, \"cat\".concat(this._uid));\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          var n = this._metadata.categoryToID.get(this.value);\n\n          r.uniform1f(this._getBinding(e).uniformLocation, n);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        },\n        set: function set(e) {\n          this.value = e;\n        }\n      }]), BaseCategory;\n    }(ut),\n        Xt = r(18),\n        Qt = r.n(Xt),\n        $t = function (e) {\n      function CIELab(e, t, r) {\n        var n;\n        return p()(this, CIELab), checkMaxArguments(arguments, 3, \"cielab\"), e = implicitCast(e), t = implicitCast(t), r = implicitCast(r), checkExpression(\"cielab\", \"l\", 0, e), checkExpression(\"cielab\", \"a\", 1, t), checkExpression(\"cielab\", \"b\", 2, r), (n = N()(this, R()(CIELab).call(this, {\n          l: e,\n          a: t,\n          b: r\n        }))).type = \"color\", n._setGenericGLSL(function (e) {\n          return \"cielabToSRGBA(vec4(\".concat(e.l, \", \").concat(e.a, \", \").concat(e.b, \", 1.))\");\n        }, Qt.a), n;\n      }\n\n      return O()(CIELab, e), v()(CIELab, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return cielabToSRGB({\n            l: this.l.eval(e),\n            a: this.a.eval(e),\n            b: this.b.eval(e)\n          });\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          return {\n            name: \"color\",\n            data: [{\n              key: \"color\",\n              value: this.value\n            }]\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(CIELab.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"cielab\", \"l\", 0, \"number\", this.l), checkType(\"cielab\", \"a\", 1, \"number\", this.a), checkType(\"cielab\", \"b\", 2, \"number\", this.b);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval(null);\n        }\n      }]), CIELab;\n    }(ut),\n        Jt = r(15),\n        Kt = r.n(Jt),\n        er = function (e) {\n      function Property(e) {\n        var t;\n        if (p()(this, Property), checkMaxArguments(arguments, 1, \"property\"), checkString(\"property\", \"name\", 0, e), \"\" === e) throw new he(\"property(): invalid parameter, zero-length string\", de.INCORRECT_VALUE);\n        return (t = N()(this, R()(Property).call(this, {}))).name = e, t.expressionName = e, lt()(R()(Property.prototype), \"_setGenericGLSL\", Vt()(t)).call(Vt()(t), function (e, r) {\n          return r(t.name);\n        }), t;\n      }\n\n      return O()(Property, e), v()(Property, [{\n        key: \"isFeatureDependent\",\n        value: function isFeatureDependent() {\n          return !0;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          if (!e) throw new he(\"A property needs to be evaluated in a 'feature'.\", de.MISSING_REQUIRED);\n          return e[this.name] && e[this.name] === Wt ? null : e[this.name];\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"$\".concat(this.name);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = e.properties[this.name];\n          if (!t) throw new he(\"Property '\".concat(this.name, \"' does not exist\"), de.MISSING_REQUIRED);\n          this._metadata = e, this.type = t.type, \"category\" === this.type && void 0 === this.numCategories && Object.defineProperty(this, \"numCategories\", {\n            get: function get() {\n              return t.categories.length;\n            }\n          });\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          return {\n            preface: \"\",\n            inline: e(this.name)\n          };\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          var e = this._variableName ? Te : ke;\n          return Kt()({}, this.name, [{\n            type: e\n          }]);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.propertyName;\n        }\n      }, {\n        key: \"propertyName\",\n        get: function get() {\n          return this.name;\n        }\n      }, {\n        key: \"categories\",\n        get: function get() {\n          return \"category\" === this.type ? this._metadata.properties[this.name].categories : void 0;\n        }\n      }]), Property;\n    }(ut),\n        tr = function (e) {\n      function ClusterAggregation(e) {\n        var t,\n            r = e.property,\n            n = e.expressionName,\n            a = e.aggName,\n            i = e.aggType;\n        return p()(this, ClusterAggregation), checkExpression(n, \"property\", 0, r), (t = N()(this, R()(ClusterAggregation).call(this, {\n          property: r\n        })))._aggName = a, t._expressionName = n, t.type = i, t;\n      }\n\n      return O()(ClusterAggregation, e), v()(ClusterAggregation, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return e[this.propertyName];\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ClusterAggregation.prototype), \"_bindMetadata\", this).call(this, e), this._metadata = e, checkInstance(this._expressionName, \"property\", 0, er, this.property), checkType(this._expressionName, \"property\", 0, this.type, this.property);\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          return {\n            preface: \"\",\n            inline: \"\".concat(e(this.propertyName))\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile() {}\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return Kt()({}, this.property.name, [{\n            type: xe,\n            op: this._aggName\n          }]);\n        }\n      }, {\n        key: \"name\",\n        get: function get() {\n          return this.property.name;\n        }\n      }, {\n        key: \"propertyName\",\n        get: function get() {\n          return Ce.aggColumn(this.property.name, this._aggName);\n        }\n      }, {\n        key: \"aggName\",\n        get: function get() {\n          return this._aggName;\n        }\n      }, {\n        key: \"numCategories\",\n        get: function get() {\n          return this.property.numCategories;\n        }\n      }, {\n        key: \"categories\",\n        get: function get() {\n          return this.property.categories;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.propertyName;\n        }\n      }]), ClusterAggregation;\n    }(ut),\n        rr = function (e) {\n      function ClusterAvg(e) {\n        return p()(this, ClusterAvg), checkMaxArguments(arguments, 1, \"clusterAvg\"), N()(this, R()(ClusterAvg).call(this, {\n          property: e,\n          expressionName: \"clusterAvg\",\n          aggName: \"avg\",\n          aggType: \"number\"\n        }));\n      }\n\n      return O()(ClusterAvg, e), ClusterAvg;\n    }(tr),\n        nr = function (e) {\n      function ClusterMax(e) {\n        return p()(this, ClusterMax), checkMaxArguments(arguments, 1, \"clusterMax\"), N()(this, R()(ClusterMax).call(this, {\n          property: e,\n          expressionName: \"clusterMax\",\n          aggName: \"max\",\n          aggType: \"number\"\n        }));\n      }\n\n      return O()(ClusterMax, e), ClusterMax;\n    }(tr),\n        ar = function (e) {\n      function ClusterMin(e) {\n        return p()(this, ClusterMin), checkMaxArguments(arguments, 1, \"clusterMin\"), N()(this, R()(ClusterMin).call(this, {\n          property: e,\n          expressionName: \"clusterMin\",\n          aggName: \"min\",\n          aggType: \"number\"\n        }));\n      }\n\n      return O()(ClusterMin, e), ClusterMin;\n    }(tr),\n        ir = function (e) {\n      function ClusterMode(e) {\n        return p()(this, ClusterMode), checkMaxArguments(arguments, 1, \"clusterMode\"), N()(this, R()(ClusterMode).call(this, {\n          property: e,\n          expressionName: \"clusterMode\",\n          aggName: \"mode\",\n          aggType: \"category\"\n        }));\n      }\n\n      return O()(ClusterMode, e), ClusterMode;\n    }(tr),\n        ur = function (e) {\n      function ClusterSum(e) {\n        return p()(this, ClusterSum), checkMaxArguments(arguments, 1, \"clusterSum\"), N()(this, R()(ClusterSum).call(this, {\n          property: e,\n          expressionName: \"clusterSum\",\n          aggName: \"sum\",\n          aggType: \"number\"\n        }));\n      }\n\n      return O()(ClusterSum, e), ClusterSum;\n    }(tr),\n        sr = function (e) {\n      function ClusterCount() {\n        var e;\n        return p()(this, ClusterCount), checkMaxArguments(arguments, 0, \"clusterCount\"), (e = N()(this, R()(ClusterCount).call(this, {}))).type = \"number\", e._hasClusterFeatureCount = !1, e;\n      }\n\n      return O()(ClusterCount, e), v()(ClusterCount, [{\n        key: \"isFeatureDependent\",\n        value: function isFeatureDependent() {\n          return !0;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return Number(e._cdb_feature_count) || 1;\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          return {\n            data: this._hasClusterFeatureCount ? this._metadata.properties._cdb_feature_count : []\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ClusterCount.prototype), \"_bindMetadata\", this).call(this, e), this._metadata = e, this._hasClusterFeatureCount = void 0 !== e.properties._cdb_feature_count;\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          return {\n            preface: \"\",\n            inline: this._hasClusterFeatureCount ? e(\"_cdb_feature_count\") : \"1.\"\n          };\n        }\n      }, {\n        key: \"propertyName\",\n        get: function get() {\n          return \"_cdb_feature_count\";\n        }\n      }]), ClusterCount;\n    }(ut),\n        cr = [\"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\", \"week\", \"quarter\", \"trimester\", \"semester\", \"decade\", \"century\", \"millennium\"],\n        lr = [\"dayOfYear\", \"weekOfYear\", \"monthOfYear\", \"quarterOfYear\", \"dayOfMonth\", \"dayOfWeek\", \"hourOfDay\", \"minuteOfHour\"],\n        fr = function (e) {\n      function clusterTimeDimension(e) {\n        var t,\n            r = e.property,\n            n = e.expressionName,\n            a = e.dimension,\n            i = e.type,\n            o = e.range;\n        return p()(this, clusterTimeDimension), checkExpression(n, \"property\", 0, r), (t = N()(this, R()(clusterTimeDimension).call(this, {\n          property: r\n        })))._dimension = a, t._dimension.propertyName = Ce.dimColumn(t.property.propertyName, t._dimension.group.units), t._expressionName = n, t.type = i, t._range = o, t;\n      }\n\n      return O()(clusterTimeDimension, e), v()(clusterTimeDimension, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return e[this.propertyName];\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(clusterTimeDimension.prototype), \"_bindMetadata\", this).call(this, e), checkInstance(this._expressionName, \"property\", 0, er, this.property), checkType(this._expressionName, \"property\", 0, \"date\", this.property), this._range = e.properties[e.baseName(this.propertyName)].dimension.range;\n        }\n      }, {\n        key: \"_resolveAliases\",\n        value: function _resolveAliases() {}\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          return {\n            preface: \"\",\n            inline: this._range ? this._range.map(function (t) {\n              return [\"\".concat(e(t))];\n            }) : \"\".concat(e(this.propertyName))\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile() {}\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return Kt()({}, this.name, [{\n            type: \"dimension\",\n            dimension: this._dimension,\n            range: !!this._range\n          }]);\n        }\n      }, {\n        key: \"name\",\n        get: function get() {\n          return this.property.propertyName;\n        }\n      }, {\n        key: \"propertyName\",\n        get: function get() {\n          return this._dimension.propertyName;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return {\n            name: this.propertyName,\n            range: this._range,\n            dimension: this._dimension\n          };\n        }\n      }], [{\n        key: \"serialUnits\",\n        get: function get() {\n          return cr;\n        }\n      }, {\n        key: \"cyclicUnits\",\n        get: function get() {\n          return lr;\n        }\n      }]), clusterTimeDimension;\n    }(ut),\n        hr = function (e) {\n      function ClusterTime(e, t, r) {\n        p()(this, ClusterTime);\n        var n = fr.cyclicUnits.includes(t);\n        return checkMaxArguments(arguments, 3, \"clusterTime\"), checkExpression(\"clusterTime\", \"property\", 0, e), checkStringValue(\"clusterTime\", \"units\", 1, t, n ? fr.cyclicUnits : fr.serialUnits), N()(this, R()(ClusterTime).call(this, {\n          property: e,\n          expressionName: \"clusterTime\",\n          dimension: {\n            group: {\n              units: t,\n              timezone: r\n            },\n            format: n ? \"number\" : \"iso\"\n          },\n          type: n ? \"number\" : \"timerange\",\n          range: n ? void 0 : []\n        }));\n      }\n\n      return O()(ClusterTime, e), v()(ClusterTime, [{\n        key: \"converse\",\n        value: function converse(e) {\n          return e;\n        }\n      }]), ClusterTime;\n    }(fr),\n        dr = function (e) {\n      function Constant(e) {\n        var t;\n        return p()(this, Constant), checkMaxArguments(arguments, 1, \"constant\"), checkNumber(\"constant\", \"x\", 0, e), (t = N()(this, R()(Constant).call(this, {})))._value = e, t.type = \"number\", t.inlineMaker = function () {\n          return \"(\".concat(e.toFixed(20), \")\");\n        }, t;\n      }\n\n      return O()(Constant, e), v()(Constant, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.value);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        },\n        set: function set(e) {\n          this._value = e;\n        }\n      }]), Constant;\n    }(ut),\n        pr = function (e) {\n      function Hex(e) {\n        var t;\n        p()(this, Hex), checkMaxArguments(arguments, 1, \"hex\"), checkString(\"hex\", \"hexadecimalColor\", 0, e), (t = N()(this, R()(Hex).call(this, {}))).type = \"color\";\n\n        try {\n          t.color = hexToRgb(e);\n        } catch (e) {\n          var r = getStringErrorPreface(\"hex\", \"hexadecimalColor\", 0);\n          throw new he(\"\".concat(r, \" \\nInvalid hexadecimal color string\"), de.INCORRECT_VALUE);\n        }\n\n        return t.hexadecimalColor = e, t.inlineMaker = function () {\n          return \"vec4(\".concat((t.color.r / 255).toFixed(4), \", \").concat((t.color.g / 255).toFixed(4), \", \").concat((t.color.b / 255).toFixed(4), \", \").concat(t.color.a.toFixed(4), \")\");\n        }, t;\n      }\n\n      return O()(Hex, e), v()(Hex, [{\n        key: \"toString\",\n        value: function toString() {\n          return this.hexadecimalColor;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          return {\n            name: \"color\",\n            data: [{\n              key: \"color\",\n              value: this.value\n            }]\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.color;\n        }\n      }]), Hex;\n    }(ut),\n        mr = genHSL(\"hsl\", !1),\n        vr = genHSL(\"hsla\", !0);\n\n    function genHSL(e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n      return function (r) {\n        function HSLA(r, n, a, i) {\n          var o;\n          p()(this, HSLA), checkMaxArguments(arguments, 4, \"hsla\");\n          var u = [r, n, a, i].map(implicitCast),\n              s = g()(u, 4);\n          r = s[0], n = s[1], a = s[2], i = s[3];\n          var c = {\n            h: r,\n            s: n,\n            l: a\n          };\n          return t && (checkExpression(e, \"a\", 3, i), c.a = i), checkExpression(e, \"h\", 0, r), checkExpression(e, \"s\", 1, n), checkExpression(e, \"l\", 2, a), (o = N()(this, R()(HSLA).call(this, c)))._alpha = t, o.type = \"color\", o;\n        }\n\n        return O()(HSLA, r), v()(HSLA, [{\n          key: \"eval\",\n          value: function _eval(e) {\n            return function hslToRgb(e, t, r, n, a, i) {\n              var o = a ? i ? n.eval(i) : n.value : 1,\n                  u = {\n                r: Math.abs(6 * e - 3) - 1,\n                g: 2 - Math.abs(6 * e - 2),\n                b: 2 - Math.abs(6 * e - 4),\n                a: o\n              },\n                  s = (1 - Math.abs(2 * r - 1)) * t;\n              return u.r = utils_clamp(u.r, 0, 1), u.g = utils_clamp(u.g, 0, 1), u.b = utils_clamp(u.b, 0, 1), u.r = 255 * ((u.r - .5) * s + r), u.g = 255 * ((u.g - .5) * s + r), u.b = 255 * ((u.b - .5) * s + r), u;\n            }(utils_clamp(normalize(this.h, e, !0), 0, 1), utils_clamp(normalize(this.s, e), 0, 1), utils_clamp(normalize(this.l, e), 0, 1), this.a, this._alpha, e);\n          }\n        }, {\n          key: \"getLegendData\",\n          value: function getLegendData() {\n            return {\n              name: \"color\",\n              data: [{\n                key: \"color\",\n                value: this.value\n              }]\n            };\n          }\n        }, {\n          key: \"_bindMetadata\",\n          value: function _bindMetadata(e) {\n            var t = this;\n            lt()(R()(HSLA.prototype), \"_bindMetadata\", this).call(this, e), hslCheckType(\"h\", 0, this.h), hslCheckType(\"s\", 1, this.s), hslCheckType(\"l\", 2, this.l), this._alpha && checkType(\"hsla\", \"a\", 3, \"number\", this.a), lt()(R()(HSLA.prototype), \"_setGenericGLSL\", this).call(this, function (e) {\n              return \"vec4(HSLtoRGB(vec3(\\n                    \".concat(e.h).concat(normalizeGLSL(t.h, !0), \",\\n                    clamp(\").concat(e.s).concat(normalizeGLSL(t.s), \", 0., 1.),\\n                    clamp(\").concat(e.l).concat(normalizeGLSL(t.l), \", 0., 1.)\\n                )), \").concat(t._alpha ? \"clamp(\".concat(e.a, \", 0., 1.)\") : \"1.\", \")\");\n            }, \"\\n                    #ifndef HSL2RGB\\n                    #define HSL2RGB\\n                    vec3 HSLtoRGB(vec3 HSL) {\\n                        float R = abs(HSL.x * 6. - 3.) - 1.;\\n                        float G = 2. - abs(HSL.x * 6. - 2.);\\n                        float B = 2. - abs(HSL.x * 6. - 4.);\\n                        float C = (1. - abs(2. * HSL.z - 1.)) * HSL.y;\\n                        vec3 RGB = clamp(vec3(R,G,B), 0., 1.);\\n                        return (RGB - 0.5) * C + HSL.z;\\n                    }\\n                    #endif\\n                \");\n          }\n        }, {\n          key: \"value\",\n          get: function get() {\n            return this.eval(null);\n          }\n        }]), HSLA;\n      }(ut);\n\n      function hslCheckType(t, r, n) {\n        if (checkExpression(e, t, r, n), \"number\" !== n.type && \"category\" !== n.type && void 0 !== n.type) throw new he(\"\".concat(e, \"(): invalid parameter\\n\\t\").concat(t, \" type was: '\").concat(n.type, \"'\"), de.INCORRECT_TYPE);\n      }\n\n      function normalize(e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            n = null !== t ? e.eval(t) : e.value;\n        return \"category\" === e.type ? n / (r ? e.numCategories + 1 : e.numCategories) : n;\n      }\n\n      function normalizeGLSL(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        return \"category\" === e.type ? \"/\".concat(t ? e.numCategories + 1 : e.numCategories, \".\") : \"\";\n      }\n    }\n\n    var yr = genHSV(\"hsv\", !1),\n        gr = genHSV(\"hsva\", !0);\n\n    function genHSV(e, t) {\n      return function (r) {\n        function _class(r, n, a, i) {\n          var o;\n          p()(this, _class), checkMaxArguments(arguments, t ? 4 : 3, e);\n          var u = {\n            h: r = implicitCast(r),\n            s: n = implicitCast(n),\n            v: a = implicitCast(a)\n          };\n          return t && (i = implicitCast(i), checkExpression(e, \"a\", 3, i), u.a = i), checkExpression(e, \"h\", 0, r), checkExpression(e, \"s\", 1, n), checkExpression(e, \"v\", 2, a), (o = N()(this, R()(_class).call(this, u))).type = \"color\", o;\n        }\n\n        return O()(_class, r), v()(_class, [{\n          key: \"eval\",\n          value: function _eval(e) {\n            var r = this,\n                n = function normalize(t) {\n              var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n              return \"category\" === t.type ? t.eval(e) / (r ? t.numCategories + 1 : t.numCategories) : t.eval(e);\n            };\n\n            return function hsvToRgb(n, a, i) {\n              var o = {\n                r: Math.abs(6 * n - 3) - 1,\n                g: 2 - Math.abs(6 * n - 2),\n                b: 2 - Math.abs(6 * n - 4),\n                a: t ? utils_clamp(r.a.eval(e), 0, 1) : 1\n              };\n              return o.r = utils_clamp(o.r, 0, 1), o.g = utils_clamp(o.g, 0, 1), o.b = utils_clamp(o.b, 0, 1), o.r = ((o.r - 1) * a + 1) * i * 255, o.g = ((o.g - 1) * a + 1) * i * 255, o.b = ((o.b - 1) * a + 1) * i * 255, o;\n            }(utils_clamp(n(this.h, !0), 0, 1), utils_clamp(n(this.s), 0, 1), utils_clamp(n(this.v), 0, 1));\n          }\n        }, {\n          key: \"getLegendData\",\n          value: function getLegendData() {\n            return {\n              name: \"color\",\n              data: [{\n                key: \"color\",\n                value: this.value\n              }]\n            };\n          }\n        }, {\n          key: \"_bindMetadata\",\n          value: function _bindMetadata(e) {\n            var r = this;\n            lt()(R()(_class.prototype), \"_bindMetadata\", this).call(this, e), hsvCheckType(\"h\", 0, this.h), hsvCheckType(\"s\", 1, this.s), hsvCheckType(\"v\", 2, this.v), t && checkType(\"hsva\", \"a\", 3, \"number\", this.a);\n\n            var n = function normalize(e) {\n              var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n              return \"category\" === e.type ? \"/\".concat(t ? e.numCategories + 1 : e.numCategories, \".\") : \"\";\n            };\n\n            lt()(R()(_class.prototype), \"_setGenericGLSL\", this).call(this, function (e) {\n              return \"vec4(HSVtoRGB(vec3(\\n                    \".concat(e.h).concat(n(r.h, !0), \",\\n                    clamp(\").concat(e.s).concat(n(r.s), \", 0.,1.),\\n                    clamp(\").concat(e.v).concat(n(r.v), \", 0.,1.)\\n                )), \").concat(t ? \"clamp(\".concat(e.a, \", 0.,1.)\") : \"1.\", \")\");\n            }, \"\\n                    #ifndef HSV2RGB\\n                    #define HSV2RGB\\n                    vec3 HSVtoRGB(vec3 HSV) {\\n                        float R = abs(HSV.x * 6. - 3.) - 1.;\\n                        float G = 2. - abs(HSV.x * 6. - 2.);\\n                        float B = 2. - abs(HSV.x * 6. - 4.);\\n                        vec3 RGB = clamp(vec3(R,G,B), 0., 1.);\\n                        return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\\n                    }\\n                    #endif\\n                \");\n          }\n        }, {\n          key: \"value\",\n          get: function get() {\n            return this.eval(null);\n          }\n        }]), _class;\n      }(ut);\n\n      function hsvCheckType(t, r, n) {\n        if (checkExpression(e, t, r, n), \"number\" !== n.type && \"category\" !== n.type && void 0 !== n.type) throw new he(\"\".concat(e, \"(): invalid parameter\\n\\t\").concat(t, \" type was: '\").concat(n.type, \"'\"), de.INCORRECT_TYPE);\n      }\n    }\n\n    var _r = function (e) {\n      function ILinear() {\n        return p()(this, ILinear), N()(this, R()(ILinear).apply(this, arguments));\n      }\n\n      return O()(ILinear, e), ILinear;\n    }(genInterpolator(\"iLinear\", function (e) {\n      return e;\n    }, void 0, function (e) {\n      return e;\n    })),\n        br = function (e) {\n      function Cubic() {\n        return p()(this, Cubic), N()(this, R()(Cubic).apply(this, arguments));\n      }\n\n      return O()(Cubic, e), Cubic;\n    }(genInterpolator(\"cubic\", function (e) {\n      return \"cubicEaseInOut(\".concat(e, \")\");\n    }, \"\\n    #ifndef CUBIC\\n    #define CUBIC\\n    float cubicEaseInOut(float p){\\n        if (p < 0.5) {\\n            return 4. * p * p * p;\\n        }else {\\n            float f = ((2. * p) - 2.);\\n            return 0.5 * f * f * f + 1.;\\n        }\\n    }\\n    #endif\\n\", function (e) {\n      return e;\n    }));\n\n    genInterpolator(\"bounceEaseIn\", function (e) {\n      return \"BounceEaseIn(\".concat(e, \")\");\n    }, \"\\n    #ifndef BOUNCE_EASE_IN\\n    #define BOUNCE_EASE_IN\\n    float BounceEaseIn_BounceEaseOut(float p)\\n    {\\n        if(p < 4./11.0)\\n        {\\n            return (121. * p * p)/16.0;\\n        }\\n        else if(p < 8./11.0)\\n        {\\n            return (363./40.0 * p * p) - (99./10.0 * p) + 17./5.0;\\n        }\\n        else if(p < 9./10.0)\\n        {\\n            return (4356./361.0 * p * p) - (35442./1805.0 * p) + 16061./1805.0;\\n        }\\n        else\\n        {\\n            return (54./5.0 * p * p) - (513./25.0 * p) + 268./25.0;\\n        }\\n    }\\n    float BounceEaseIn(float p)\\n    {\\n        return 1. - BounceEaseOut(1. - p);\\n    }\\n    #endif\\n\\n\", function (e) {\n      return e;\n    });\n\n    function genInterpolator(e, t, r, n) {\n      var a = function (a) {\n        function Interpolator(t) {\n          return p()(this, Interpolator), checkMaxArguments(arguments, 1, e), t = implicitCast(t), N()(this, R()(Interpolator).call(this, {\n            m: t\n          }));\n        }\n\n        return O()(Interpolator, a), v()(Interpolator, [{\n          key: \"eval\",\n          value: function _eval(e) {\n            return n(this.m.eval(e));\n          }\n        }, {\n          key: \"_bindMetadata\",\n          value: function _bindMetadata(e) {\n            if (lt()(R()(Interpolator.prototype), \"_bindMetadata\", this).call(this, e), \"number\" !== this.m.type) throw new he(\"Blending cannot be performed by '\".concat(this.m.type, \"'\"), de.INCORRECT_TYPE);\n            this.type = \"number\", this._setGenericGLSL(function (e) {\n              return t(e.m);\n            }, r);\n          }\n        }]), Interpolator;\n      }(ut);\n\n      return a.type = \"interpolator\", a;\n    }\n\n    var xr = function () {\n      function BaseCodec(e, t) {\n        p()(this, BaseCodec), e && t && (this._baseName = e.baseName(t));\n      }\n\n      return v()(BaseCodec, [{\n        key: \"isRange\",\n        value: function isRange() {\n          return !1;\n        }\n      }, {\n        key: \"isIdentity\",\n        value: function isIdentity() {\n          return !1;\n        }\n      }, {\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          return t;\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          return t;\n        }\n      }, {\n        key: \"externalToSource\",\n        value: function externalToSource(e, t) {\n          return t;\n        }\n      }, {\n        key: \"sourceToExternal\",\n        value: function sourceToExternal(e, t) {\n          return this.internalToExternal(e, this.sourceToInternal(e, t));\n        }\n      }, {\n        key: \"externalToInternal\",\n        value: function externalToInternal(e, t) {\n          return this.sourceToInternal(e, this.externalToSource(e, t));\n        }\n      }, {\n        key: \"inlineInternalMatch\",\n        value: function inlineInternalMatch(e, t) {\n          return \"\".concat(e);\n        }\n      }]), BaseCodec;\n    }(),\n        kr = function (e) {\n      function IdentityCodec() {\n        return p()(this, IdentityCodec), N()(this, R()(IdentityCodec).apply(this, arguments));\n      }\n\n      return O()(IdentityCodec, e), v()(IdentityCodec, [{\n        key: \"isIdentity\",\n        value: function isIdentity() {\n          return !0;\n        }\n      }, {\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          return t;\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          return t;\n        }\n      }, {\n        key: \"sourceToExternal\",\n        value: function sourceToExternal(e, t) {\n          return t;\n        }\n      }, {\n        key: \"externalToSource\",\n        value: function externalToSource(e, t) {\n          return t;\n        }\n      }, {\n        key: \"externalToInternal\",\n        value: function externalToInternal(e, t) {\n          return t;\n        }\n      }]), IdentityCodec;\n    }(xr),\n        Tr = function (e) {\n      function Linear(e, t, r, n) {\n        var a,\n            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ut;\n        return p()(this, Linear), checkMaxArguments(arguments, 5, \"linear\"), e = implicitCast(e), !t || t instanceof ut || void 0 !== r || void 0 !== n || (n = t, t = void 0, r = void 0), void 0 === t && void 0 === r && (t = io(e), r = ao(e)), t = implicitCast(t), r = implicitCast(r), i = implicitCast(i), checkExpression(\"linear\", \"input\", 0, e), checkExpression(\"linear\", \"min\", 1, t), checkExpression(\"linear\", \"max\", 2, r), checkExpression(\"linear\", \"samples\", 4, i), (a = N()(this, R()(Linear).call(this, {\n          input: e,\n          min: t,\n          max: r\n        }))).type = \"number\", a.samples = i, a._rangeMode = n || \"unit\", a;\n      }\n\n      return O()(Linear, e), v()(Linear, [{\n        key: \"converse\",\n        value: function converse(e) {\n          if (\"date\" === this.input.type) {\n            var t = this.min.value.getTime();\n            return msToDate(e * (this.max.value.getTime() - t) + t);\n          }\n\n          if (\"timerange\" === this.input.type) {\n            var r,\n                n,\n                a = castTimeRange(this.min.value),\n                i = castTimeRange(this.max.value);\n            if (void 0 === a || void 0 === i) return null;\n\n            switch (this._rangeMode) {\n              case \"unit\":\n                r = a.startValue, n = i.startValue;\n                break;\n\n              case \"start\":\n              case \"end\":\n                r = a.startValue, n = i.endValue;\n            }\n\n            return Q.fromValue(e * (n - r) + r, a.timeZone);\n          }\n\n          var o = this.min.value;\n          return e * (this.max.value - o) + o;\n        }\n      }, {\n        key: \"limits\",\n        value: function limits() {\n          var e, t;\n          if (\"timerange\" === this.input.type) switch (this._rangeMode) {\n            case \"unit\":\n              e = castTimeRange(this.min.value).startValue, t = castTimeRange(this.max.value).startValue;\n              break;\n\n            case \"start\":\n            case \"end\":\n              e = castTimeRange(this.min.value).startValue, t = castTimeRange(this.max.value).endValue;\n          } else e = this.min.value, t = this.max.value;\n          return [e, t];\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          if (\"timerange\" === this.input.type) {\n            var t;\n\n            switch (this._rangeMode) {\n              case \"unit\":\n              case \"start\":\n                t = 0;\n                break;\n\n              case \"end\":\n                t = 1;\n            }\n\n            return (e._dataframe.properties[this._metadata.decodedProperties(this.input.propertyName)[t]][e._index] - this._internalMin) / (this._internalMax - this._internalMin);\n          }\n\n          var r = this.input.eval(e),\n              n = this._metadata,\n              a = n && this.input.propertyName ? n.codec(this.input.propertyName) : new kr(),\n              i = a.externalToInternal(n, this.min.eval(e)),\n              o = a.externalToInternal(n, this.max.eval(e));\n          return (a.externalToInternal(n, r) - i) / (o - i);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          if (lt()(R()(Linear.prototype), \"_bindMetadata\", this).call(this, e), this._metadata = e, \"timerange\" === this.input.type) {\n            var t, r, n;\n\n            switch (this._rangeMode) {\n              case \"unit\":\n                t = 0, r = e.codec(this.input.propertyName).externalToInternal(e, this.min.value)[t], n = e.codec(this.input.propertyName).externalToInternal(e, this.max.value)[t];\n                break;\n\n              case \"start\":\n                t = 0, r = e.codec(this.input.propertyName).externalToInternal(e, this.min.value)[0], n = e.codec(this.input.propertyName).externalToInternal(e, this.max.value)[1];\n                break;\n\n              case \"end\":\n                t = 1, r = e.codec(this.input.propertyName).externalToInternal(e, this.min.value)[0], n = e.codec(this.input.propertyName).externalToInternal(e, this.max.value)[1];\n            }\n\n            this._internalMin = r, this._internalMax = n, this.inlineMaker = function (e) {\n              return \"((\".concat(e.input[t], \"-(\").concat(r.toFixed(20), \"))/(\").concat((n - r).toFixed(20), \"))\");\n            };\n          } else {\n            checkType(\"linear\", \"input\", 0, [\"number\", \"date\"], this.input), checkType(\"linear\", \"min\", 1, [\"number\", \"date\"], this.min), checkType(\"linear\", \"max\", 2, [\"number\", \"date\"], this.max), checkType(\"linear\", \"samples\", 4, [\"number\"], this.samples);\n            var a = this.input.propertyName && e.codec(this.input.propertyName);\n            if (!a || a.isIdentity()) this.inlineMaker = function (e) {\n              return \"((\".concat(e.input, \"-\").concat(e.min, \")/(\").concat(e.max, \"-\").concat(e.min, \"))\");\n            };else {\n              var i = a.externalToInternal(e, this.min.value),\n                  o = a.externalToInternal(e, this.max.value);\n\n              this.inlineMaker = function (e) {\n                return \"((\".concat(e.input, \"-(\").concat(i.toFixed(20), \"))/(\").concat((o - i).toFixed(20), \"))\");\n              };\n            }\n          }\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          var t = this.min.value,\n              r = this.max.value,\n              n = this.toString();\n          if (t === r) return {\n            min: t,\n            max: r,\n            name: n,\n            data: []\n          };\n\n          for (var a = e && e.samples ? e.samples : this.samples, i = 1 / (a - 1), o = [], u = 0; o.length < a; u += i) {\n            var s = utils_clamp(u, 0, 1),\n                c = u * (r - t) + t;\n            o.push({\n              key: c,\n              value: s\n            });\n          }\n\n          return {\n            data: o,\n            min: t,\n            max: r,\n            name: n\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return {\n            min: this.min,\n            max: this.max,\n            input: this.input.value,\n            range: this._rangeMode,\n            samples: this.samples\n          };\n        }\n      }]), Linear;\n    }(ut),\n        wr = [\"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\", \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\", \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkgrey\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\", \"darkslategray\", \"darkslategrey\", \"darkturquoise\", \"darkviolet\", \"deeppink\", \"deepskyblue\", \"dimgray\", \"dimgrey\", \"dodgerblue\", \"firebrick\", \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\", \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"grey\", \"honeydew\", \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\", \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightgrey\", \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightslategrey\", \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\", \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\", \"slategrey\", \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\", \"tomato\", \"transparent\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\", \"yellow\", \"yellowgreen\"],\n        Cr = function (e) {\n      function NamedColor(e) {\n        var t;\n\n        if (p()(this, NamedColor), checkMaxArguments(arguments, 1, \"namedColor\"), checkString(\"namedColor\", \"colorName\", 0, e), !wr.includes(e.toLowerCase())) {\n          var r = getStringErrorPreface(\"namedColor\", \"colorName\", 0);\n          throw new he(\"\".concat(r, \"\\nInvalid color name:  '\").concat(e, \"'\"), de.INCORRECT_VALUE);\n        }\n\n        return (t = N()(this, R()(NamedColor).call(this, {}))).type = \"color\", t.name = e, t.expressionName = e, t.color = function _nameToRGBA(e) {\n          if (Er[e]) return Er[e];\n          var t = document.createElement(\"div\");\n          t.style.backgroundColor = e, document.body.appendChild(t);\n          var r = getComputedStyle(t).backgroundColor;\n          document.body.removeChild(t);\n          var n = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.exec(r),\n              a = {\n            r: Number(n[1]),\n            g: Number(n[2]),\n            b: Number(n[3]),\n            a: Number(n[4] || 1)\n          };\n          return Er[e] = a, a;\n        }(t.name), t.inlineMaker = function () {\n          return \"vec4(\".concat((t.color.r / 255).toFixed(4), \", \").concat((t.color.g / 255).toFixed(4), \", \").concat((t.color.b / 255).toFixed(4), \", \").concat(t.color.a.toFixed(4), \")\");\n        }, t;\n      }\n\n      return O()(NamedColor, e), v()(NamedColor, [{\n        key: \"toString\",\n        value: function toString() {\n          return this.expressionName;\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          return {\n            name: \"color\",\n            data: [{\n              key: \"color\",\n              value: this.color\n            }]\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.color;\n        }\n      }]), NamedColor;\n    }(ut),\n        Er = {};\n\n    var Mr = r(16),\n        Ar = r.n(Mr),\n        Sr = function (e) {\n      function Now() {\n        var e;\n        return p()(this, Now), checkMaxArguments(arguments, 0, \"now\"), (e = N()(this, R()(Now).call(this, {\n          now: ba(0)\n        }))).type = \"number\", Ar()(R()(Now.prototype), \"inlineMaker\", function (e) {\n          return e.now;\n        }, Vt()(e), !0), e;\n      }\n\n      return O()(Now, e), v()(Now, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !0;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return !0;\n        }\n      }, {\n        key: \"_setTimestamp\",\n        value: function _setTimestamp(e) {\n          this.now.value = e;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.now.value;\n        }\n      }]), Now;\n    }(ut),\n        Pr = function (e) {\n      function BaseNumber(e) {\n        var t;\n        return p()(this, BaseNumber), checkMaxArguments(arguments, 1, \"number\"), checkNumber(\"number\", \"x\", 0, e), (t = N()(this, R()(BaseNumber).call(this, {})))._value = e, t.type = \"number\", t;\n      }\n\n      return O()(BaseNumber, e), v()(BaseNumber, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.value);\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !1;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return !1;\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource() {\n          return {\n            preface: this._prefaceCode(\"uniform float number\".concat(this._uid, \";\")),\n            inline: \"number\".concat(this._uid)\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._getBinding(e).uniformLocation = t.getUniformLocation(e, \"number\".concat(this._uid));\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          r.uniform1f(this._getBinding(e).uniformLocation, this.value);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        },\n        set: function set(e) {\n          this._value = e;\n        }\n      }]), BaseNumber;\n    }(ut),\n        Ir = r(14),\n        Nr = r.n(Ir),\n        Dr = function (e) {\n      function Opacity(e, t) {\n        var r;\n        return p()(this, Opacity), checkMaxArguments(arguments, 2, \"opacity\"), e = implicitCast(e), t = implicitCast(t), checkExpression(\"opacity\", \"input\", 0, e), checkExpression(\"opacity\", \"alpha\", 1, t), (r = N()(this, R()(Opacity).call(this, {\n          input: e,\n          alpha: t\n        }))).inlineMaker = function (e) {\n          return \"vec4((\".concat(e.input, \").rgb, \").concat(e.alpha, \")\");\n        }, r;\n      }\n\n      return O()(Opacity, e), v()(Opacity, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.input.eval(e),\n              r = this.alpha.eval(e);\n          return t.a = r, t;\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          var t = this.input.getLegendData(e),\n              r = this.alpha.value;\n\n          if (\"color\" === this.input.type) {\n            var n = t.data.map(function (e) {\n              var t = e.key,\n                  n = e.value;\n              return {\n                key: t,\n                value: {\n                  r: n.r,\n                  g: n.g,\n                  b: n.b,\n                  a: r\n                }\n              };\n            });\n            return Nr()({}, t, {\n              data: n\n            });\n          }\n\n          var a = t.data;\n          return Nr()({}, t, {\n            data: a,\n            alpha: r\n          });\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Opacity.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"opacity\", \"input\", 0, [\"color\", \"image\"], this.input), checkType(\"opacity\", \"alpha\", 1, \"number\", this.alpha), this.type = this.input.type;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          var e = this.input.value,\n              t = this.alpha.value;\n          return e.a = t, e;\n        }\n      }]), Opacity;\n    }(ut),\n        Rr = function (e) {\n      function Asc(e) {\n        var t;\n        return p()(this, Asc), checkMaxArguments(arguments, 1, \"asc\"), checkExpression(\"asc\", \"input\", 0, e = implicitCast(e)), (t = N()(this, R()(Asc).call(this, {\n          input: e\n        }))).type = \"orderer\", t;\n      }\n\n      return O()(Asc, e), v()(Asc, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Asc.prototype), \"_bindMetadata\", this).call(this, e), checkInstance(\"asc\", \"input\", 0, Br, this.input);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return \"asc\";\n        }\n      }]), Asc;\n    }(ut),\n        Fr = function (e) {\n      function Desc(e) {\n        var t;\n        return p()(this, Desc), checkMaxArguments(arguments, 1, \"desc\"), checkExpression(\"desc\", \"input\", 0, e = implicitCast(e)), (t = N()(this, R()(Desc).call(this, {\n          input: e\n        }))).type = \"orderer\", t;\n      }\n\n      return O()(Desc, e), v()(Desc, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Desc.prototype), \"_bindMetadata\", this).call(this, e), checkInstance(\"desc\", \"input\", 0, Br, this.input);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return \"desc\";\n        }\n      }]), Desc;\n    }(ut),\n        Lr = function (e) {\n      function NoOrder() {\n        var e;\n        return p()(this, NoOrder), checkMaxArguments(arguments, 0, \"noOrder\"), (e = N()(this, R()(NoOrder).call(this, {}))).type = \"orderer\", e;\n      }\n\n      return O()(NoOrder, e), v()(NoOrder, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return \"noOrder\";\n        }\n      }]), NoOrder;\n    }(ut),\n        Br = function (e) {\n      function Width() {\n        var e;\n        return p()(this, Width), checkMaxArguments(arguments, 1, \"width\"), (e = N()(this, R()(Width).call(this, {}))).type = \"propertyReference\", e;\n      }\n\n      return O()(Width, e), Width;\n    }(ut),\n        Vr = r(22),\n        Gr = genRGB(\"rgb\", !1),\n        Ur = genRGB(\"rgba\", !0);\n\n    function genRGB(e, t) {\n      return function (r) {\n        function RGBA(r, n, a, i) {\n          var o;\n          p()(this, RGBA), checkMaxArguments(arguments, 4, \"rgba\");\n          var u = [r, n, a, i].map(implicitCast),\n              s = g()(u, 4);\n          r = s[0], n = s[1], a = s[2], i = s[3], checkExpression(e, \"r\", 0, r), checkExpression(e, \"g\", 1, n), checkExpression(e, \"b\", 2, a);\n          var c = {\n            r: r,\n            g: n,\n            b: a\n          };\n          return t && (checkExpression(e, \"a\", 3, i), c.a = i), (o = N()(this, R()(RGBA).call(this, c))).type = \"color\", o.inlineMaker = function (e) {\n            return \"vec4(\".concat(e.r, \"/255., \").concat(e.g, \"/255., \").concat(e.b, \"/255., \").concat(t ? e.a : \"1.\", \")\");\n          }, o;\n        }\n\n        return O()(RGBA, r), v()(RGBA, [{\n          key: \"eval\",\n          value: function _eval() {\n            return this.value;\n          }\n        }, {\n          key: \"getLegendData\",\n          value: function getLegendData() {\n            return {\n              name: \"color\",\n              data: [{\n                key: \"color\",\n                value: this.value\n              }]\n            };\n          }\n        }, {\n          key: \"_bindMetadata\",\n          value: function _bindMetadata(r) {\n            lt()(R()(RGBA.prototype), \"_bindMetadata\", this).call(this, r), checkType(e, \"r\", 0, \"number\", this.r), checkType(e, \"g\", 1, \"number\", this.g), checkType(e, \"b\", 2, \"number\", this.b), t && checkType(\"rgba\", \"a\", 3, \"number\", this.a);\n          }\n        }, {\n          key: \"value\",\n          get: function get() {\n            return {\n              r: this.r.value,\n              g: this.g.value,\n              b: this.b.value,\n              a: t ? this.a.value : 1\n            };\n          }\n        }]), RGBA;\n      }(ut);\n    }\n\n    var zr = function (e) {\n      function Palette(e, t) {\n        var r;\n        return p()(this, Palette), (r = N()(this, R()(Palette).call(this, {}))).type = \"palette\", r.childType = \"color\", r.name = e, r.subPalettes = new Proxy(t, {\n          get: function get(e, t) {\n            if (\"symbol\" !== h()(t) && Number.isSafeInteger(Number(t)) && Array.isArray(e[t])) return e[t].map(hexToRgb);\n          }\n        }), r.expressionName = e, r.tags = t.tags, r;\n      }\n\n      return O()(Palette, e), v()(Palette, [{\n        key: \"getColors\",\n        value: function getColors(e) {\n          var t = this._getBestSubPalette(e);\n\n          return this.isQualitative() ? {\n            colors: t,\n            othersColor: t.pop()\n          } : {\n            colors: t,\n            othersColor: null\n          };\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return this.expressionName;\n        }\n      }, {\n        key: \"_getBestSubPalette\",\n        value: function _getBestSubPalette(e) {\n          e = e <= 2 ? 2 : e;\n          var t = this.getLongestSubPalette();\n          return (e < t.length ? l()(this.subPalettes[e]) : l()(t)).map(function (e) {\n            return new Ur(ii(e.r), ii(e.g), ii(e.b), ii(e.a));\n          });\n        }\n      }, {\n        key: \"getLongestSubPalette\",\n        value: function getLongestSubPalette() {\n          for (var e = this.subPalettes, t = 20; t >= 0; t--) if (e[t]) return e[t];\n        }\n      }, {\n        key: \"isQualitative\",\n        value: function isQualitative() {\n          return this.tags.includes(\"qualitative\");\n        }\n      }, {\n        key: \"isQuantitative\",\n        value: function isQuantitative() {\n          return this.tags.includes(\"quantitative\");\n        }\n      }]), Palette;\n    }(ut),\n        qr = {};\n\n    Object.keys(Vr).map(function (e) {\n      qr[\"\".concat(e.toUpperCase())] = new zr(e, Vr[e]);\n    });\n\n    var jr = qr,\n        Wr = function (e) {\n      function ReversePalette() {\n        return p()(this, ReversePalette), N()(this, R()(ReversePalette).apply(this, arguments));\n      }\n\n      return O()(ReversePalette, e), v()(ReversePalette, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = this;\n          this.type = \"palette\", this.childType = \"color\", this.subPalettes = new Proxy(this.input.subPalettes, {\n            get: function get(e, r) {\n              return Number.isFinite(Number(r)) && Array.isArray(e[r]) ? t._reversePalette(e[r]) : e[r];\n            }\n          }), this.tags = this.input.tags;\n        }\n      }, {\n        key: \"getLongestSubPalette\",\n        value: function getLongestSubPalette() {\n          return this._reversePalette(this.input.getLongestSubPalette());\n        }\n      }, {\n        key: \"_reversePalette\",\n        value: function _reversePalette(e) {\n          if (this.isQualitative()) {\n            var t = l()(e),\n                r = t.pop();\n            return l()(t.reverse()).concat([r]);\n          }\n\n          return l()(e).reverse();\n        }\n      }]), ReversePalette;\n    }(zr),\n        Hr = function (e) {\n      function ReverseList() {\n        return p()(this, ReverseList), N()(this, R()(ReverseList).apply(this, arguments));\n      }\n\n      return O()(ReverseList, e), v()(ReverseList, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          checkType(\"reverse\", \"array\", 0, [\"number-list\", \"category-list\", \"color-list\", \"date-list\", \"image-list\"], this.input), this.type = this.input.type, this.childType = this.input.childType;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.elems.map(function (t) {\n            return t.eval(e);\n          });\n        }\n      }, {\n        key: \"elems\",\n        get: function get() {\n          return l()(this.input.elems).reverse();\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.elems.map(function (e) {\n            return e.value;\n          });\n        }\n      }]), ReverseList;\n    }(ut),\n        Yr = function (e) {\n      function Reverse(e) {\n        return p()(this, Reverse), checkMaxArguments(arguments, 1, \"reverse\"), checkExpression(\"reverse\", \"input\", 0, e = implicitCast(e)), N()(this, R()(Reverse).call(this, {\n          input: e\n        }));\n      }\n\n      return O()(Reverse, e), v()(Reverse, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          return lt()(R()(Reverse.prototype), \"_bindMetadata\", this).call(this, e), \"palette\" === this.input.type ? Object.setPrototypeOf(this, Wr.prototype) : Object.setPrototypeOf(this, Hr.prototype), this._bindMetadata(e);\n        }\n      }]), Reverse;\n    }(ut),\n        Zr = function () {\n      function ClassifierGLSLHelper(e) {\n        p()(this, ClassifierGLSLHelper), this.classifier = e;\n      }\n\n      return v()(ClassifierGLSLHelper, [{\n        key: \"applyToShaderSource\",\n        value: function applyToShaderSource(e) {\n          var t = this,\n              r = this.classifier.childrenNames.map(function (r) {\n            return t.classifier[r]._applyToShaderSource(e);\n          }),\n              n = {};\n          r.map(function (e, r) {\n            n[t.classifier.childrenNames[r]] = e.inline;\n          });\n          var a = \"classifier\".concat(this.classifier.classifierUID),\n              i = this.classifier.numCategories - 1 || 1,\n              o = this.classifier.breakpoints ? this.classifier.breakpoints.map(function elif(e, t) {\n            return \"\".concat(t > 0 ? \"else\" : \"\", \" if (x<(\").concat(n[\"arg\".concat(t)], \")){\\n                return \").concat((t / i).toFixed(20), \";\\n            }\");\n          }).join(\"\") : \"\",\n              u = \"float \".concat(a, \"(float x){\\n            \").concat(o, \"\\n            return 1.;\\n        }\");\n          return {\n            preface: this.classifier._prefaceCode(r.map(function (e) {\n              return e.preface;\n            }).reduce(function (e, t) {\n              return e + t;\n            }, \"\") + u),\n            inline: \"\".concat(a, \"(\").concat(n.input, \")\")\n          };\n        }\n      }]), ClassifierGLSLHelper;\n    }(),\n        Xr = 1e3,\n        Qr = 0,\n        $r = function (e) {\n      function Classifier(e) {\n        var t;\n        return p()(this, Classifier), (t = N()(this, R()(Classifier).call(this, e))).classifierUID = Qr++, t.type = \"category\", t._GLSLhelper = new Zr(Vt()(Vt()(t))), t;\n      }\n\n      return O()(Classifier, e), v()(Classifier, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.input.eval(e),\n              r = this.breakpoints.findIndex(function (e) {\n            return t <= e.value;\n          }),\n              n = this.numCategories - 1 || 1;\n          return -1 === r ? 1 : r / n;\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"(\").concat(this.input.toString(), \", \").concat(this.numCategories, \")\");\n        }\n      }, {\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          lt()(R()(Classifier.prototype), \"_resolveAliases\", this).call(this, e), this._bucketsInitialization();\n        }\n      }, {\n        key: \"_bucketsInitialization\",\n        value: function _bucketsInitialization() {\n          this._validateBucketsIsProperNumber();\n\n          var e = this.buckets.value;\n          this.numCategories = e, this.numCategoriesWithoutOthers = e, this._initBreakpointsChildren(e);\n        }\n      }, {\n        key: \"_initBreakpointsChildren\",\n        value: function _initBreakpointsChildren(e) {\n          this.breakpoints = this._breakpointsWithZeros(e);\n          var t = this.breakpoints.reduce(function (e, t, r) {\n            return e[\"arg\".concat(r)] = t, e;\n          }, {});\n\n          this._initializeChildren(t);\n        }\n      }, {\n        key: \"_breakpointsWithZeros\",\n        value: function _breakpointsWithZeros(e) {\n          for (var t = [], r = 0; r < e - 1; r++) t.push(ba(0));\n\n          return t;\n        }\n      }, {\n        key: \"_validateBucketsIsProperNumber\",\n        value: function _validateBucketsIsProperNumber() {\n          var e = this.buckets.value;\n          if (checkNumber(this.expressionName, \"buckets\", 1, e), e <= 1) throw new he(\"The number of 'buckets' must be >=2, but \".concat(e, \" was used\"), de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Classifier.prototype), \"_bindMetadata\", this).call(this, e), this._validateInputIsNumericProperty();\n        }\n      }, {\n        key: \"_validateInputIsNumericProperty\",\n        value: function _validateInputIsNumericProperty() {\n          checkType(this.expressionName, \"input\", 0, \"number\", this.input);\n        }\n      }, {\n        key: \"_getBreakpointList\",\n        value: function _getBreakpointList() {\n          return this._genBreakpoints(), this.breakpoints.map(function (e) {\n            return e.value;\n          });\n        }\n      }, {\n        key: \"_genBreakpoints\",\n        value: function _genBreakpoints() {}\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          return this._GLSLhelper ? this._GLSLhelper.applyToShaderSource(e) : null;\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          this._genBreakpoints(), lt()(R()(Classifier.prototype), \"_preDraw\", this).call(this, e, t, r);\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          for (var e = this._getBreakpointList(), t = e.length, r = this.min.value, n = this.max.value, a = [], i = 0; i <= t; i++) {\n            var o = [0 === e[i - 1] ? 0 : e[i - 1] || r, 0 === e[i] ? 0 : e[i] || n],\n                u = i / t;\n            a.push({\n              key: o,\n              value: u\n            });\n          }\n\n          return {\n            name: this.toString(),\n            data: a\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval();\n        }\n      }]), Classifier;\n    }(ut),\n        Jr = function (e) {\n      function GlobalEqIntervals(e, t) {\n        return p()(this, GlobalEqIntervals), checkExactNumberOfArguments(arguments, 2, \"globalEqIntervals\"), N()(this, R()(GlobalEqIntervals).call(this, {\n          input: e,\n          buckets: t\n        }));\n      }\n\n      return O()(GlobalEqIntervals, e), v()(GlobalEqIntervals, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(GlobalEqIntervals.prototype), \"_bindMetadata\", this).call(this, e), this._updateBreakpointsWith(e);\n        }\n      }, {\n        key: \"_updateBreakpointsWith\",\n        value: function _updateBreakpointsWith(e) {\n          var t = this;\n          if (\"_cdb_feature_count\" === this.input.propertyName) throw new he(\"'clusterCount' can not be used in GlobalEqIntervals. Consider using ViewportEqIntervals instead\", de.INCORRECT_TYPE);\n          var r = this.input.name,\n              n = e.stats(r),\n              a = n.min,\n              i = n.max;\n          this.min = ba(a), this.max = ba(i), this.breakpoints.map(function (e, r) {\n            var n = (r + 1) / t.numCategories;\n            e.value = a + (i - a) * n;\n          });\n        }\n      }]), GlobalEqIntervals;\n    }($r),\n        Kr = function (e) {\n      function GlobalQuantiles(e, t) {\n        return p()(this, GlobalQuantiles), checkExactNumberOfArguments(arguments, 2, \"globalQuantiles\"), N()(this, R()(GlobalQuantiles).call(this, {\n          input: e,\n          buckets: t\n        }));\n      }\n\n      return O()(GlobalQuantiles, e), v()(GlobalQuantiles, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(GlobalQuantiles.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"globalQuantiles\", \"input\", 0, \"number\", this.input), this._updateBreakpointsWith(e);\n        }\n      }, {\n        key: \"_validateInputIsNumericProperty\",\n        value: function _validateInputIsNumericProperty() {}\n      }, {\n        key: \"_updateBreakpointsWith\",\n        value: function _updateBreakpointsWith(e) {\n          var t = this;\n          if (\"_cdb_feature_count\" === this.input.propertyName) throw new he(\"'clusterCount' can not be used in GlobalQuantiles. Consider using ViewportQuantiles instead\", de.INCORRECT_TYPE);\n          var r = this.input.name,\n              n = e.stats(r),\n              a = n.min,\n              i = n.max,\n              o = e.sample.map(function (e) {\n            return e[r];\n          });\n          this.min = ba(a), this.max = ba(i), o.sort(function (e, t) {\n            return e - t;\n          }), this.breakpoints = this.breakpoints.map(function (e, r) {\n            var n = (r + 1) / t.numCategories;\n            return e.value = o[Math.floor(n * o.length)], e;\n          });\n        }\n      }]), GlobalQuantiles;\n    }($r),\n        en = function (e) {\n      function GlobalStandardDev(e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n        return p()(this, GlobalStandardDev), checkMinArguments(arguments, 2, \"globalStandardDev\"), checkMaxArguments(arguments, 3, \"globalStandardDev\"), N()(this, R()(GlobalStandardDev).call(this, {\n          input: e,\n          buckets: t,\n          _classSize: r\n        }));\n      }\n\n      return O()(GlobalStandardDev, e), v()(GlobalStandardDev, [{\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          lt()(R()(GlobalStandardDev.prototype), \"_resolveAliases\", this).call(this, e), this._validateClassSizeIsProperNumber();\n        }\n      }, {\n        key: \"_validateClassSizeIsProperNumber\",\n        value: function _validateClassSizeIsProperNumber() {\n          var e = this._classSize.value;\n          if (checkNumber(this.expressionName, \"classSize\", 2, e), e <= 0) throw new he(\"The 'classSize' must be > 0.0, but \".concat(e, \" was used.\"), de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(GlobalStandardDev.prototype), \"_bindMetadata\", this).call(this, e), this._updateBreakpointsWith(e);\n        }\n      }, {\n        key: \"_updateBreakpointsWith\",\n        value: function _updateBreakpointsWith(e) {\n          if (\"_cdb_feature_count\" === this.input.propertyName) throw new he(\"'clusterCount' can not be used in GlobalStandardDev. Consider using ViewportStandardDev instead\", de.INCORRECT_TYPE);\n\n          var t = this.input.name,\n              r = e.sample.map(function (e) {\n            return e[t];\n          }),\n              n = fe(r),\n              a = function standardDeviation(e) {\n            var t = fe(e),\n                r = fe(function variance(e, t) {\n              for (var r = [], n = 0; n < e.length; n++) {\n                var a = e[n] - t;\n                r.push(a * a);\n              }\n\n              return r;\n            }(e, t));\n            return Math.sqrt(r);\n          }(r),\n              i = e.stats(t),\n              o = i.min,\n              u = i.max;\n\n          this.min = ba(o), this.max = ba(u);\n          var s = calculateBreakpoints(n, a, this.numCategories, this._classSize.value);\n          this.breakpoints.forEach(function (e, t) {\n            e.value = s[t];\n          });\n        }\n      }]), GlobalStandardDev;\n    }($r);\n\n    function calculateBreakpoints(e, t, r, n) {\n      if (0 === t || isNaN(t)) throw new Ae(\"There is no Standard Deviation, not possible to compute \".concat(r, \" buckets (just one feature or maybe all share the same value...?)\"), Se.NOT_SUPPORTED);\n      var a,\n          i = [],\n          o = [],\n          u = r % 2 == 0 ? 0 : 1;\n\n      do {\n        var s = u * (t * n);\n        i.push(e + s), o.push(e - s), (a = l()(new Set(i.concat(o)))).sort(function (e, t) {\n          return e - t;\n        }), u++;\n      } while (a.length < r - 1);\n\n      return a;\n    }\n\n    var tn = function (e) {\n      function ViewportEqIntervals(e, t) {\n        return p()(this, ViewportEqIntervals), checkExactNumberOfArguments(arguments, 2, \"viewportEqIntervals\"), N()(this, R()(ViewportEqIntervals).call(this, {\n          input: e,\n          buckets: t\n        }));\n      }\n\n      return O()(ViewportEqIntervals, e), v()(ViewportEqIntervals, [{\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          lt()(R()(ViewportEqIntervals.prototype), \"_resolveAliases\", this).call(this, e), this._minMaxInitialization();\n        }\n      }, {\n        key: \"_minMaxInitialization\",\n        value: function _minMaxInitialization() {\n          var e = this.input,\n              t = {\n            min: $i(e),\n            max: Qi(e)\n          };\n\n          this._initializeChildren(t);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ViewportEqIntervals.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"viewportEqIntervals\", \"input\", 0, \"number\", this.input);\n        }\n      }, {\n        key: \"_validateInputIsNumericProperty\",\n        value: function _validateInputIsNumericProperty() {}\n      }, {\n        key: \"_genBreakpoints\",\n        value: function _genBreakpoints() {\n          var e = this,\n              t = this.min.value,\n              r = this.max.value;\n          this.breakpoints.map(function (n, a) {\n            var i = (a + 1) / e.numCategories;\n            n.value = t + (r - t) * i;\n          });\n        }\n      }]), ViewportEqIntervals;\n    }($r),\n        rn = function (e) {\n      function ViewportQuantiles(e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Xr;\n        return p()(this, ViewportQuantiles), checkMinArguments(arguments, 2, \"viewportQuantiles\"), checkMaxArguments(arguments, 3, \"viewportQuantiles\"), e = implicitCast(e), N()(this, R()(ViewportQuantiles).call(this, {\n          input: e,\n          buckets: t,\n          _histogramSize: r\n        }));\n      }\n\n      return O()(ViewportQuantiles, e), v()(ViewportQuantiles, [{\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          lt()(R()(ViewportQuantiles.prototype), \"_resolveAliases\", this).call(this, e), this._histogramInitialization();\n        }\n      }, {\n        key: \"_histogramInitialization\",\n        value: function _histogramInitialization() {\n          this._validateHistogramSizeIsProperNumber();\n\n          var e = this.input,\n              t = this._histogramSize.value,\n              r = {\n            min: $i(e),\n            max: Qi(e),\n            _histogram: to(e, t)\n          };\n\n          this._initializeChildren(r);\n        }\n      }, {\n        key: \"_validateHistogramSizeIsProperNumber\",\n        value: function _validateHistogramSizeIsProperNumber() {\n          var e = this._histogramSize.value;\n          if (checkNumber(this.expressionName, \"histogramSize\", 2, e), e <= 0) throw new he(\"The 'histogramSize' must be > 0, but \".concat(e, \" was used\"), de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ViewportQuantiles.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"viewportQuantiles\", \"input\", 0, \"number\", this.input);\n        }\n      }, {\n        key: \"_validateInputIsNumericProperty\",\n        value: function _validateInputIsNumericProperty() {}\n      }, {\n        key: \"_genBreakpoints\",\n        value: function _genBreakpoints() {\n          var e = this._histogram.value;\n\n          if (e) {\n            var t = this._getAccumHistogramFrom(e),\n                r = this._getMinMaxFrom(e),\n                n = g()(r, 2),\n                a = n[0],\n                i = n[1];\n\n            this._updateBreakpointsWith({\n              accumHistogram: t,\n              min: a,\n              max: i\n            });\n          }\n        }\n      }, {\n        key: \"_updateBreakpointsWith\",\n        value: function _updateBreakpointsWith(e) {\n          var t = this,\n              r = e.accumHistogram,\n              n = e.min,\n              a = e.max,\n              i = r.length,\n              o = 0,\n              u = r[i - 1];\n          this.breakpoints.map(function (e, s) {\n            for (; o < i && !(r[o] > (s + 1) / t.numCategories * u); o++);\n\n            var c = o / i * (a - n) + n;\n            e.value = c;\n          });\n        }\n      }, {\n        key: \"_getAccumHistogramFrom\",\n        value: function _getAccumHistogramFrom(e) {\n          var t = 0;\n          return e.map(function (e) {\n            var r = e.y;\n            return t += r;\n          });\n        }\n      }, {\n        key: \"_getMinMaxFrom\",\n        value: function _getMinMaxFrom(e) {\n          return [e[0].x[0], e[e.length - 1].x[1]];\n        }\n      }]), ViewportQuantiles;\n    }($r),\n        nn = function (e) {\n      function ViewportStandardDev(e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n            n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Xr;\n        return p()(this, ViewportStandardDev), checkMinArguments(arguments, 2, \"viewportStandardDev\"), checkMaxArguments(arguments, 4, \"viewportStandardDev\"), N()(this, R()(ViewportStandardDev).call(this, {\n          input: e,\n          buckets: t,\n          _classSize: r,\n          _histogramSize: n\n        }));\n      }\n\n      return O()(ViewportStandardDev, e), v()(ViewportStandardDev, [{\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          lt()(R()(ViewportStandardDev.prototype), \"_resolveAliases\", this).call(this, e), this._validateClassSizeIsProperNumber(), this._histogramInitialization();\n        }\n      }, {\n        key: \"_histogramInitialization\",\n        value: function _histogramInitialization() {\n          this._validateHistogramSizeIsProperNumber();\n\n          var e = this.input,\n              t = this._histogramSize.value,\n              r = {\n            min: $i(e),\n            max: Qi(e),\n            _histogram: to(e, t)\n          };\n\n          this._initializeChildren(r);\n        }\n      }, {\n        key: \"_validateClassSizeIsProperNumber\",\n        value: function _validateClassSizeIsProperNumber() {\n          var e = this._classSize.value;\n          if (checkNumber(this.expressionName, \"classSize\", 2, e), e <= 0) throw new he(\"The 'classSize' must be > 0.0, but \".concat(e, \" was used.\"), de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_validateHistogramSizeIsProperNumber\",\n        value: function _validateHistogramSizeIsProperNumber() {\n          var e = this._histogramSize.value;\n          if (checkNumber(this.expressionName, \"histogramSize\", 3, e), e <= 0) throw new he(\"The 'histogramSize' must be > 0, but \".concat(e, \" was used\"), de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ViewportStandardDev.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"viewportStandardDev\", \"input\", 0, \"number\", this.input);\n        }\n      }, {\n        key: \"_validateInputIsNumericProperty\",\n        value: function _validateInputIsNumericProperty() {}\n      }, {\n        key: \"_genBreakpoints\",\n        value: function _genBreakpoints() {\n          var e = this._histogram.value;\n\n          if (void 0 !== e) {\n            var t = this._getAverageFrom(e),\n                r = this._getStandardDevFrom(e, t);\n\n            this._updateBreakpointsWith({\n              avg: t,\n              stdev: r\n            });\n          }\n        }\n      }, {\n        key: \"_updateBreakpointsWith\",\n        value: function _updateBreakpointsWith(e) {\n          var t = calculateBreakpoints(e.avg, e.stdev, this.numCategories, this._classSize.value);\n          this.breakpoints.forEach(function (e, r) {\n            e.value = t[r];\n          });\n        }\n      }, {\n        key: \"_getAverageFrom\",\n        value: function _getAverageFrom(e) {\n          var t = 0,\n              r = 0;\n          return e.forEach(function (e) {\n            var n = e.x,\n                a = e.y;\n            t += a;\n            var i = (n[0] + n[1]) / 2;\n            r += i * a;\n          }), r / t;\n        }\n      }, {\n        key: \"_getStandardDevFrom\",\n        value: function _getStandardDevFrom(e, t) {\n          var r = 0,\n              n = 0;\n          e.forEach(function (e) {\n            var a = e.x,\n                i = e.y;\n            r += i;\n            var o = (a[0] + a[1]) / 2 - t;\n            n += i * o * o;\n          });\n          var a = n / r;\n          return Math.sqrt(a);\n        }\n      }]), ViewportStandardDev;\n    }($r),\n        an = \"https://libs.cartocdn.com/carto-vl/assets/symbols\",\n        un = {\n      bicycle: \"\".concat(an, \"/bicycle.svg\"),\n      building: \"\".concat(an, \"/building.svg\"),\n      bus: \"\".concat(an, \"/bus.svg\"),\n      car: \"\".concat(an, \"/car.svg\"),\n      circle: \"\".concat(an, \"/circle.svg\"),\n      circleOutline: \"\".concat(an, \"/circleOutline.svg\"),\n      cross: \"\".concat(an, \"/cross.svg\"),\n      house: \"\".concat(an, \"/house.svg\"),\n      flag: \"\".concat(an, \"/flag.svg\"),\n      marker: \"\".concat(an, \"/marker.svg\"),\n      markerOutline: \"\".concat(an, \"/markerOutline.svg\"),\n      plus: \"\".concat(an, \"/plus.svg\"),\n      square: \"\".concat(an, \"/square.svg\"),\n      squareOutline: \"\".concat(an, \"/squareOutline.svg\"),\n      star: \"\".concat(an, \"/star.svg\"),\n      starOutline: \"\".concat(an, \"/starOutline.svg\"),\n      triangle: \"\".concat(an, \"/triangle.svg\"),\n      triangleOutline: \"\".concat(an, \"/triangleOutline.svg\")\n    },\n        sn = 256,\n        cn = function (e) {\n      function CategoryIndex(e) {\n        var t;\n        return p()(this, CategoryIndex), checkMaxArguments(arguments, 1, \"categoryIndex\"), checkExpression(\"categoryIndex\", \"property\", 0, e = implicitCast(e)), (t = N()(this, R()(CategoryIndex).call(this, {\n          property: e\n        })))._numTranslatedCategories = null, t.type = \"category\", t._translatePixels = new Float32Array(sn * sn), t._translateArray = [], t._numTranslatedCategories = 0, t._numTranslatedCategoriesGL = 0, t;\n      }\n\n      return O()(CategoryIndex, e), v()(CategoryIndex, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(CategoryIndex.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"categoryIndex\", \"property\", 0, \"category\", this.property), this._metadata = e, this._calcTranslated();\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.property.eval(e),\n              r = this._metadata.categoryToID.get(t);\n\n          return this._translateArray[r];\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          r.activeTexture(r.TEXTURE0 + t.freeTexUnit), this._numTranslatedCategoriesGL !== this.numCategories ? (this._numTranslatedCategoriesGL = this.numCategories, this._calcTranslated(), this._translateTexture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this._translateTexture), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, sn, sn, 0, r.ALPHA, r.FLOAT, this._translatePixels), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE)) : r.bindTexture(r.TEXTURE_2D, this._translateTexture), r.uniform1i(this._getBinding(e).texRampTranslateLoc, t.freeTexUnit), t.freeTexUnit++;\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = sn.toFixed(20),\n              r = this.property._applyToShaderSource(e);\n\n          return {\n            inline: \"ramp_translate\".concat(this._uid, \"(\").concat(r.inline, \")\"),\n            preface: \"\\n                    uniform sampler2D texRampTranslate\".concat(this._uid, \";\\n                    float ramp_translate\").concat(this._uid, \"(float s){\\n                        vec2 v = vec2(mod(s, \").concat(t, \"), floor(s / \").concat(t, \"));\\n                        return texture2D(texRampTranslate\").concat(this._uid, \", v/\").concat(t, \").a;\\n                    }\")\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._getBinding(e).texRampTranslateLoc = t.getUniformLocation(e, \"texRampTranslate\".concat(this._uid));\n        }\n      }, {\n        key: \"_calcTranslated\",\n        value: function _calcTranslated() {\n          var e = this.numCategories;\n\n          if (this._numTranslatedCategories !== e) {\n            this._numTranslatedCategories = e;\n\n            for (var t = 0; t < e; t++) {\n              var r = this._metadata.categoryToID.get(this.metaColumn.categories[t].name),\n                  n = t / (e - 1),\n                  a = {\n                x: r % sn,\n                y: Math.floor(r / sn)\n              };\n\n              this._translatePixels[sn * a.y + a.x] = n, this._translateArray.push(n);\n            }\n          }\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData() {\n          for (var e = this._metadata.properties[this.property.propertyName].categories, t = e.length, r = t - 1, n = [], a = 0; a < t; a++) {\n            var i = e[a].name,\n                o = a / r;\n            n.push({\n              key: i,\n              value: o\n            });\n          }\n\n          return {\n            data: n\n          };\n        }\n      }, {\n        key: \"numCategories\",\n        get: function get() {\n          return this.metaColumn.categories.length;\n        }\n      }, {\n        key: \"metaColumn\",\n        get: function get() {\n          var e = this.property.propertyName;\n          return this._metadata.properties[e] ? this._metadata.properties[e] : this._metadata.properties[this.property.name];\n        }\n      }, {\n        key: \"numCategoriesWithoutOthers\",\n        get: function get() {\n          return this.numCategories;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval();\n        }\n      }]), CategoryIndex;\n    }(ut),\n        ln = function (e) {\n      function ListImage() {\n        return p()(this, ListImage), N()(this, R()(ListImage).apply(this, arguments));\n      }\n\n      return O()(ListImage, e), v()(ListImage, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ListImage.prototype), \"_bindMetadata\", this).call(this, e), this.numImages = this.elems.length, this._getChildren().forEach(function (e, t) {\n            return checkType(\"imageArray\", \"imageArray[\".concat(t, \"]\"), 0, \"image\", e);\n          });\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.elems.map(function (t) {\n            return t.eval(e);\n          });\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource() {\n          return {\n            preface: this._prefaceCode(\"\\n                uniform sampler2D atlas\".concat(this._uid, \";\\n\\n                vec4 atlas\").concat(this._uid, \"Fn(vec2 imageUV, float category) {\\n                    return texture2D(atlas\").concat(this._uid, \", imageUV/16. + vec2(mod(category, 16.), floor(category/16.))/16. ).rgba;\\n                }\\n            \")),\n            inline: \"atlas\".concat(this._uid, \"Fn\")\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._getBinding(e).texLoc = t.getUniformLocation(e, \"atlas\".concat(this._uid));\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          this.init = !0;\n\n          for (var n = 0; n < this.numImages; n++) {\n            var a = this[\"image-\".concat(n)];\n            this.init = this.init && a.canvas;\n          }\n\n          if (this.init && !this.texture) {\n            r.activeTexture(r.TEXTURE0 + t.freeTexUnit), this.texture = r.createTexture(), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.bindTexture(r.TEXTURE_2D, this.texture), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, 4096, 4096, 0, r.RGBA, r.UNSIGNED_BYTE, null), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE);\n\n            for (var i = 0, o = 0, u = 0; u < this.numImages; u++) {\n              var s = this[\"image-\".concat(u)];\n              r.texSubImage2D(r.TEXTURE_2D, 0, i, o, r.RGBA, r.UNSIGNED_BYTE, s.canvas), (i += 256) + 256 > 4096 && (i = 0, o += 256);\n            }\n\n            r.generateMipmap(r.TEXTURE_2D);\n          }\n\n          this.texture && (r.activeTexture(r.TEXTURE0 + t.freeTexUnit), r.bindTexture(r.TEXTURE_2D, this.texture), r.uniform1i(this._getBinding(e).texLoc, t.freeTexUnit), t.freeTexUnit++);\n        }\n      }]), ListImage;\n    }(ut),\n        fn = function (e) {\n      function Image(e) {\n        var t;\n        return p()(this, Image), checkMaxArguments(arguments, 1, \"image\"), checkString(\"image\", \"url\", 0, e), (t = N()(this, R()(Image).call(this, {}))).type = \"image\", t.canvas = null, t.url = e, t._promise = new Promise(function (e, r) {\n          t.image = new window.Image(), t.image.onload = function () {\n            t.canvas = function _getCanvasFromImage(e) {\n              var t = document.createElement(\"canvas\");\n              t.width = 256, t.height = 256;\n              var r = t.getContext(\"2d\"),\n                  n = Math.max(e.width, e.height),\n                  a = e.width / n * 256,\n                  i = e.height / n * 256;\n              return r.drawImage(e, (256 - a) / 2, (256 - i) / 2, a, i), t;\n            }(t.image), t.image = null, e();\n          }, t.image.onerror = r, t.image.crossOrigin = \"anonymous\", t.image.src = t.url;\n        }), t;\n      }\n\n      return O()(Image, e), v()(Image, [{\n        key: \"loadImages\",\n        value: function loadImages() {\n          return this.count = this.count + 1 || 1, this._promise;\n        }\n      }, {\n        key: \"keepDefaultsOnBlend\",\n        value: function keepDefaultsOnBlend() {\n          this.default && this.parent.color.default && (this.parent.color = noOverrideColor());\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          return {\n            name: \"image\",\n            data: [{\n              key: \"url\",\n              value: this.url\n            }]\n          };\n        }\n      }, {\n        key: \"_free\",\n        value: function _free(e) {\n          this.texture && e.deleteTexture(this.texture);\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource() {\n          return {\n            preface: this._prefaceCode(\"uniform sampler2D texSprite\".concat(this._uid, \";\")),\n            inline: \"texture2D(texSprite\".concat(this._uid, \", imageUV).rgba\")\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._getBinding(e)._texLoc = t.getUniformLocation(e, \"texSprite\".concat(this._uid));\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          !this.init && this.canvas && (this.init = !0, r.activeTexture(r.TEXTURE0 + t.freeTexUnit), this.texture = r.createTexture(), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), r.bindTexture(r.TEXTURE_2D, this.texture), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, this.canvas), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.generateMipmap(r.TEXTURE_2D), this.canvas = null), this.texture && (r.activeTexture(r.TEXTURE0 + t.freeTexUnit), r.bindTexture(r.TEXTURE_2D, this.texture), r.uniform1i(this._getBinding(e)._texLoc, t.freeTexUnit), t.freeTexUnit++);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.url;\n        }\n      }]), Image;\n    }(ut);\n\n    var hn = new fn(un.circle),\n        dn = function (e) {\n      function RampImage() {\n        return p()(this, RampImage), N()(this, R()(RampImage).apply(this, arguments));\n      }\n\n      return O()(RampImage, e), v()(RampImage, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          ut.prototype._bindMetadata.call(this, e), this.type = this.palette.childType, checkType(\"ramp\", \"input\", 0, \"category\", this.input), checkInstance(\"ramp\", \"palette\", 1, ln, this.palette), this.others === Gt ? this.others = hn : checkType(\"ramp\", \"others\", 2, \"image\", this.others), this.input.isA(er) && (this.input = new cn(this.input), this.input._bindMetadata(e)), this.others._bindMetadata(e), this.childrenNames.push(\"others\");\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.input.eval(e);\n          return this._calcEval(t);\n        }\n      }, {\n        key: \"_calcEval\",\n        value: function _calcEval(e) {\n          var t = Math.round(e * (this.input.numCategoriesWithoutOthers - 1));\n          return this.palette.eval()[t] || this.others.eval();\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          var t = this,\n              r = this.input.type,\n              n = this.input.getLegendData(e),\n              a = n.data.map(function (e) {\n            var r = e.key,\n                n = e.value;\n            return {\n              key: r,\n              value: n = t._calcEval(n)\n            };\n          });\n          return Nr()({\n            type: r\n          }, n, {\n            data: a\n          });\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this.input._applyToShaderSource(e),\n              r = this.palette._applyToShaderSource(e),\n              n = this.others._applyToShaderSource(e);\n\n          return {\n            preface: this._prefaceCode(\"\\n                uniform float rampImageMultiplier\".concat(this._uid, \";\\n\\n                \").concat(t.preface, \"\\n                \").concat(r.preface, \"\\n                \").concat(n.preface, \"\\n\\n                vec4 rampImage\").concat(this._uid, \"(vec2 imageUV, float index){\\n                    if (index == \").concat(\"(-1.)\", \"){\\n                        return \").concat(n.inline, \";\\n                    }\\n                    return \").concat(r.inline, \"(imageUV, rampImageMultiplier\").concat(this._uid, \"*index);\\n                }\\n            \")),\n            inline: \"rampImage\".concat(this._uid, \"(imageUV, \").concat(t.inline, \")\")\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          lt()(R()(RampImage.prototype), \"_postShaderCompile\", this).call(this, e, t), this._getBinding(e)._multiplierLoc = t.getUniformLocation(e, \"rampImageMultiplier\".concat(this._uid));\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          lt()(R()(RampImage.prototype), \"_preDraw\", this).call(this, e, t, r), r.uniform1f(this._getBinding(e)._multiplierLoc, this.input.numCategoriesWithoutOthers - 1);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval();\n        }\n      }]), RampImage;\n    }(ut),\n        pn = function (e) {\n      function RampGeneric() {\n        return p()(this, RampGeneric), N()(this, R()(RampGeneric).apply(this, arguments));\n      }\n\n      return O()(RampGeneric, e), v()(RampGeneric, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = new dr(1),\n              r = new Cr(\"gray\");\n          lt()(R()(RampGeneric.prototype), \"_bindMetadata\", this).call(this, e), this.type = this.palette.childType, this.others === Gt ? (this.others = \"number-list\" === this.palette.type ? t : r, this.others._bindMetadata(e)) : (this.others._bindMetadata(e), checkType(\"ramp\", \"others\", 2, this.palette.childType, this.others)), (this.input.isA(er) || this.input.isA(tr)) && (this.input = \"number\" === this.input.type ? new Tr(this.input) : new cn(this.input), this.input._bindMetadata(e)), checkType(\"ramp\", \"input\", 0, [\"number\", \"category\"], this.input), this.childrenNames.push(\"others\"), this._metadata = e;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this.input.eval(e);\n          return this._calcEval(t, e);\n        }\n      }, {\n        key: \"_calcEval\",\n        value: function _calcEval(e, t) {\n          var r = this._getPalette(),\n              n = r.palette,\n              a = r.others,\n              i = this.palette.isA(zr) ? n.map(function (e) {\n            return e.eval(t);\n          }) : this.palette.eval(t);\n\n          if (e === zt) return a.eval(t);\n\n          var o = i.length - 1,\n              u = Math.floor(e * o),\n              s = Math.ceil(e * o),\n              c = utils_clamp(u, 0, o),\n              l = utils_clamp(s, 0, o),\n              f = function fract(e) {\n            return e - Math.floor(e);\n          }(e * o);\n\n          return utils_mix(i[c], i[l], f);\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          var t = this,\n              r = Object.assign({}, jt, e),\n              n = this.input.type,\n              a = this.input.getLegendData(r),\n              i = a.data.map(function (e) {\n            var r = e.key,\n                n = e.value;\n            return {\n              key: r,\n              value: n = t._calcEval(n, void 0)\n            };\n          });\n          return Nr()({\n            type: n\n          }, a, {\n            data: i\n          });\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this.input._applyToShaderSource(e),\n              r = this._getPalette(),\n              n = r.palette,\n              a = r.others,\n              i = n.map(function (t) {\n            return t._applyToShaderSource(e);\n          }),\n              o = a._applyToShaderSource(e),\n              u = \"number-list\" === this.palette.type ? function _getInlineGLSLBlend(e) {\n            return _generateGLSLBlend(e.map(function (e) {\n              return e.inline;\n            }));\n          }(i) : function _getInlineColorGLSLBlend(e) {\n            return \"cielabToSRGBA(\".concat(_generateGLSLBlend(e.map(function (e) {\n              return \"sRGBAToCieLAB(\".concat(e.inline, \")\");\n            })), \")\");\n          }(i),\n              s = \"number-list\" === this.palette.type ? \"float\" : \"vec4\",\n              c = \"ramp_color\".concat(this._uid, \"(\").concat(t.inline, \")\");\n\n          return {\n            preface: this._prefaceCode(\"\\n            \".concat(t.preface, \"\\n            \").concat(Qt.a, \"\\n            \").concat(i.map(function (e) {\n              return e.preface;\n            }).join(\"\\n\"), \"\\n            \").concat(o.preface, \"\\n\\n            \").concat(s, \" ramp_color\").concat(this._uid, \"(float x){\\n                return x==\").concat(\"(-1.)\", \"\\n                    ? \").concat(o.inline, \"\\n                    : \").concat(u, \";\\n            }\")),\n            inline: c\n          };\n        }\n      }, {\n        key: \"_getPalette\",\n        value: function _getPalette() {\n          return this.palette.isA(zr) ? this._getColorPalette() : {\n            palette: this.palette.elems,\n            others: this.others\n          };\n        }\n      }, {\n        key: \"_getColorPalette\",\n        value: function _getColorPalette() {\n          var e = this.palette.getColors(this.input.numCategoriesWithoutOthers);\n          return {\n            palette: e.colors,\n            others: this._defaultOthers && e.othersColor ? e.othersColor : this.others\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval();\n        }\n      }]), RampGeneric;\n    }(ut);\n\n    function _generateGLSLBlend(e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n          r = e[t];\n      return t === e.length - 1 ? r : function _mixClampGLSL(e, t, r, n) {\n        var a = (r / (n - 1)).toFixed(20),\n            i = (1 / (n - 1)).toFixed(20),\n            o = \"clamp((x - \".concat(a, \")/\").concat(i, \", 0., 1.)\");\n        return \"mix(\".concat(e, \", \").concat(t, \", \").concat(o, \")\");\n      }(r, _generateGLSLBlend(e, t + 1), t, e.length);\n    }\n\n    var mn = function (e) {\n      function Ramp(e, t) {\n        var r,\n            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Gt;\n        return p()(this, Ramp), checkMaxArguments(arguments, 3, \"ramp\"), e = implicitCast(e), t = implicitCast(t), checkExpression(\"ramp\", \"input\", 0, e), checkExpression(\"ramp\", \"palette\", 1, t), n !== Gt && checkExpression(\"ramp\", \"others\", 2, n = implicitCast(n)), (r = N()(this, R()(Ramp).call(this, {\n          input: e,\n          palette: t\n        }))).palette = t, r.others = n, r.type = t.type, r._defaultOthers = n === Gt, r;\n      }\n\n      return O()(Ramp, e), v()(Ramp, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          switch (lt()(R()(Ramp.prototype), \"_bindMetadata\", this).call(this, e), this.palette.type) {\n            case \"image-list\":\n              Object.setPrototypeOf(this, dn.prototype);\n              break;\n\n            default:\n              Object.setPrototypeOf(this, pn.prototype);\n          }\n\n          return this._bindMetadata(e);\n        }\n      }]), Ramp;\n    }(ut),\n        vn = function (e) {\n      function ListGeneric() {\n        return p()(this, ListGeneric), N()(this, R()(ListGeneric).apply(this, arguments));\n      }\n\n      return O()(ListGeneric, e), v()(ListGeneric, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.elems.map(function (t) {\n            return t.eval(e);\n          });\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this.elems.map(function (t) {\n            return t._applyToShaderSource(e);\n          });\n          return {\n            preface: t.map(function (e) {\n              return e.preface;\n            }).join(\"\\n\"),\n            inline: t.map(function (e) {\n              return e.inline;\n            })\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.elems.map(function (e) {\n            return e.value;\n          });\n        }\n      }]), ListGeneric;\n    }(ut),\n        yn = function (e) {\n      function ListTransform() {\n        return p()(this, ListTransform), N()(this, R()(ListTransform).apply(this, arguments));\n      }\n\n      return O()(ListTransform, e), v()(ListTransform, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ListTransform.prototype), \"_bindMetadata\", this).call(this, e), this._getChildren().forEach(function (e, t) {\n            return checkType(\"ListTransformation\", \"ListTransformation[\".concat(t, \"]\"), 0, \"transformation\", e);\n          }), this.type = \"transformation\";\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.elems.map(function (t) {\n            return t.eval(e);\n          });\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this.elems.map(function (t) {\n            return t._applyToShaderSource(e);\n          });\n          return {\n            preface: this._prefaceCode(\"\\n                \".concat(t.map(function (e) {\n              return e.preface;\n            }).join(\"\\n\"), \"\\n\\n                vec2 listTransform\").concat(this._uid, \"(vec2 p) {\\n                    \").concat(t.map(function (e) {\n              return \"p = \".concat(e.inline, \"(p);\");\n            }).join(\"\\n\"), \"\\n                    return p;\\n                }\\n            \")),\n            inline: \"listTransform\".concat(this._uid)\n          };\n        }\n      }]), ListTransform;\n    }(ut),\n        gn = [\"number\", \"category\", \"color\", \"date\", \"image\", \"transformation\"],\n        _n = function (e) {\n      function List(e) {\n        var t;\n        if (p()(this, List), checkMaxArguments(arguments, 1, \"list\"), !e) throw new he(\"list(): invalid parameters: must receive at least one argument.\", de.MISSING_REQUIRED);\n        if (Array.isArray(e) || (e = [e]), !(e = e.map(implicitCast)).length) throw new he(\"list(): invalid parameters: must receive at least one argument.\", de.MISSING_REQUIRED);\n        return e.map(function (e, t) {\n          checkExpression(\"list\", \"item[\".concat(t, \"]\"), t, e);\n        }), (t = N()(this, R()(List).call(this, e))).elems = e, t.type = e[0].type, t;\n      }\n\n      return O()(List, e), v()(List, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.elems.map(function (t) {\n            return t.eval(e);\n          });\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = this;\n          if (lt()(R()(List.prototype), \"_bindMetadata\", this).call(this, e), this._setTypes(), -1 === gn.indexOf(this.childType)) throw new he(\"list(): invalid parameters type: \".concat(this.childType, \".\"), de.INCORRECT_TYPE);\n\n          switch (this.elems.map(function (e, r) {\n            if (checkExpression(\"list\", \"item[\".concat(r, \"]\"), r, e), e.type !== t.childType) throw new he(\"list(): invalid \".concat(getOrdinalFromIndex(r + 1), \" parameter type, invalid argument type combination.\"), de.INCORRECT_TYPE);\n          }), this.elems[0].type) {\n            case \"image\":\n              Object.setPrototypeOf(this, ln.prototype);\n              break;\n\n            case \"transformation\":\n              Object.setPrototypeOf(this, yn.prototype);\n              break;\n\n            default:\n              Object.setPrototypeOf(this, vn.prototype);\n          }\n\n          return this._bindMetadata(e);\n        }\n      }, {\n        key: \"_setTypes\",\n        value: function _setTypes() {\n          this.childType = this.elems[0].type, this.type = \"\".concat(this.childType, \"-list\");\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.elems.map(function (e) {\n            return e.value;\n          });\n        }\n      }]), List;\n    }(ut),\n        bn = function (e) {\n      function Time(e) {\n        var t;\n        p()(this, Time), checkMaxArguments(arguments, 1, \"time\"), (t = N()(this, R()(Time).call(this, {}))).type = \"date\";\n\n        try {\n          t.date = castDate(e);\n        } catch (e) {\n          throwInvalidType(\"time\", \"date\", 0, \"Date or string or number\", \"other type\");\n        }\n\n        return t.inlineMaker = function () {}, t;\n      }\n\n      return O()(Time, e), v()(Time, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !1;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return !1;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.date;\n        }\n      }]), Time;\n    }(ut),\n        xn = function (e) {\n      function TimeRangeExpr(e) {\n        var t;\n        return p()(this, TimeRangeExpr), (t = N()(this, R()(TimeRangeExpr).call(this, {}))).type = \"timerange\", t.range = castTimeRange(e), t.inlineMaker = function () {}, t;\n      }\n\n      return O()(TimeRangeExpr, e), v()(TimeRangeExpr, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return {\n            iso: this.range.iso.eval(e),\n            timeZone: this.range.timeZone.eval(e),\n            startValue: this.range.startValue.eval(e),\n            endValue: this.range.endValue.eval(e),\n            startDate: this.range.startDate.eval(e),\n            endDate: this.range.endDate.eval(e)\n          };\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !1;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return !1;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return {\n            iso: this.range.iso.value,\n            timeZone: this.range.timeZone.value,\n            startValue: this.range.startValue.value,\n            endValue: this.range.endValue.value,\n            startDate: this.range.startDate.value,\n            endDate: this.range.endDate.value\n          };\n        }\n      }]), TimeRangeExpr;\n    }(ut),\n        kn = 16,\n        Tn = function (e) {\n      function Top(e, t) {\n        var r,\n            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : qt;\n        p()(this, Top), checkMaxArguments(arguments, 3, \"top\");\n\n        for (var a = {\n          property: e,\n          buckets: t = implicitCast(t),\n          othersLabel: n = implicitCast(n)\n        }, i = 0; i < kn; i++) a[\"_top\".concat(i)] = ba(0);\n\n        return (r = N()(this, R()(Top).call(this, a))).numBuckets = 0, r.type = \"category\", r;\n      }\n\n      return O()(Top, e), v()(Top, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this._metadata.properties[this.property.propertyName],\n              r = l()(t.categories).sort(function (e, t) {\n            return t.frequency - e.frequency;\n          }),\n              n = this.property.eval(e),\n              a = r.findIndex(function (e) {\n            return e.name === n;\n          }),\n              i = this.numCategoriesWithoutOthers - 1 || 1;\n          return a >= this.numBuckets || -1 === a ? {\n            label: qt,\n            index: zt\n          } : {\n            label: n,\n            index: a / i\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Top.prototype), \"_bindMetadata\", this).call(this, e), checkInstance(\"top\", \"property\", 0, er, this.property), checkType(\"top\", \"property\", 0, \"category\", this.property), checkFeatureIndependent(\"top\", \"buckets\", 1, this.buckets), checkType(\"top\", \"buckets\", 1, \"number\", this.buckets), checkType(\"top\", \"othersLabel\", 2, \"category\", this.othersLabel), checkFeatureIndependent(\"top\", \"othersLabel\", 2, this.othersLabel), this._metadata = e, this._textureBuckets = null, this.numBuckets = this.getNumBuckets(this.buckets);\n        }\n      }, {\n        key: \"getNumBuckets\",\n        value: function getNumBuckets(e) {\n          var t = Math.round(e);\n\n          if (t > this.property.numCategories && (t = this.property.numCategories), t > kn) {\n            var r = e;\n            throw new he(\"top() function has a limit of \".concat(kn, \" buckets but '\").concat(r, \"' buckets were specified.\"), de.INCORRECT_VALUE);\n          }\n\n          return t;\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this,\n              r = {};\n          return this.childrenNames.forEach(function (n) {\n            r[n] = t[n]._applyToShaderSource(e);\n          }), {\n            preface: this._prefaceCode(Object.values(r).map(function (e) {\n              return e.preface;\n            }).join(\"\") + \"\\n            uniform float numCategoriesWithoutOthers\".concat(this._uid, \";\\n\\n            float top\").concat(this._uid, \"(float id){\\n                float r;\\n                if (\").concat(r._top0.inline, \" == id){\\n                    r = 0.;\\n                } else if (\").concat(r._top1.inline, \" == id){\\n                    r = 1.;\\n                } else if (\").concat(r._top2.inline, \" == id){\\n                    r = 2.;\\n                } else if (\").concat(r._top3.inline, \" == id){\\n                    r = 3.;\\n                } else if (\").concat(r._top4.inline, \" == id){\\n                    r = 4.;\\n                } else if (\").concat(r._top5.inline, \" == id){\\n                    r = 5.;\\n                } else if (\").concat(r._top6.inline, \" == id){\\n                    r = 6.;\\n                } else if (\").concat(r._top7.inline, \" == id){\\n                    r = 7.;\\n                } else if (\").concat(r._top8.inline, \" == id){\\n                    r = 8.;\\n                } else if (\").concat(r._top9.inline, \" == id){\\n                    r = 9.;\\n                } else if (\").concat(r._top10.inline, \" == id){\\n                    r = 10.;\\n                } else if (\").concat(r._top11.inline, \" == id){\\n                    r = 11.;\\n                } else if (\").concat(r._top12.inline, \" == id){\\n                    r = 12.;\\n                } else if (\").concat(r._top13.inline, \" == id){\\n                    r = 13.;\\n                } else if (\").concat(r._top14.inline, \" == id){\\n                    r = 14.;\\n                } else if (\").concat(r._top15.inline, \" == id){\\n                    r = 15.;\\n                }else{\\n                    return \").concat(\"(-1.)\", \";\\n                }\\n                return r/(numCategoriesWithoutOthers\").concat(this._uid, \"-1.);\\n            }\")),\n            inline: \"top\".concat(this._uid, \"(\").concat(r.property.inline, \")\")\n          };\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          this._numCategoriesLoc = t.getUniformLocation(e, \"numCategoriesWithoutOthers\".concat(this._uid)), lt()(R()(Top.prototype), \"_postShaderCompile\", this).call(this, e, t);\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          for (var n = this, a = this.numBuckets, i = this._metadata.properties[this.property.propertyName], o = l()(i.categories).sort(function (e, t) {\n            return t.frequency - e.frequency;\n          }), u = 0; u < kn; u++) this[\"_top\".concat(u)].value = Number.POSITIVE_INFINITY;\n\n          o.forEach(function (e, t) {\n            t < a && (n[\"_top\".concat(t)].value = n._metadata.categoryToID.get(e.name));\n          }), r.uniform1f(this._numCategoriesLoc, this.numCategoriesWithoutOthers), lt()(R()(Top.prototype), \"_preDraw\", this).call(this, e, t, r);\n        }\n      }, {\n        key: \"getLegendData\",\n        value: function getLegendData(e) {\n          var t = this._metadata.properties[this.property.propertyName],\n              r = l()(t.categories).sort(function (e, t) {\n            return t.frequency - e.frequency;\n          }),\n              n = this.numBuckets,\n              a = [],\n              i = this.toString(),\n              o = this.numCategoriesWithoutOthers - 1 || 1;\n\n          if (r.forEach(function (e, t) {\n            if (t < n) {\n              var r = e.name,\n                  i = t / o;\n              a.push({\n                key: r,\n                value: i\n              });\n            }\n          }), r.length > this.buckets) {\n            var u = e && e.othersLabel ? e.othersLabel : this.othersLabel.value;\n            a.push({\n              key: u,\n              value: zt\n            });\n          }\n\n          return {\n            name: i,\n            data: a\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.eval();\n        }\n      }, {\n        key: \"numCategories\",\n        get: function get() {\n          return this.numBuckets + 1;\n        }\n      }, {\n        key: \"numCategoriesWithoutOthers\",\n        get: function get() {\n          return this.numCategories - 1;\n        }\n      }]), Top;\n    }(ut),\n        wn = .15,\n        Cn = void 0,\n        En = function (e) {\n      function Fade() {\n        var e,\n            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Cn,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Cn;\n        p()(this, Fade), checkMaxArguments(arguments, 2, \"fade\");\n        var n = implicitCast(t === Cn ? wn : t),\n            a = r === Cn ? n : implicitCast(r);\n        return checkExpression(\"fade\", \"param1\", 0, n), checkExpression(\"fade\", \"param2\", 1, a), (e = N()(this, R()(Fade).call(this, {\n          fadeIn: n,\n          fadeOut: a\n        }))).type = \"fade\", e.inlineMaker = function (e) {\n          return {\n            in: e.fadeIn,\n            out: e.fadeOut\n          };\n        }, e;\n      }\n\n      return O()(Fade, e), v()(Fade, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return {\n            fadeIn: this.fadeIn.eval(e),\n            fadeOut: this.fadeOut.eval(e)\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Fade.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"fade\", \"param1\", 0, \"number\", this.fadeIn), checkType(\"fade\", \"param2\", 1, \"number\", this.fadeOut);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return {\n            fadeIn: this.fadeIn.value,\n            fadeOut: this.fadeOut.value\n          };\n        }\n      }]), Fade;\n    }(ut),\n        Mn = new Set(),\n        An = new Set(),\n        Sn = function (e) {\n      function AnimationGeneral(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,\n            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new En();\n        return p()(this, AnimationGeneral), checkMaxArguments(arguments, 3, \"animation\"), r = implicitCast(r), e = implicitCast(e), (t = N()(this, R()(AnimationGeneral).call(this, {\n          input: e,\n          duration: r,\n          fade: n\n        })))._init(), t;\n      }\n\n      return O()(AnimationGeneral, e), v()(AnimationGeneral, [{\n        key: \"_init\",\n        value: function _init() {\n          var e = this.input,\n              t = e;\n          e.isA(er) || e.isA(hr) && \"timerange\" === e.type ? this._input = mi(e, io(e), ao(e), \"start\") : this._input = this.input, this.childrenNames = this.childrenNames.filter(function (e) {\n            return \"_input\" === e;\n          }), this.childrenNames.push(\"_input\"), this.childrenNames.push(\"fade\"), this.childrenNames.push(\"duration\"), this.type = \"number\", this._originalInput = t, this._paused = !1, this.progress = ba(0), this.childrenNames.push(\"progress\"), this.expressionName = \"animation\", this.preface = \"\\n        #ifndef ANIMATION\\n        #define ANIMATION\\n\\n        float animation(float _input, float progress, float duration, float fadeIn, float fadeOut){\\n            float x = 0.;\\n\\n            // Check for NaN\\n            if (_input <= 0.0 || 0.0 <= _input){\\n                x = 1. - clamp(abs(_input - progress) * duration / (_input > progress ? fadeIn: fadeOut), 0., 1.);\\n            }\\n\\n            return x;\\n        }\\n\\n        #endif\\n    \", this.inlineMaker = function (e) {\n            return \"animation(\".concat(e._input, \", \").concat(e.progress, \", \").concat(e.duration, \", \").concat(e.fade.in, \", \").concat(e.fade.out, \")\");\n          }, Mn.add(this), this._paused || (this._paused = \"default\");\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"(\").concat(this._input.toString(), \", \").concat(this.duration.toString(), \", \").concat(this.fade.toString(), \")\");\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this._input._bindMetadata(e), this.progress._bindMetadata(e), this.fade._bindMetadata(e), this.duration._bindMetadata(e), checkType(\"animation\", \"input\", 0, [\"number\", \"date\", \"timerange\"], this._originalInput), checkType(\"animation\", \"duration\", 1, \"number\", this.duration), checkType(\"animation\", \"fade\", 2, \"fade\", this.fade), checkFeatureIndependent(\"animation\", \"duration\", 1, this.duration);\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !0;\n        }\n      }, {\n        key: \"_dataReady\",\n        value: function _dataReady() {\n          var e = this;\n          Mn.has(this) && (Mn.delete(this), An.add(this)), setTimeout(function () {\n            if (An.has(e)) {\n              if ((Mn = new Set(l()(Mn).filter(function (e) {\n                for (; e.parent;) e = e.parent;\n\n                return !!e._getRootExpressions;\n              }))).size > 0) return;\n              l()(An.values()).map(function (e) {\n                \"default\" === e._paused && e.play();\n              }), An.clear();\n            }\n          }, 0);\n        }\n      }, {\n        key: \"_postShaderCompile\",\n        value: function _postShaderCompile(e, t) {\n          lt()(R()(AnimationGeneral.prototype), \"_postShaderCompile\", this).call(this, e, t);\n        }\n      }, {\n        key: \"_setTimestamp\",\n        value: function _setTimestamp(e) {\n          if (lt()(R()(AnimationGeneral.prototype), \"_setTimestamp\", this).call(this, e), !this._paused || void 0 !== this._lastTime) {\n            var t = 0,\n                r = 1 / this.duration.value;\n            void 0 !== this._lastTime && (t = e - this._lastTime), this._lastTime = e, this._paused || (this.progress.value = (this.progress.value + r * t) % 1);\n          }\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          var t = this._input.eval(e);\n\n          if (null === t) return 0;\n          var r = this.progress.value,\n              n = this.duration.value,\n              a = this.fade.fadeIn.eval(e),\n              i = this.fade.fadeOut.eval(e);\n          return 1 - utils_clamp(Math.abs(t - r) * n / (t > r ? a : i), 0, 1);\n        }\n      }, {\n        key: \"getProgressValue\",\n        value: function getProgressValue() {\n          var e = this.progress.value;\n          return this._input.converse(e);\n        }\n      }, {\n        key: \"setTimestamp\",\n        value: function setTimestamp(e) {\n          var t = castDate(e),\n              r = this._input.limits(),\n              n = g()(r, 2),\n              a = n[0],\n              i = n[1];\n\n          if (t.getTime() < a) throw new RangeError(\"animation.setTimestamp requires the date parameter to be higher than the lower limit\");\n          if (t.getTime() > i) throw new RangeError(\"animation.setTimestamp requires the date parameter to be lower than the higher limit\");\n          this.progress.value = (t.getTime() - a) / (i - a);\n        }\n      }, {\n        key: \"getProgressPct\",\n        value: function getProgressPct() {\n          return this.progress.value;\n        }\n      }, {\n        key: \"setProgressPct\",\n        value: function setProgressPct(e) {\n          if ((e = Number.parseFloat(e)) < 0 || e > 1) throw new TypeError(\"animation.setProgressPct requires a number between 0 and 1 as parameter but got: \".concat(e));\n          this.progress.value = e;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return !1 === this._paused;\n        }\n      }, {\n        key: \"pause\",\n        value: function pause() {\n          this._paused = !0;\n        }\n      }, {\n        key: \"play\",\n        value: function play() {\n          this._paused = !1, this.notify();\n        }\n      }, {\n        key: \"stop\",\n        value: function stop() {\n          this.progress.value = 0, this._paused = !0;\n        }\n      }]), AnimationGeneral;\n    }(ut),\n        Pn = function (e) {\n      function AnimationRange() {\n        return p()(this, AnimationRange), N()(this, R()(AnimationRange).apply(this, arguments));\n      }\n\n      return O()(AnimationRange, e), v()(AnimationRange, [{\n        key: \"_init\",\n        value: function _init() {\n          var e = this.input,\n              t = this.duration,\n              r = this.fade,\n              n = mi(e, io(e), ao(e), \"start\"),\n              a = {};\n          Object.keys(e).forEach(function (t) {\n            a[t] = e[t];\n          }), Object.setPrototypeOf(a, e);\n          var i = mi(a, io(a), ao(a), \"end\"),\n              o = new Sn(n, t, new En(r.fadeIn, go)),\n              u = new Sn(i, t, new En(go, r.fadeOut)),\n              s = Sa(o, u);\n          this.combinedAnimation = s, this.childrenNames.push(\"combinedAnimation\"), s.parent = this, this.type = \"number\", this._startAnim = o, this._endAnim = u, this.expressionName = \"animation\", this.inlineMaker = function (e) {\n            return e.combinedAnimation;\n          };\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this.combinedAnimation._bindMetadata(e);\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.combinedAnimation.eval(e);\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return !0;\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return this._startAnim.isPlaying();\n        }\n      }, {\n        key: \"getProgressValue\",\n        value: function getProgressValue() {\n          return this._startAnim.getProgressValue();\n        }\n      }, {\n        key: \"getProgressPct\",\n        value: function getProgressPct() {\n          return this._startAnim.getProgressPct();\n        }\n      }, {\n        key: \"setProgressPct\",\n        value: function setProgressPct(e) {\n          this._startAnim.setProgressPct(e), this._endAnim.setProgressPct(e);\n        }\n      }, {\n        key: \"pause\",\n        value: function pause() {\n          this._startAnim.pause(), this._endAnim.pause();\n        }\n      }, {\n        key: \"play\",\n        value: function play() {\n          this._startAnim.play(), this._endAnim.play(), this._endAnim.setProgressPct(this._startAnim.getProgressPct());\n        }\n      }, {\n        key: \"stop\",\n        value: function stop() {\n          this._startAnim.stop(), this._endAnim.stop();\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"(\").concat(this._input.toString(), \", \").concat(this.duration.toString(), \", \").concat(this.fade.toString(), \")\");\n        }\n      }]), AnimationRange;\n    }(ut),\n        In = function (e) {\n      function Animation(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,\n            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new En();\n        return p()(this, Animation), checkMaxArguments(arguments, 3, \"animation\"), t = implicitCast(t), e = implicitCast(e), N()(this, R()(Animation).call(this, {\n          input: e,\n          duration: t,\n          fade: r\n        }));\n      }\n\n      return O()(Animation, e), v()(Animation, [{\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          this._getChildren().map(function (t) {\n            return t._resolveAliases(e);\n          }), \"timerange\" === this.input.type ? Object.setPrototypeOf(this, Pn.prototype) : Object.setPrototypeOf(this, Sn.prototype), this._init();\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this._resolveAliases({}), this._bindMetadata(e);\n        }\n      }]), Animation;\n    }(ut),\n        Nn = genUnaryOp(\"log\", function (e) {\n      return Math.log(e);\n    }, function (e) {\n      return \"log(\".concat(e, \")\");\n    }),\n        Dn = genUnaryOp(\"sqrt\", function (e) {\n      return Math.sqrt(e);\n    }, function (e) {\n      return \"sqrt(\".concat(e, \")\");\n    }),\n        Rn = genUnaryOp(\"sin\", function (e) {\n      return Math.sin(e);\n    }, function (e) {\n      return \"sin(\".concat(e, \")\");\n    }),\n        Fn = genUnaryOp(\"cos\", function (e) {\n      return Math.cos(e);\n    }, function (e) {\n      return \"cos(\".concat(e, \")\");\n    }),\n        On = genUnaryOp(\"tan\", function (e) {\n      return Math.tan(e);\n    }, function (e) {\n      return \"tan(\".concat(e, \")\");\n    }),\n        Ln = genUnaryOp(\"sign\", function (e) {\n      return Math.sign(e);\n    }, function (e) {\n      return \"sign(\".concat(e, \")\");\n    }),\n        Bn = genUnaryOp(\"abs\", function (e) {\n      return Math.abs(e);\n    }, function (e) {\n      return \"abs(\".concat(e, \")\");\n    }),\n        Vn = genUnaryOp(\"isNull\", function (e) {\n      return null === e ? 1 : 0;\n    }, function (e) {\n      return \"((\".concat(e, \" == \").concat(Wt.toFixed(20), \") ? 1. : 0.)\");\n    }, [\"number\", \"category\"]),\n        Gn = genUnaryOp(\"not\", function (e) {\n      return 1 - e;\n    }, function (e) {\n      return \"(1.0 - \".concat(e, \")\");\n    }),\n        Un = genUnaryOp(\"floor\", function (e) {\n      return Math.floor(e);\n    }, function (e) {\n      return \"floor(\".concat(e, \")\");\n    }),\n        zn = genUnaryOp(\"ceil\", function (e) {\n      return Math.ceil(e);\n    }, function (e) {\n      return \"ceil(\".concat(e, \")\");\n    });\n\n    function genUnaryOp(e, t, r) {\n      var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : \"number\";\n      return function (a) {\n        function UnaryOperation(t) {\n          var n;\n          return p()(this, UnaryOperation), checkMaxArguments(arguments, 1, e), t = implicitCast(t), (n = N()(this, R()(UnaryOperation).call(this, {\n            a: t\n          }))).type = \"number\", n.expressionName = e, n.inlineMaker = function (e) {\n            return r(e.a);\n          }, n;\n        }\n\n        return O()(UnaryOperation, a), v()(UnaryOperation, [{\n          key: \"eval\",\n          value: function _eval(e) {\n            return t(this.a.eval(e));\n          }\n        }, {\n          key: \"_bindMetadata\",\n          value: function _bindMetadata(t) {\n            lt()(R()(UnaryOperation.prototype), \"_bindMetadata\", this).call(this, t), checkType(e, \"x\", 0, n, this.a);\n          }\n        }, {\n          key: \"value\",\n          get: function get() {\n            return t(this.a.value);\n          }\n        }]), UnaryOperation;\n      }(ut);\n    }\n\n    var qn = function (e) {\n      function Variable() {\n        return p()(this, Variable), N()(this, R()(Variable).call(this, {}));\n      }\n\n      return O()(Variable, e), Variable;\n    }(ut);\n\n    var jn = function (e) {\n      function ViewportAggregation(e) {\n        var t,\n            r = e.property;\n        return p()(this, ViewportAggregation), r = implicitCast(r), (t = N()(this, R()(ViewportAggregation).call(this, {\n          property: r,\n          _impostor: ba(0)\n        })))._isViewport = !0, t.type = \"number\", t.inlineMaker = function (e) {\n          return e._impostor;\n        }, t;\n      }\n\n      return O()(ViewportAggregation, e), v()(ViewportAggregation, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ViewportAggregation.prototype), \"_bindMetadata\", this).call(this, e);\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return this.property._getMinimumNeededSchema();\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw() {\n          var e;\n          this._impostor.value = this.value;\n\n          for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];\n\n          (e = lt()(R()(ViewportAggregation.prototype), \"_preDraw\", this)).call.apply(e, [this].concat(r));\n        }\n      }]), ViewportAggregation;\n    }(ut),\n        Wn = function (e) {\n      function ViewportAvg(e) {\n        var t;\n        return p()(this, ViewportAvg), checkMaxArguments(arguments, 1, \"viewportAvg\"), (t = N()(this, R()(ViewportAvg).call(this, {\n          property: e\n        })))._sum = 0, t._count = 0, t;\n      }\n\n      return O()(ViewportAvg, e), v()(ViewportAvg, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this.property.eval(e);\n\n          if (null !== t) {\n            var r = e._cdb_feature_count || 1;\n            this._count += r, this._sum += r * t;\n          }\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg() {\n          this._sum = 0, this._count = 0;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._sum / this._count;\n        }\n      }]), ViewportAvg;\n    }(jn),\n        Hn = function (e) {\n      function ViewportMax(e) {\n        var t;\n        return p()(this, ViewportMax), checkMaxArguments(arguments, 1, \"viewportMax\"), (t = N()(this, R()(ViewportMax).call(this, {\n          property: e\n        })))._value = Number.NEGATIVE_INFINITY, t;\n      }\n\n      return O()(ViewportMax, e), v()(ViewportMax, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this.property.eval(e);\n          null !== t && (this._value = Math.max(this._value, t));\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg() {\n          this._value = Number.NEGATIVE_INFINITY;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        }\n      }]), ViewportMax;\n    }(jn),\n        Yn = function (e) {\n      function ViewportMin(e) {\n        var t;\n        return p()(this, ViewportMin), checkMaxArguments(arguments, 1, \"viewportMin\"), (t = N()(this, R()(ViewportMin).call(this, {\n          property: e\n        })))._value = Number.POSITIVE_INFINITY, t;\n      }\n\n      return O()(ViewportMin, e), v()(ViewportMin, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this.property.eval(e);\n          null !== t && (this._value = Math.min(this._value, t));\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg() {\n          this._value = Number.POSITIVE_INFINITY;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        }\n      }]), ViewportMin;\n    }(jn),\n        Zn = function (e) {\n      function ViewportSum(e) {\n        var t;\n        return p()(this, ViewportSum), checkMaxArguments(arguments, 1, \"viewportSum\"), (t = N()(this, R()(ViewportSum).call(this, {\n          property: e\n        })))._value = 0, t;\n      }\n\n      return O()(ViewportSum, e), v()(ViewportSum, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this.property.eval(e);\n\n          if (null !== t) {\n            var r = e._cdb_feature_count || 1;\n            this._value = this._value + r * t;\n          }\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg() {\n          this._value = 0;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        }\n      }]), ViewportSum;\n    }(jn),\n        Xn = function (e) {\n      function ViewportCount() {\n        var e;\n        return p()(this, ViewportCount), checkMaxArguments(arguments, 0, \"viewportCount\"), (e = N()(this, R()(ViewportCount).call(this, {\n          property: ba(0)\n        })))._value = 0, e;\n      }\n\n      return O()(ViewportCount, e), v()(ViewportCount, [{\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"()\");\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = e._cdb_feature_count || 1;\n          this._value += t;\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg() {\n          this._value = 0;\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return {};\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        }\n      }]), ViewportCount;\n    }(jn),\n        Qn = function (e) {\n      function ViewportPercentile(e, t) {\n        var r;\n        return p()(this, ViewportPercentile), e = implicitCast(e), t = implicitCast(t), checkExpression(\"viewportPercentile\", \"property\", 0, e), checkExpression(\"viewportPercentile\", \"percentile\", 0, t), checkMaxArguments(arguments, 2, \"viewportPercentile\"), (r = N()(this, R()(ViewportPercentile).call(this, {\n          property: e\n        }))).percentile = t, r.childrenNames.push(\"percentile\"), r;\n      }\n\n      return O()(ViewportPercentile, e), v()(ViewportPercentile, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(ViewportPercentile.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"viewportPercentile\", \"property\", 0, \"number\", this.property), checkType(\"viewportPercentile\", \"percentile\", 1, \"number\", this.percentile);\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return null === this._value && (this._value = _nearestRankMethod(this.percentile.eval(e), this._total, this._values)), this._value;\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg() {\n          this._value = null, this._map = new Map(), this._total = 0;\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this.property.eval(e),\n              r = e._cdb_feature_count || 1;\n          this._map.set(t, (this._map.get(t) || 0) + r), this._total += r;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return _nearestRankMethod(this.percentile.value, this._total, this._values);\n        }\n      }, {\n        key: \"_values\",\n        get: function get() {\n          return l()(this._map.entries());\n        }\n      }]), ViewportPercentile;\n    }(jn);\n\n    function _nearestRankMethod(e, t, r) {\n      var n = utils_clamp(Math.ceil(e / 100 * t) - 1, 0, t - 1);\n      r.sort(function (e, t) {\n        return e[0] - t[0];\n      });\n\n      for (var a = 0, i = 0; i < r.length; i++) a += r[i][1], r[i][1] = a;\n\n      return function binarySearch(e, t, r, n) {\n        var a = Math.round((r + n) / 2);\n        var i = e[a][1];\n        var o = (e[a - 1] || [e[a][0] - 1, 0])[1];\n        return t >= o && t < i ? e[a][0] : t < o ? binarySearch(e, t, r, a - 1) : binarySearch(e, t, a + 1, n);\n      }(r, n, 0, r.length - 1);\n    }\n\n    var $n = r(30),\n        Jn = r.n($n),\n        Kn = function (e) {\n      function Histogram(e) {\n        var t;\n        return p()(this, Histogram), (t = N()(this, R()(Histogram).call(this, e))).type = \"histogram\", t.inlineMaker = function () {\n          return null;\n        }, t;\n      }\n\n      return O()(Histogram, e), v()(Histogram, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Histogram.prototype), \"_bindMetadata\", this).call(this, e), this._metadata = e;\n          var t = this.propertyName;\n          this._categories = this._metadata.properties[t] ? this._metadata.properties[t].categories.sort(this._sortByFrequency) : [];\n        }\n      }, {\n        key: \"_getCategoryValue\",\n        value: function _getCategoryValue(e) {\n          var t = this;\n          return l()(e).map(function (e) {\n            var t = g()(e, 2);\n            return {\n              x: t[0],\n              y: t[1]\n            };\n          }).sort(this._sortByFrequency).map(function (e, r) {\n            return {\n              x: \"number\" == typeof e.x && t._categories[r] ? t._categories[r].name : e.x,\n              y: e.y\n            };\n          });\n        }\n      }, {\n        key: \"_getNumericValue\",\n        value: function _getNumericValue(e, t) {\n          for (var r = l()(e), n = r.length, a = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, o = 0; o < n; o++) {\n            var u = r[o][0];\n            a = Math.min(a, u), i = Math.max(i, u);\n          }\n\n          for (var s = Array(t).fill(0), c = i - a, f = t - 1, h = 0; h < n; h++) {\n            var d = r[h][0],\n                p = r[h][1];\n            s[Math.min(Math.floor(t * (d - a) / c), f)] += p;\n          }\n\n          return s.map(function (e, r) {\n            return {\n              x: [a + r / t * c, a + (r + 1) / t * c],\n              y: e\n            };\n          });\n        }\n      }, {\n        key: \"_getBucketsValue\",\n        value: function _getBucketsValue(e, t) {\n          for (var r = Jn()(e).slice(0), n = (t = t.length && 0 === t.length ? this._genBreakpoints(t) : t).length, a = Array(n).fill(0), i = 0, o = r.length; i < o; i++) for (var u = r[i][0], s = 0; s < n; s++) {\n            var c = t[s];\n\n            if (u >= c[0] && u < c[1]) {\n              a[s] += r[i][1];\n              break;\n            }\n          }\n\n          return a.map(function (e, r) {\n            return {\n              x: t[r],\n              y: e\n            };\n          });\n        }\n      }, {\n        key: \"_getDateValue\",\n        value: function _getDateValue(e, t) {\n          for (var r = l()(e).map(function (e) {\n            return {\n              x: e[0].getTime(),\n              y: e[1]\n            };\n          }), n = r.length, a = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, o = 0; o < n; o++) {\n            var u = r[o].x;\n            a = Math.min(a, u), i = Math.max(i, u);\n          }\n\n          for (var s = Array(t).fill(0), c = i - a, f = t - 1, h = 0; h < n; h++) {\n            var d = r[h].x,\n                p = r[h].y;\n            s[Math.min(Math.floor(t * (d - a) / c), f)] += p;\n          }\n\n          return s.map(function (e, r) {\n            return {\n              x: [new Date(a + r / t * c), new Date(a + (r + 1) / t * c)],\n              y: e\n            };\n          });\n        }\n      }, {\n        key: \"_genBreakpoints\",\n        value: function _genBreakpoints() {\n          var e = this._histogram.value;\n\n          if (e) {\n            var t = this._getAccumHistogramFrom(e),\n                r = this._getMinMaxFrom(e),\n                n = g()(r, 2),\n                a = n[0],\n                i = n[1];\n\n            this._updateBreakpointsWith({\n              accumHistogram: t,\n              min: a,\n              max: i\n            });\n          }\n        }\n      }, {\n        key: \"_getAccumHistogramFrom\",\n        value: function _getAccumHistogramFrom(e) {\n          var t = 0;\n          return e.map(function (e) {\n            var r = e.y;\n            return t += r;\n          });\n        }\n      }, {\n        key: \"_getMinMaxFrom\",\n        value: function _getMinMaxFrom(e) {\n          return [e[0].x[0], e[e.length - 1].x[1]];\n        }\n      }, {\n        key: \"_sortByFrequency\",\n        value: function _sortByFrequency(e, t) {\n          var r = t.y - e.y;\n\n          if (0 === r) {\n            var n = e.x,\n                a = t.x;\n            return n || a ? n ? a ? \"string\" == typeof n && \"string\" == typeof a ? n.localeCompare(a) : n < a ? -1 : n > a ? 1 : 0 : -1 : 1 : 0;\n          }\n\n          return r;\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          switch (this.input.type) {\n            case \"number\":\n              return this._hasBuckets ? this._getBucketsValue(this._histogram, this._sizeOrBuckets) : this._getNumericValue(this._histogram, this._sizeOrBuckets);\n\n            case \"date\":\n              return this._hasBuckets ? this._getBucketsValue(this._histogram, this._sizeOrBuckets) : this._getDateValue(this._histogram, this._sizeOrBuckets);\n\n            default:\n              return this._getCategoryValue(this._histogram);\n          }\n        }\n      }]), Histogram;\n    }(ut),\n        ea = function (e) {\n      function ViewportHistogram(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20,\n            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n        return p()(this, ViewportHistogram), checkMaxArguments(arguments, 3, \"viewportHistogram\"), (t = N()(this, R()(ViewportHistogram).call(this, {\n          input: implicitCast(e),\n          weight: implicitCast(n)\n        })))._sizeOrBuckets = r, t._isViewport = !0, t._hasBuckets = Array.isArray(r), t._cached = null, t;\n      }\n\n      return O()(ViewportHistogram, e), v()(ViewportHistogram, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"getJoinedValues\",\n        value: function getJoinedValues(e, t) {\n          if (checkArray(\"viewportHistogram.getJoinedValues\", \"values\", 0, e), !e.length) return [];\n          var r = Object.assign({}, jt, t),\n              n = [],\n              a = [];\n          this.value.forEach(function (t) {\n            var r = e.find(function (e) {\n              return Array.isArray(e.key) ? e.key[0] === t.x[0] && e.key[1] === t.x[1] : t.x === e.key;\n            });\n\n            if (r) {\n              var i = t.y,\n                  o = r.key,\n                  u = r.value;\n              n.push({\n                frequency: i,\n                key: o,\n                value: u\n              });\n            } else a.push(t.y);\n          });\n          var i = e.find(function (e) {\n            return r.othersLabel === e.key;\n          });\n\n          if (i) {\n            var o = a.reduce(function (e, t) {\n              return e + t;\n            }),\n                u = i.key,\n                s = i.value;\n            n.push({\n              frequency: o,\n              key: u,\n              value: s\n            });\n          }\n\n          return n.sort(function (e, t) {\n            return t.frequency - e.frequency;\n          });\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this.input.eval(e),\n              r = this.input.isA(Tn) ? t.label : t;\n\n          if (void 0 !== r) {\n            var n = (e._cdb_feature_count || 1) * this.weight.eval(e),\n                a = this._histogram.get(r) || 0;\n\n            this._histogram.set(r, a + n);\n          }\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg(e) {\n          e && this._bindMetadata(e), this._cached = null, this._histogram = new Map();\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          if (null === this._cached) {\n            if (!this._histogram) return null;\n            this._cached = lt()(R()(ViewportHistogram.prototype), \"value\", this);\n          }\n\n          return this._cached;\n        }\n      }]), ViewportHistogram;\n    }(Kn),\n        ta = function (e) {\n      function GlobalHistogram(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20;\n        return p()(this, GlobalHistogram), checkMaxArguments(arguments, 3, \"globalHistogram\"), (t = N()(this, R()(GlobalHistogram).call(this, {\n          input: implicitCast(e)\n        })))._sizeOrBuckets = r, t._hasBuckets = Array.isArray(r), t._histogram = new Map(), t;\n      }\n\n      return O()(GlobalHistogram, e), v()(GlobalHistogram, [{\n        key: \"getJoinedValues\",\n        value: function getJoinedValues(e, t) {\n          if (checkArray(\"globalHistogram.getJoinedValues\", \"values\", 0, e), !e.length) return [];\n          var r = Object.assign({}, jt, t),\n              n = [];\n          return this.value.forEach(function (t) {\n            t.x = t.x === qt ? r.othersLabel : t.x;\n            var a = e.find(function (e) {\n              return t.x === e.key;\n            });\n\n            if (a) {\n              var i = t.y,\n                  o = a.key,\n                  u = a.value;\n              n.push({\n                frequency: i,\n                key: o,\n                value: u\n              });\n            }\n          }), n;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(GlobalHistogram.prototype), \"_bindMetadata\", this).call(this, e), this._histogram = new Map(), this.input.isA(er) ? \"number\" !== this.input.type ? this._setHistogramForCategoryValues() : this._setHistogramForNumericValues() : this._setHistogramForExpression();\n        }\n      }, {\n        key: \"_setHistogramForExpression\",\n        value: function _setHistogramForExpression() {\n          var e = this,\n              t = this.input.getLegendData(jt).data;\n\n          this._categories.forEach(function (r) {\n            if (t.find(function (e) {\n              return r.name === e.key;\n            })) e._histogram.set(r.name, r.frequency);else {\n              var n = e._histogram.get(qt) || 0;\n\n              e._histogram.set(qt, r.frequency + parseInt(n));\n            }\n          });\n        }\n      }, {\n        key: \"_setHistogramForCategoryValues\",\n        value: function _setHistogramForCategoryValues() {\n          var e = this;\n\n          this._categories.forEach(function (t) {\n            e._histogram.set(t.name, t.frequency);\n          });\n        }\n      }, {\n        key: \"_setHistogramForNumericValues\",\n        value: function _setHistogramForNumericValues() {\n          var e = this,\n              t = this.propertyName,\n              r = this._metadata.featureCount / this._metadata.sample.length;\n\n          this._metadata.sample.forEach(function (n) {\n            var a = n[t],\n                i = e._histogram.get(a) || 0;\n\n            e._histogram.set(a, i + r);\n          });\n        }\n      }]), GlobalHistogram;\n    }(Kn);\n\n    function generateResetFunction(e, t, r, n, a) {\n      return function reset() {\n        var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;\n        r[t] && r[t][e] && (r[t][e].replaceChild(r[t][e].mix, Xa(Ga(wi(a), t), Ca(0), Ca(i))), n[e].notify(), r[t][e] = void 0);\n      };\n    }\n\n    function generateBlenderFunction(e, t, r, n, a, i, o) {\n      return function generatedBlendTo(u) {\n        var s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;\n        if (\"string\" == typeof u && (u = o(u)), r[t] && r[t][e]) r[t][e].a.blendTo(u, s);else {\n          var c = Xa(u, n[e], Xa(1, Ga(wi(i), t), Ca(s)));\n          a(t, e, c, r), n.replaceChild(n[e], c), n[e].notify();\n        }\n      };\n    }\n\n    var ra = [\"color\", \"filter\", \"order\", \"resolution\", \"strokeColor\", \"strokeWidth\", \"symbol\", \"symbolPlacement\", \"transform\", \"width\"],\n        na = [\"color\", \"filter\", \"order\", \"strokeColor\", \"strokeWidth\", \"symbol\", \"symbolPlacement\", \"transform\", \"width\"];\n\n    function genLightweightFeatureClass(e, t) {\n      var r = function LightweightFeature(e) {\n        p()(this, LightweightFeature), this._rawFeature = e, this._featureProperties = null;\n      };\n\n      return function _defineIdProperty(e, t) {\n        Object.defineProperty(e, \"id\", {\n          get: function get() {\n            var e = t.viz.metadata.idProperty;\n            return this._rawFeature[e];\n          },\n          configurable: !0\n        });\n      }(r.prototype, t), function lightweightFeature_defineVizProperties(e, t) {\n        ra.forEach(function (r) {\n          _createLightweightFeatureVizProperty(e, t, r);\n        });\n      }(r.prototype, t), function _defineVizVariables(e, t) {\n        Object.defineProperty(e, \"variables\", {\n          get: function get() {\n            var e = {};\n            Object.defineProperty(e, \"id\", {\n              get: function get() {\n                return this.id;\n              }\n            });\n            var r = t.viz.variables;\n            return Object.keys(r).forEach(function (r) {\n              var n = \"__cartovl_variable_\".concat(r);\n\n              _createLightweightFeatureVizProperty(e, t, n, r);\n            }), e;\n          }\n        });\n      }(r.prototype, t), function _defineFeatureProperties(e, t) {\n        Object.defineProperty(e, \"properties\", {\n          get: function get() {\n            var e = this;\n            return null === this._featureProperties && (this._featureProperties = {}, t.forEach(function (t) {\n              var r = t.property,\n                  n = t.variable,\n                  a = n || r;\n              e._featureProperties[a] = e._rawFeature[r];\n            })), this._featureProperties;\n          }\n        });\n      }(r.prototype, e), function _defineRootBlendToMethod(e) {\n        Object.defineProperty(e, \"blendTo\", {\n          get: function get() {\n            var e = this;\n            return function blendTo(t) {\n              var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;\n              Object.keys(t).forEach(function (n) {\n                if (!ra.includes(n)) throw new he(\"Property '\".concat(n, \"' is not a valid viz property\"), de.INCORRECT_VALUE);\n                var a = t[n];\n                e[n].blendTo(a, r);\n              });\n            };\n          }\n        });\n      }(r.prototype), function _defineRootResetMethod(e) {\n        Object.defineProperty(e, \"reset\", {\n          get: function get() {\n            var e = this;\n            return function reset() {\n              var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;\n\n              for (var r in ra.forEach(function (r) {\n                e[r].reset(t);\n              }), e.variables) e.variables[r].reset(t);\n            };\n          }\n        });\n      }(r.prototype), function _defineGetRenderedCentroidMethod(e) {\n        Object.defineProperty(e, \"getRenderedCentroid\", {\n          get: function get() {\n            var e = this;\n            return function getRenderedCentroid() {\n              return e._rawFeature._dataframe.getRenderedCentroid(e._rawFeature._index);\n            };\n          },\n          configurable: !0\n        });\n      }(r.prototype), r;\n    }\n\n    function _createLightweightFeatureVizProperty(e, t, r) {\n      var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r,\n          a = t.customizedFeatures,\n          i = t.viz,\n          o = t.trackFeatureViz,\n          u = t.parseVizExpression,\n          s = i.metadata.idProperty;\n      Object.defineProperty(e, n, {\n        get: function get() {\n          var e = this;\n          return {\n            blendTo: function blendTo() {\n              return function blender(e) {\n                return generateBlenderFunction(r, e, a, i, o, s, u);\n              }(e.id).apply(void 0, arguments);\n            },\n            reset: function reset() {\n              return function reset(e) {\n                return generateResetFunction(r, e, a, i, s);\n              }(e.id).apply(void 0, arguments);\n            },\n            value: i[r].eval(this._rawFeature)\n          };\n        }\n      });\n    }\n\n    function getCompoundFeature(e) {\n      var t = e[0];\n      if (1 === e.length) return t;\n\n      var r = function _getGeomPropertiesFromPieces(e) {\n        return e.map(function (e) {\n          var t = e.getRenderedCentroid(),\n              r = g()(t, 2);\n          return {\n            centroid: {\n              x: r[0],\n              y: r[1]\n            },\n            aabb: e._rawFeature._dataframe._aabb[e._rawFeature._index]\n          };\n        }).filter(function (e) {\n          var t = e.centroid,\n              r = t.x,\n              n = t.y;\n          return !(isNaN(r) || isNaN(n));\n        });\n      }(e);\n\n      return Object.defineProperty(t, \"getRenderedCentroid\", {\n        get: function get() {\n          return function getRenderedCentroid() {\n            var e = r.reduce(function (e, t) {\n              var r = t.aabb,\n                  n = r.minx,\n                  a = r.miny,\n                  i = (r.maxx - n) * (r.maxy - a),\n                  o = t.centroid.x * i,\n                  u = t.centroid.y * i;\n              return [e[0] + o, e[1] + u, e[2] + i];\n            }, [0, 0, 0]),\n                t = g()(e, 3),\n                n = t[0],\n                a = t[1],\n                i = t[2];\n            return [n / i, a / i];\n          };\n        }\n      }), t;\n    }\n\n    var aa = function (e) {\n      function ViewportFeatures() {\n        for (var e, t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];\n\n        return p()(this, ViewportFeatures), r = r.map(function (e) {\n          return implicitCast(e);\n        }), (e = N()(this, R()(ViewportFeatures).call(this, function _childrenFromProperties(e) {\n          var t = 0,\n              r = {};\n          return e.forEach(function (e) {\n            r[\"p\" + ++t] = e;\n          }), r;\n        }(r))))._value = [], e.type = \"featureList\", e._isViewport = !0, e._requiredProperties = r, e._FeatureProxy = null, e;\n      }\n\n      return O()(ViewportFeatures, e), v()(ViewportFeatures, [{\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource() {\n          throw new Ae(\"'viewportFeatures' cannot be used in visualizations.\");\n        }\n      }, {\n        key: \"isFeatureDependent\",\n        value: function isFeatureDependent() {\n          return !1;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"_resetViewportAgg\",\n        value: function _resetViewportAgg(e, t) {\n          if (!this._FeatureProxy) {\n            if (!this._requiredProperties.every(function (e) {\n              return function validProperty(e) {\n                return [er, tr, sr, fr].some(function (t) {\n                  return e.isA(t);\n                });\n              }(e);\n            })) throw new he(\"viewportFeatures arguments can only be properties\", de.INCORRECT_TYPE);\n\n            var r = this._requiredProperties.map(function (e) {\n              return {\n                property: e.propertyName,\n                variable: e._variableName\n              };\n            });\n\n            this._FeatureProxy = genLightweightFeatureClass(r, t);\n          }\n\n          this._value = [];\n        }\n      }, {\n        key: \"accumViewportAgg\",\n        value: function accumViewportAgg(e) {\n          var t = this;\n          if (1 === (e = Array.isArray(e) ? e : [e]).length) this._value.push(new this._FeatureProxy(e[0]));else {\n            var r = getCompoundFeature(e.map(function (e) {\n              return new t._FeatureProxy(e);\n            }));\n\n            this._value.push(r);\n          }\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value;\n        },\n        set: function set(e) {\n          this._value = e;\n        }\n      }]), ViewportFeatures;\n    }(ut);\n\n    var ia = function (e) {\n      function GlobalAggregation(e) {\n        var t,\n            r = e.property,\n            n = e.name,\n            a = e.type,\n            i = e.baseStats,\n            o = void 0 !== i && i;\n        return p()(this, GlobalAggregation), (t = N()(this, R()(GlobalAggregation).call(this, {\n          _value: ba(0)\n        }))).property = implicitCast(r), t._name = n, t.type = a, t.baseStats = o, Ar()(R()(GlobalAggregation.prototype), \"inlineMaker\", function (e) {\n          return e._value;\n        }, Vt()(t), !0), t;\n      }\n\n      return O()(GlobalAggregation, e), v()(GlobalAggregation, [{\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"(\").concat(this.property.toString(), \")\");\n        }\n      }, {\n        key: \"isFeatureDependent\",\n        value: function isFeatureDependent() {\n          return !1;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"_resolveAliases\",\n        value: function _resolveAliases(e) {\n          this.property && this.property._resolveAliases(e);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(GlobalAggregation.prototype), \"_bindMetadata\", this).call(this, e), this.property._bindMetadata(e);\n\n          var t = this.property.name || this.property.propertyName,\n              r = this._getValueFromStats(e, t);\n\n          this._value.value = e.codec(t).sourceToExternal(e, r);\n        }\n      }, {\n        key: \"_getValueFromStats\",\n        value: function _getValueFromStats(e, t) {\n          var r;\n          if (this.baseStats) {\n            if (\"_count\" === this.baseStats) r = e.featureCount;else {\n              var n = e.stats(this.property.name);\n              r = n && n[this.baseStats];\n            }\n          } else {\n            if (\"_cdb_feature_count\" === t) throw new he(de.INCORRECT_TYPE, \"'clusterCount' can not be used in \".concat(this.expressionName, \".\"));\n            var a = e.stats(t);\n            r = a && a[this._name];\n          }\n          if (void 0 === r) throw new he(\"Metadata \".concat(this._name, \" for property \").concat(t, \" is not defined\"), de.MISSING_REQUIRED);\n          return r;\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return this.property._getMinimumNeededSchema();\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._value.value;\n        }\n      }]), GlobalAggregation;\n    }(ut),\n        oa = function (e) {\n      function GlobalAvg(e) {\n        p()(this, GlobalAvg), checkMaxArguments(arguments, 1, \"globalAvg\");\n        var t = !1;\n\n        if (e && e.isA(tr)) {\n          if (!e.isA(rr)) throw new he(\"Invalid globlalAvg input\", de.INCORRECT_TYPE);\n          t = \"avg\";\n        }\n\n        return N()(this, R()(GlobalAvg).call(this, {\n          property: e,\n          name: \"avg\",\n          type: \"number\",\n          baseStats: t\n        }));\n      }\n\n      return O()(GlobalAvg, e), v()(GlobalAvg, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(GlobalAvg.prototype), \"_bindMetadata\", this).call(this, e), checkType(this.expressionName, \"property\", 0, \"number\", this.property);\n        }\n      }]), GlobalAvg;\n    }(ia),\n        ua = function (e) {\n      function GlobalCount() {\n        return p()(this, GlobalCount), checkMaxArguments(arguments, 0, \"globalCount\"), N()(this, R()(GlobalCount).call(this, {\n          name: \"count\",\n          type: \"number\"\n        }));\n      }\n\n      return O()(GlobalCount, e), v()(GlobalCount, [{\n        key: \"toString\",\n        value: function toString() {\n          return \"\".concat(this.expressionName, \"()\");\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this._value.value = e.featureCount;\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return {};\n        }\n      }]), GlobalCount;\n    }(ia),\n        sa = function (e) {\n      function GlobalMax(e) {\n        p()(this, GlobalMax), checkMaxArguments(arguments, 1, \"globalMax\");\n        var t = !1;\n\n        if (e && e.isA(tr)) {\n          if (!(e.isA(rr) || e.isA(ar) || e.isA(nr))) throw new he(\"Invalid globlalAvg input\", de.INCORRECT_TYPE);\n          t = \"max\";\n        }\n\n        return N()(this, R()(GlobalMax).call(this, {\n          property: e,\n          name: \"max\",\n          type: \"number\",\n          baseStats: t\n        }));\n      }\n\n      return O()(GlobalMax, e), GlobalMax;\n    }(ia),\n        ca = function (e) {\n      function GlobalMin(e) {\n        p()(this, GlobalMin), checkMaxArguments(arguments, 1, \"globalMin\");\n        var t = !1;\n\n        if (e && e.isA(tr)) {\n          if (!(e.isA(rr) || e.isA(ar) || e.isA(nr))) throw new he(\"Invalid globlalAvg input\", de.INCORRECT_TYPE);\n          t = \"min\";\n        }\n\n        return N()(this, R()(GlobalMin).call(this, {\n          property: e,\n          name: \"min\",\n          type: \"number\",\n          baseStats: t\n        }));\n      }\n\n      return O()(GlobalMin, e), GlobalMin;\n    }(ia),\n        la = function (e) {\n      function GlobalSum(e) {\n        p()(this, GlobalSum), checkMaxArguments(arguments, 1, \"globalSum\");\n        var t = e.type,\n            r = !1;\n        if (e && (e.isA(tr) || e.isA(sr))) if (e.isA(ur)) r = \"sum\";else {\n          if (!e.isA(sr)) throw new he(\"Invalid globlalAvg input\", de.INCORRECT_TYPE);\n          r = \"_count\";\n        }\n        return N()(this, R()(GlobalSum).call(this, {\n          property: e,\n          name: \"sum\",\n          baseStats: r,\n          type: t\n        }));\n      }\n\n      return O()(GlobalSum, e), GlobalSum;\n    }(ia),\n        fa = function (e) {\n      function GlobalPercentile(e, t) {\n        var r;\n        return p()(this, GlobalPercentile), checkMaxArguments(arguments, 2, \"globalPercentile\"), e = implicitCast(e), t = implicitCast(t), checkExpression(\"globalPercentile\", \"property\", 0, e), checkExpression(\"globalPercentile\", \"percentile\", 1, t), (r = N()(this, R()(GlobalPercentile).call(this, {\n          _value: ba(0),\n          property: e,\n          percentile: t\n        }))).type = \"number\", Ar()(R()(GlobalPercentile.prototype), \"inlineMaker\", function (e) {\n          return e._value;\n        }, Vt()(r), !0), r;\n      }\n\n      return O()(GlobalPercentile, e), v()(GlobalPercentile, [{\n        key: \"isFeatureDependent\",\n        value: function isFeatureDependent() {\n          return !1;\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval() {\n          return this.value;\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = this;\n          lt()(R()(GlobalPercentile.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"globalPercentile\", \"property\", 0, \"number\", this.property), checkType(\"globalPercentile\", \"percentile\", 0, \"number\", this.percentile), checkInstance(\"globalPercentile\", \"property\", 0, er, this.property), checkFeatureIndependent(\"globalPercentile\", \"percentile\", 1, this.percentile), this._copySample = e.sample.map(function (e) {\n            return e[t.property.propertyName];\n          }), this._copySample.sort(function (e, t) {\n            return e - t;\n          });\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw() {\n          var e;\n          this._value.value = this.value;\n\n          for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];\n\n          (e = lt()(R()(GlobalPercentile.prototype), \"_preDraw\", this)).call.apply(e, [this].concat(r));\n        }\n      }, {\n        key: \"_getMinimumNeededSchema\",\n        value: function _getMinimumNeededSchema() {\n          return this.property._getMinimumNeededSchema();\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          var e = this.percentile.value / 100;\n          return this._copySample[Math.floor(e * this._copySample.length)];\n        }\n      }]), GlobalPercentile;\n    }(ut),\n        ha = function (e) {\n      function Zoom() {\n        var e;\n        return p()(this, Zoom), checkMaxArguments(arguments, 0, \"zoom\"), (e = N()(this, R()(Zoom).call(this, {\n          zoom: ba(0)\n        }))).type = \"number\", Ar()(R()(Zoom.prototype), \"inlineMaker\", function (e) {\n          return e.zoom;\n        }, Vt()(e), !0), e;\n      }\n\n      return O()(Zoom, e), v()(Zoom, [{\n        key: \"eval\",\n        value: function _eval() {\n          return this.zoom.value;\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          this.zoom.value = t.zoomLevel, this.zoom._preDraw(e, t, r);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.zoom.value;\n        }\n      }]), Zoom;\n    }(ut),\n        da = function (e) {\n      function Placement(e, t) {\n        var r;\n        return p()(this, Placement), checkMaxArguments(arguments, 2, \"placement\"), e = implicitCast(e), t = implicitCast(t), (r = N()(this, R()(Placement).call(this, {\n          x: e,\n          y: t\n        }))).inlineMaker = function (e) {\n          return \"vec2(\".concat(e.x, \", \").concat(e.y, \")\");\n        }, r.type = \"placement\", r;\n      }\n\n      return O()(Placement, e), v()(Placement, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return [this.x.eval(e), this.y.eval(e)];\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Placement.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"placement\", \"x\", 0, \"number\", this.x), checkType(\"placement\", \"y\", 1, \"number\", this.y);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return [this.x.value, this.y.value];\n        }\n      }]), Placement;\n    }(ut),\n        pa = function (e) {\n      function SVG(e) {\n        return p()(this, SVG), checkMaxArguments(arguments, 1, \"svg\"), N()(this, R()(SVG).call(this, \"data:image/svg+xml,\".concat(encodeURIComponent(e))));\n      }\n\n      return O()(SVG, e), SVG;\n    }(fn),\n        ma = function (e) {\n      function Zoomrange(e) {\n        var t;\n        return p()(this, Zoomrange), e = implicitCast(e), t = N()(this, R()(Zoomrange).call(this, {})), checkExpression(\"zoomrange\", \"zoomBreakpointList\", 0, e), t.type = \"number\", t._zoomBreakpointList = e, t.inlineMaker = function (e) {\n          return e._impostor;\n        }, t;\n      }\n\n      return O()(Zoomrange, e), v()(Zoomrange, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          if (this._zoomBreakpointList._bindMetadata(e), checkType(\"zoomrange\", \"zoomBreakpointList\", 0, \"number-list\", this._zoomBreakpointList), this._zoomBreakpointList.elems.length < 2) throw new he(\"zoomrange() function must receive a list with at least two elements.\", de.INCORRECT_VALUE);\n          var t = l()(this._zoomBreakpointList.elems);\n          this._impostor = function _genImpostor(e, t, r) {\n            if (1 === e.length) return 1;\n            var n = e[0];\n            var a = e[1];\n            e.shift();\n            return Xa(t / r, _genImpostor(e, t + 1, r), mi(Da(2, lo()), Da(2, n), Da(2, a)));\n          }(t, 0, t.length - 1), this.childrenNames.push(\"_impostor\"), lt()(R()(Zoomrange.prototype), \"_bindMetadata\", this).call(this, e);\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return this._impostor.eval(e);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._zoomBreakpointList.elems.map(function (e) {\n            return e.value;\n          });\n        }\n      }]), Zoomrange;\n    }(ut);\n\n    var va = function (e) {\n      function Scaled(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n        return p()(this, Scaled), e = implicitCast(e), r = implicitCast(r), (t = N()(this, R()(Scaled).call(this, {\n          scale: Pa(Sa(e, 0), Da(2, r))\n        }))).type = \"number\", t.inlineMaker = function (e) {\n          return e.scale;\n        }, t;\n      }\n\n      return O()(Scaled, e), v()(Scaled, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.scale.eval(e);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Scaled.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"scaled\", \"width\", 0, \"number\", this.scale.a.a), checkType(\"scaled\", \"zoomlevel\", 1, \"number\", this.scale.b);\n        }\n      }, {\n        key: \"_preDraw\",\n        value: function _preDraw(e, t, r) {\n          this.scale.a.b.value = Math.pow(2, t.zoomLevel), lt()(R()(Scaled.prototype), \"_preDraw\", this).call(this, e, t, r);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.scale.value;\n        }\n      }]), Scaled;\n    }(ut),\n        ya = function (e) {\n      function AlphaNormalize(e, t) {\n        var r;\n        return p()(this, AlphaNormalize), checkMaxArguments(arguments, 2, \"alphaNormalize\"), checkExpression(\"alphaNormalize\", \"input\", 0, e), checkExpression(\"alphaNormalize\", \"normalizer\", 1, t), (r = N()(this, R()(AlphaNormalize).call(this, {\n          _impostor: gi(e, Pa(t, ao(t)))\n        })))._input = e, r._normalizer = t, r.type = \"color\", r.inlineMaker = function (e) {\n          return e._impostor;\n        }, r;\n      }\n\n      return O()(AlphaNormalize, e), v()(AlphaNormalize, [{\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          this._input._bindMetadata(e), this._normalizer._bindMetadata(e), checkType(\"alphaNormalize\", \"input\", 0, \"color\", this._input), checkType(\"alphaNormalize\", \"normalizer\", 1, \"number\", this._normalizer), checkInstance(\"alphaNormalize\", \"normalizer\", 1, er, this._normalizer), lt()(R()(AlphaNormalize.prototype), \"_bindMetadata\", this).call(this, e);\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return this._impostor.eval(e);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._impostor.value;\n        }\n      }]), AlphaNormalize;\n    }(ut),\n        ga = function (e) {\n      function Translate(e, t) {\n        var r;\n        return p()(this, Translate), checkMaxArguments(arguments, 2, \"translate\"), e = implicitCast(e), t = implicitCast(t), (r = N()(this, R()(Translate).call(this, {\n          x: e,\n          y: t\n        }))).type = \"transformation\", r;\n      }\n\n      return O()(Translate, e), v()(Translate, [{\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this.x._applyToShaderSource(e),\n              r = this.y._applyToShaderSource(e);\n\n          return {\n            preface: this._prefaceCode(\"\\n                \".concat(t.preface, \"\\n                \").concat(r.preface, \"\\n\\n                vec2 translate\").concat(this._uid, \"(vec2 p){\\n                    return p+vec2(\").concat(t.inline, \", \").concat(r.inline, \");\\n                }\")),\n            inline: \"translate\".concat(this._uid)\n          };\n        }\n      }, {\n        key: \"eval\",\n        value: function _eval(e) {\n          return [this.x.eval(e), this.y.eval(e)];\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Translate.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"translate\", \"x\", 0, \"number\", this.x), checkType(\"translate\", \"y\", 1, \"number\", this.y);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return [this.x.value, this.y.value];\n        }\n      }]), Translate;\n    }(ut),\n        _a = function (e) {\n      function Rotate(e) {\n        var t;\n        p()(this, Rotate), checkMaxArguments(arguments, 1, \"rotate\");\n        var r = implicitCast(e);\n        return (t = N()(this, R()(Rotate).call(this, {\n          angle: r\n        }))).type = \"transformation\", t;\n      }\n\n      return O()(Rotate, e), v()(Rotate, [{\n        key: \"eval\",\n        value: function _eval(e) {\n          return this.angle.eval(e);\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          lt()(R()(Rotate.prototype), \"_bindMetadata\", this).call(this, e), checkType(\"rotate\", \"angle\", 0, \"number\", this.angle);\n        }\n      }, {\n        key: \"_applyToShaderSource\",\n        value: function _applyToShaderSource(e) {\n          var t = this.angle._applyToShaderSource(e);\n\n          return {\n            preface: this._prefaceCode(\"\\n                \".concat(t.preface, \"\\n\\n                #ifndef DEGREES_TO_RADIANS\\n                #define DEGREES_TO_RADIANS\\n                float degreesToRadians(float degrees){\\n                    return degrees/360.*2.*3.14159265359;\\n                }\\n                #endif\\n                \\n                vec2 rotate\").concat(this._uid, \"(vec2 p){\\n                    float angle = degreesToRadians(\").concat(t.inline, \");\\n                    mat2 M = mat2(cos(angle), -sin(angle),\\n                                  sin(angle),  cos(angle));\\n                    return M * p;\\n                }\")),\n            inline: \"rotate\".concat(this._uid)\n          };\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this.angle.value;\n        }\n      }]), Rotate;\n    }(ut),\n        ba = function number() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Pr, t);\n    },\n        xa = function category() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Zt, t);\n    },\n        ka = function list() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(_n, t);\n    },\n        Ta = function rgb() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Gr, t);\n    },\n        wa = function rgba() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Ur, t);\n    },\n        Ca = function transition() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(st, t);\n    },\n        Ea = function in_() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ft, t);\n    },\n        Ma = function nin() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ht, t);\n    },\n        Aa = function between() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(dt, t);\n    },\n        Sa = function mul() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Nt, t);\n    },\n        Pa = function div() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Ct, t);\n    },\n        Ia = function add() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Tt, t);\n    },\n        Na = function sub() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Ot, t);\n    },\n        Da = function pow() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Ft, t);\n    },\n        Ra = function mod() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(It, t);\n    },\n        Fa = function greaterThan() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Mt, t);\n    },\n        Oa = function greaterThanOrEqualTo() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(At, t);\n    },\n        La = function lessThan() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(St, t);\n    },\n        Ba = function lessThanOrEqualTo() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Pt, t);\n    },\n        Va = function equals() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Et, t);\n    },\n        Ga = function notEquals() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Dt, t);\n    },\n        Ua = function and() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(wt, t);\n    },\n        za = function or() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Rt, t);\n    },\n        qa = Fa,\n        ja = Oa,\n        Wa = La,\n        Ha = Ba,\n        Ya = Va,\n        Za = Ga,\n        Xa = function blend() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Lt, t);\n    },\n        Qa = function buckets() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Yt, t);\n    },\n        $a = function cielab() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()($t, t);\n    },\n        Ja = function clusterAvg() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(rr, t);\n    },\n        Ka = function clusterMax() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(nr, t);\n    },\n        ei = function clusterMin() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ar, t);\n    },\n        ti = function clusterMode() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ir, t);\n    },\n        ri = function clusterSum() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ur, t);\n    },\n        ni = function clusterCount() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(sr, t);\n    },\n        ai = function clusterTime() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(hr, t);\n    },\n        ii = function constant() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(dr, t);\n    },\n        oi = function image() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(fn, t);\n    },\n        ui = function svg() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(pa, t);\n    },\n        si = function hex() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(pr, t);\n    },\n        ci = function hsl() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(mr, t);\n    },\n        li = function hsla() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(vr, t);\n    },\n        fi = function hsv() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(yr, t);\n    },\n        hi = function hsva() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(gr, t);\n    },\n        di = function cubic() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(br, t);\n    },\n        pi = function ilinear() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(_r, t);\n    },\n        mi = function linear() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Tr, t);\n    },\n        vi = function namedColor() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Cr, t);\n    },\n        yi = function now() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Sr, t);\n    },\n        gi = function opacity() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Dr, t);\n    },\n        _i = function asc() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Rr, t);\n    },\n        bi = function desc() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Fr, t);\n    },\n        xi = function noOrder() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Lr, t);\n    },\n        ki = function width() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Br, t);\n    },\n        Ti = function reverse() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Yr, t);\n    },\n        wi = function property() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(er, t);\n    },\n        Ci = function globalQuantiles() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Kr, t);\n    },\n        Ei = function viewportQuantiles() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(rn, t);\n    },\n        Mi = function globalEqIntervals() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Jr, t);\n    },\n        Ai = function viewportEqIntervals() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(tn, t);\n    },\n        Si = function globalStandardDev() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(en, t);\n    },\n        Pi = function viewportStandardDev() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(nn, t);\n    },\n        Ii = function ramp() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(mn, t);\n    },\n        Ni = function time() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(bn, t);\n    },\n        Di = function timeRange() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(xn, t);\n    },\n        Ri = function top() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Tn, t);\n    },\n        Fi = function fade() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(En, t);\n    },\n        Oi = function animation() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(In, t);\n    },\n        Li = function log() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Nn, t);\n    },\n        Bi = function sqrt() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Dn, t);\n    },\n        Vi = function sin() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Rn, t);\n    },\n        Gi = function cos() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Fn, t);\n    },\n        Ui = function tan() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(On, t);\n    },\n        zi = function sign() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Ln, t);\n    },\n        qi = function abs() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Bn, t);\n    },\n        ji = function isNull() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Vn, t);\n    },\n        Wi = function not() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Gn, t);\n    },\n        Hi = function floor() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Un, t);\n    },\n        Yi = function ceil() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(zn, t);\n    },\n        Zi = function variable() {\n      return function variable_variable(e) {\n        if (checkMaxArguments(arguments, 1, \"variable\"), checkString(\"variable\", \"name\", 0, e), \"\" === e) throw new he(\"variable(): invalid parameter, zero-length string\", de.INCORRECT_VALUE);\n\n        var t,\n            r = function resolve(r) {\n          if (!r[e]) throw new he(\"variable() with name '\".concat(e, \"' doesn't exist\"), de.MISSING_REQUIRED);\n          t = r[e];\n        },\n            n = function _getDependencies() {\n          return [t];\n        },\n            a = {\n          set: function set(e, r, n) {\n            if (\"parent\" === r) e[r] = n;else if (\"notify\" === r) e[r] = n;else {\n              if (!t || !t[r]) return !1;\n              t[r] = n;\n            }\n            return !0;\n          },\n          get: function get(e, a) {\n            switch (a) {\n              case \"propertyName\":\n                return t.propertyName;\n\n              case \"name\":\n                return t._dimension ? t.propertyName : t.name;\n\n              case \"parent\":\n              case \"notify\":\n              case \"blendTo\":\n                return e[a];\n\n              case \"_resolveAliases\":\n                return r;\n\n              case \"_getDependencies\":\n                return n;\n\n              default:\n                if (void 0 !== t) {\n                  var i = t[a];\n                  if (void 0 !== i) return i.bind ? i.bind(t) : i;\n                }\n\n                return e[a];\n            }\n          }\n        };\n\n        return new Proxy(new qn(), a);\n      }.apply(void 0, arguments);\n    },\n        Xi = function viewportAvg() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Wn, t);\n    },\n        Qi = function viewportMax() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Hn, t);\n    },\n        $i = function viewportMin() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Yn, t);\n    },\n        Ji = function viewportSum() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Zn, t);\n    },\n        Ki = function viewportCount() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Xn, t);\n    },\n        eo = function viewportPercentile() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(Qn, t);\n    },\n        to = function viewportHistogram() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ea, t);\n    },\n        ro = function viewportFeatures() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(aa, t);\n    },\n        no = function globalAvg() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(oa, t);\n    },\n        ao = function globalMax() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(sa, t);\n    },\n        io = function globalMin() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ca, t);\n    },\n        oo = function globalSum() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(la, t);\n    },\n        uo = function globalCount() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ua, t);\n    },\n        so = function globalPercentile() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(fa, t);\n    },\n        co = function globalHistogram() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ta, t);\n    },\n        lo = function zoom() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ha, t);\n    },\n        fo = function scaled() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(va, t);\n    },\n        ho = function zoomrange() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ma, t);\n    },\n        po = function placement() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(da, t);\n    },\n        mo = function translate() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ga, t);\n    },\n        vo = function rotate() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(_a, t);\n    },\n        yo = function alphaNormalize() {\n      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n      return Ke()(ya, t);\n    },\n        go = new dr(Number.MAX_SAFE_INTEGER),\n        _o = new dr(1),\n        bo = new dr(0),\n        xo = new dr(Math.PI),\n        ko = new dr(Math.E),\n        To = new fn(un.bicycle),\n        wo = new fn(un.building),\n        Co = new fn(un.bus),\n        Eo = new fn(un.car),\n        Mo = new fn(un.circle),\n        Ao = new fn(un.circleOutline),\n        So = new fn(un.cross),\n        Po = new fn(un.flag),\n        Io = new fn(un.house),\n        No = new fn(un.marker),\n        Do = new fn(un.markerOutline),\n        Ro = new fn(un.plus),\n        Fo = new fn(un.square),\n        Oo = new fn(un.squareOutline),\n        Lo = new fn(un.star),\n        Bo = new fn(un.starOutline),\n        Vo = new fn(un.triangle),\n        Go = new fn(un.triangleOutline),\n        Uo = new da(ii(0), ii(0)),\n        zo = new da(ii(0), ii(1)),\n        qo = r(10),\n        jo = r.n(qo),\n        Wo = [],\n        Ho = {};\n\n    Object.keys(u).filter(function (e) {\n      return e[0] === e[0].toLowerCase();\n    }).map(function (e) {\n      Ho[e.toLocaleLowerCase()] = u[e];\n    }), Ho.true = _o, Ho.false = bo, Ho.align_center = Uo, Ho.align_bottom = zo, Ho.pi = xo, Ho.e = ko, Ho.hold = go, Ho.bicycle = To, Ho.building = wo, Ho.bus = Co, Ho.car = Eo, Ho.circle = Mo, Ho.circle_outline = Ao, Ho.cross = So, Ho.flag = Po, Ho.house = Io, Ho.marker = No, Ho.marker_outline = Do, Ho.plus = Ro, Ho.square = Fo, Ho.square_outline = Oo, Ho.star = Lo, Ho.star_outline = Bo, Ho.triangle = Vo, Ho.triangle_outline = Go;\n    var Yo = ut.prototype.blendTo;\n\n    function parser_parseVizExpression(e) {\n      prepareJsep();\n      var t = implicitCast(parseNode(jo()(e)));\n      return cleanJsep(), t;\n    }\n\n    function parseVizNamedExpr(e, t) {\n      if (\":\" !== t.operator) throw new V(\"Invalid syntax.\");\n      t.left.name.length && \"@\" === t.left.name[0] && (t.left.name = \"__cartovl_variable_\" + t.left.name.substr(1));\n      var r = t.left.name;\n      if (!r) throw new V(\"Invalid syntax.\");\n\n      if (r.startsWith(\"__cartovl_variable_\")) {\n        if ((r = t.left.name.substr(\"__cartovl_variable_\".length)) in e.variables) throw new V(\"Variable '\".concat(r, \"' is already defined.\"));\n        e.variables[r] = implicitCast(parseNode(t.right));\n      } else {\n        if (r in e) throw new V(\"Property '\".concat(r, \"' is already defined.\"));\n        var n = parseNode(t.right);\n        e[r] = \"resolution\" === r ? n : implicitCast(n);\n      }\n    }\n\n    function parseNode(e) {\n      if (\"CallExpression\" === e.type) return function parseFunctionCall(e) {\n        var t = e.callee.name.toLowerCase();\n        if (Wo.includes(t)) return e.arguments.map(function (e) {\n          return parseNode(e);\n        })[0];\n        var r = e.arguments.map(function (e) {\n          return parseNode(e);\n        });\n        if (Ho[t]) return Ho[t].apply(Ho, l()(r));\n        throw new V(\"Invalid function name '\".concat(e.callee.name, \"'.\"));\n      }(e);\n      if (\"Literal\" === e.type) return e.value;\n      if (\"ArrayExpression\" === e.type) return e.elements.map(function (e) {\n        return parseNode(e);\n      });\n      if (\"BinaryExpression\" === e.type) return function parseBinaryOperation(e) {\n        var t = parseNode(e.left),\n            r = parseNode(e.right);\n\n        switch (e.operator.toLowerCase()) {\n          case \"*\":\n            return Sa(t, r);\n\n          case \"/\":\n            return Pa(t, r);\n\n          case \"+\":\n            return Ia(t, r);\n\n          case \"-\":\n            return Na(t, r);\n\n          case \"%\":\n            return Ra(t, r);\n\n          case \"^\":\n            return Da(t, r);\n\n          case \">\":\n            return Fa(t, r);\n\n          case \">=\":\n            return Oa(t, r);\n\n          case \"<\":\n            return La(t, r);\n\n          case \"<=\":\n            return Ba(t, r);\n\n          case \"==\":\n            return Va(t, r);\n\n          case \"!=\":\n            return Ga(t, r);\n\n          case \"and\":\n            return Ua(t, r);\n\n          case \"or\":\n            return za(t, r);\n\n          case \"in\":\n            return Ea(t, r);\n\n          case \"nin\":\n            return Ma(t, r);\n\n          default:\n            throw new V(\"Invalid binary operator '\".concat(e.operator, \"'.\"));\n        }\n      }(e);\n      if (\"UnaryExpression\" === e.type) return function parseUnaryOperation(e) {\n        switch (e.operator) {\n          case \"-\":\n            return Sa(-1, parseNode(e.argument));\n\n          case \"+\":\n            return parseNode(e.argument);\n\n          default:\n            throw new V(\"Invalid unary operator '\".concat(e.operator, \"'.\"));\n        }\n      }(e);\n      if (\"Identifier\" === e.type) return function parseIdentifier(e) {\n        if (e.name.length && \"@\" === e.name[0] && (e.name = \"__cartovl_variable_\" + e.name.substr(1)), e.name.startsWith(\"__cartovl_variable_\")) return Zi(e.name.substr(\"__cartovl_variable_\".length));\n        if (\"#\" === e.name[0]) return new pr(e.name);\n        if (\"$\" === e.name[0]) return wi(e.name.substring(1));\n        if (jr[e.name.toUpperCase()]) return jr[e.name.toUpperCase()];\n        if (Ho[e.name.toLowerCase()]) return Ho[e.name.toLowerCase()];\n        if (wr.includes(e.name.toLowerCase())) return new Cr(e.name.toLowerCase());\n        throw new V(\"Invalid expression '\".concat(JSON.stringify(e), \"'.\"));\n      }(e);\n      throw new V(\"Invalid expression '\".concat(JSON.stringify(e), \"'.\"));\n    }\n\n    function prepareJsep() {\n      jo.a.addBinaryOp(\":\", 0), jo.a.addBinaryOp(\"^\", 11), jo.a.addBinaryOp(\"or\", 1), jo.a.addBinaryOp(\"OR\", 1), jo.a.addBinaryOp(\"and\", 2), jo.a.addBinaryOp(\"AND\", 2), jo.a.addBinaryOp(\"in\", 13), jo.a.addBinaryOp(\"IN\", 1), jo.a.addBinaryOp(\"nin\", 13), jo.a.addBinaryOp(\"NIN\", 13), jo.a.addIdentifierChar(\"@\"), jo.a.addIdentifierChar(\"#\"), jo.a.removeLiteral(\"true\"), jo.a.removeLiteral(\"false\");\n    }\n\n    function cleanJsep() {\n      jo.a.removeBinaryOp(\"in\"), jo.a.removeBinaryOp(\"IN\"), jo.a.removeBinaryOp(\"nin\"), jo.a.removeBinaryOp(\"NIN\"), jo.a.removeBinaryOp(\"and\"), jo.a.removeBinaryOp(\"AND\"), jo.a.removeBinaryOp(\"or\"), jo.a.removeBinaryOp(\"OR\"), jo.a.removeBinaryOp(\"^\"), jo.a.removeBinaryOp(\":\"), jo.a.removeIdentifierChar(\"@\"), jo.a.removeIdentifierChar(\"#\"), jo.a.addLiteral(\"true\"), jo.a.addLiteral(\"false\");\n    }\n\n    ut.prototype.blendTo = function (e) {\n      \"string\" == typeof e && (e = parser_parseVizExpression(e));\n\n      for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];\n\n      return Yo.bind(this).apply(void 0, [e].concat(r));\n    };\n\n    var Zo = r(40),\n        Xo = r.n(Zo),\n        Qo = r(41),\n        $o = r.n(Qo),\n        Jo = r(42),\n        Ko = r.n(Jo),\n        eu = r(43),\n        tu = r.n(eu),\n        ru = r(44),\n        nu = r.n(ru),\n        au = r(45),\n        iu = r.n(au),\n        ou = function () {\n      function Viz(e) {\n        var t = this;\n        p()(this, Viz);\n\n        var r = this._getVizDefinition(e);\n\n        this._checkVizSpec(r), Object.keys(r).forEach(function (e) {\n          t._defineProperty(e, r[e]);\n        }), Object.keys(r).includes(\"variables\") || this._defineProperty(\"variables\", {}), this.updated = !0, this._changeCallback = null, this._updateRootExpressionList(), this._updateRootExpressions(), this._resolveAliases(), this._validateAliasDAG();\n      }\n\n      return v()(Viz, [{\n        key: \"loadImages\",\n        value: function loadImages() {\n          return Promise.all(this._getRootExpressions().map(function (e) {\n            return e.loadImages();\n          }));\n        }\n      }, {\n        key: \"_ignoreChangeRejections\",\n        value: function _ignoreChangeRejections() {\n          return {};\n        }\n      }, {\n        key: \"_defineProperty\",\n        value: function _defineProperty(e, t) {\n          var r = this;\n\n          if (\"variables\" === e || ra.includes(e)) {\n            Object.defineProperty(this, e, {\n              get: function get() {\n                return r[\"_\" + e];\n              },\n              set: function set(t) {\n                r[\"_\" + e] = implicitCast(t), r._changed().catch(r._ignoreChangeRejections);\n              }\n            });\n            var n = t;\n\n            if (\"variables\" === e) {\n              var a = !1;\n              n = new Proxy({}, {\n                get: function get(e, t) {\n                  return e[t];\n                },\n                set: function set(e, t, n) {\n                  return (n = implicitCast(n)) instanceof ut && (n._variableName = t), e[t] = n, r[\"__cartovl_variable_\" + t] = n, a && r._changed().catch(r._ignoreChangeRejections), !0;\n                }\n              }), Object.keys(t).map(function (e) {\n                n[e] = t[e];\n              }), a = !0;\n            }\n\n            this[\"_\" + e] = n;\n          }\n        }\n      }, {\n        key: \"_getRootExpressions\",\n        value: function _getRootExpressions() {\n          return this._rootExpressions;\n        }\n      }, {\n        key: \"_getRootStyleExpressions\",\n        value: function _getRootStyleExpressions() {\n          return this._rootStyleExpressions;\n        }\n      }, {\n        key: \"_updateRootExpressions\",\n        value: function _updateRootExpressions() {\n          var e = this;\n\n          this._getRootExpressions().forEach(function (t) {\n            t.parent = e, t.notify = e._changed.bind(e);\n          });\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return this._getRootStyleExpressions().some(function (e) {\n            return e.isAnimated();\n          });\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return this._getRootStyleExpressions().some(function (e) {\n            return e.isPlaying();\n          });\n        }\n      }, {\n        key: \"onChange\",\n        value: function onChange(e) {\n          this._changeCallback = e;\n        }\n      }, {\n        key: \"_changed\",\n        value: function _changed() {\n          return this._updateRootExpressionList(), this._resolveAliases(), this._validateAliasDAG(), this._changeCallback ? this._changeCallback(this) : Promise.resolve(null);\n        }\n      }, {\n        key: \"_updateRootExpressionList\",\n        value: function _updateRootExpressionList() {\n          var e = this,\n              t = l()(ra).map(function (t) {\n            return e[t];\n          }),\n              r = l()(na).map(function (t) {\n            return e[t];\n          }),\n              n = l()(Object.values(this.variables));\n          this._rootExpressions = l()(t).concat(l()(n)), this._rootStyleExpressions = r;\n        }\n      }, {\n        key: \"getMinimumNeededSchema\",\n        value: function getMinimumNeededSchema() {\n          return this._getRootExpressions().filter(function (e) {\n            return e && e._getMinimumNeededSchema;\n          }).map(function (e) {\n            return e._getMinimumNeededSchema();\n          }).reduce(Ee.union, Ee.IDENTITY);\n        }\n      }, {\n        key: \"setDefaultsIfRequired\",\n        value: function setDefaultsIfRequired(e) {\n          if (this._geomType = e, !this._appliedDefaults) {\n            var t = this._getDefaultGeomStyle(e);\n\n            t && (this._appliedDefaults = !0, this.color.default && (this.color = t.COLOR_EXPRESSION()), this.width.default && (this.width = t.WIDTH_EXPRESSION()), this.strokeColor.default && (this.strokeColor = t.STROKE_COLOR_EXPRESSION()), this.strokeWidth.default && (this.strokeWidth = t.STROKE_WIDTH_EXPRESSION()), this._updateRootExpressions());\n          }\n        }\n      }, {\n        key: \"_getDefaultGeomStyle\",\n        value: function _getDefaultGeomStyle(e) {\n          return e === pe.POINT ? {\n            COLOR_EXPRESSION: function COLOR_EXPRESSION() {\n              return _markDefault(si(\"#EE4D5A\"));\n            },\n            WIDTH_EXPRESSION: function WIDTH_EXPRESSION() {\n              return _markDefault(ba(7));\n            },\n            STROKE_COLOR_EXPRESSION: function STROKE_COLOR_EXPRESSION() {\n              return _markDefault(si(\"#FFF\"));\n            },\n            STROKE_WIDTH_EXPRESSION: function STROKE_WIDTH_EXPRESSION() {\n              return _markDefault(ba(1));\n            }\n          } : e === pe.LINE ? {\n            COLOR_EXPRESSION: function COLOR_EXPRESSION() {\n              return _markDefault(si(\"#4CC8A3\"));\n            },\n            WIDTH_EXPRESSION: function WIDTH_EXPRESSION() {\n              return _markDefault(ba(1.5));\n            },\n            STROKE_COLOR_EXPRESSION: function STROKE_COLOR_EXPRESSION() {\n              return _markDefault(si(\"#FFF\"));\n            },\n            STROKE_WIDTH_EXPRESSION: function STROKE_WIDTH_EXPRESSION() {\n              return _markDefault(ba(1));\n            }\n          } : e === pe.POLYGON ? {\n            COLOR_EXPRESSION: function COLOR_EXPRESSION() {\n              return _markDefault(si(\"#826DBA\"));\n            },\n            WIDTH_EXPRESSION: function WIDTH_EXPRESSION() {\n              return _markDefault(ba(1));\n            },\n            STROKE_COLOR_EXPRESSION: function STROKE_COLOR_EXPRESSION() {\n              return _markDefault(si(\"#FFF\"));\n            },\n            STROKE_WIDTH_EXPRESSION: function STROKE_WIDTH_EXPRESSION() {\n              return _markDefault(ba(1));\n            }\n          } : void 0;\n        }\n      }, {\n        key: \"_resolveAliases\",\n        value: function _resolveAliases() {\n          var e = this;\n\n          this._getRootExpressions().forEach(function (t) {\n            t._resolveAliases(e.variables);\n          });\n        }\n      }, {\n        key: \"_validateAliasDAG\",\n        value: function _validateAliasDAG() {\n          for (var e = new Set(), t = new Set(), r = function visit(r) {\n            if (!e.has(r)) {\n              if (t.has(r)) throw new Ae(\"Viz contains a circular dependency\");\n              t.add(r), r._getDependencies().forEach(visit), e.add(r);\n            }\n          }, n = this._getRootExpressions().map(function (e) {\n            return e._getDependencies();\n          }).reduce(function (e, t) {\n            return l()(e).concat(l()(t));\n          }, []); n.length;) r(n.pop());\n        }\n      }, {\n        key: \"_bindMetadata\",\n        value: function _bindMetadata(e) {\n          var t = this;\n          this._colorShader = null, this._widthShader = null, this._strokeColorShader = null, this._strokeWidthShader = null, this._filterShader = null, this._symbolShader = null, this._pointShader = null, this._lineShader = null, this._polygonShader = null, this.metadata = e, this._getRootExpressions().forEach(function (e) {\n            return e._bindMetadata(t.metadata);\n          }), function checkVizPropertyTypes(e) {\n            var t = {\n              color: \"color\",\n              filter: \"number\",\n              order: \"orderer\",\n              resolution: \"number\",\n              strokeColor: \"color\",\n              strokeWidth: \"number\",\n              symbol: \"image\",\n              symbolPlacement: \"placement\",\n              transform: \"transformation\",\n              width: \"number\"\n            };\n            Object.keys(t).forEach(function (r) {\n              var n = e[r].type,\n                  a = t[r];\n              if (n !== a) throw new he(\"Viz property '\".concat(r, \"': must be of type '\").concat(a, \"' but it was of type '\").concat(n, \"'\"), de.INCORRECT_TYPE);\n            });\n          }(this);\n        }\n      }, {\n        key: \"_compileShader\",\n        value: function _compileShader(e, t, r) {\n          return this[\"_\" + e] || (this[\"_\" + e] = compileShader(this.gl, t, r)), this[\"_\" + e];\n        }\n      }, {\n        key: \"replaceChild\",\n        value: function replaceChild(e, t) {\n          var r = this;\n\n          if (Object.values(this.variables).includes(e)) {\n            var n = Object.keys(this.variables).find(function (t) {\n              return r.variables[t] === e;\n            });\n            this.variables[n] = t, t.parent = this, t.notify = e.notify;\n          } else {\n            var a = ra.find(function (t) {\n              return r[t] === e;\n            });\n            if (!a) throw new Ae(\"No child found\");\n            this[a] = t, t.parent = this, t.notify = e.notify;\n          }\n        }\n      }, {\n        key: \"_getVizDefinition\",\n        value: function _getVizDefinition(e) {\n          if (be.isUndefined(e)) return this._setDefaults({});\n          if (be.isObject(e)) return this._setDefaults(e);\n          if (be.isString(e)) return this._setDefaults(function parseVizDefinition(e) {\n            prepareJsep();\n            var t = jo()(function cleanComments(e) {\n              for (var t = {\n                singleQuote: !1,\n                doubleQuote: !1,\n                blockComment: !1,\n                lineComment: !1,\n                escape: 0\n              }, r = 0, n = (e = (\"_\" + e + \"_\").split(\"\")).length; r < n; r++) if (t.singleQuote) \"\\\\\" === e[r] ? t.escape++ : \"'\" === e[r] && t.escape % 2 == 0 && (t.singleQuote = !1, t.escape = 0);else if (t.doubleQuote) \"\\\\\" === e[r] ? t.escape++ : '\"' === e[r] && t.escape % 2 == 0 && (t.doubleQuote = !1, t.escape = 0);else if (t.blockComment) \"*\" === e[r] && \"/\" === e[r + 1] && (e[r + 1] = \"\", t.blockComment = !1), e[r] = \"\";else if (t.lineComment) \"\\n\" !== e[r + 1] && \"\\r\" !== e[r + 1] || (t.lineComment = !1), r + 1 < n && (e[r] = \"\");else if (t.doubleQuote = '\"' === e[r], t.singleQuote = \"'\" === e[r], \"/\" === e[r]) {\n                if (\"*\" === e[r + 1]) {\n                  e[r] = \"\", t.blockComment = !0;\n                  continue;\n                }\n\n                if (\"/\" === e[r + 1]) {\n                  e[r] = \"\", t.lineComment = !0;\n                  continue;\n                }\n              }\n\n              return e.join(\"\").slice(1, -1);\n            }(e)),\n                r = {\n              variables: {}\n            };\n            return \"Compound\" === t.type ? t.body.map(function (e) {\n              return parseVizNamedExpr(r, e);\n            }) : parseVizNamedExpr(r, t), cleanJsep(), r;\n          }(e));\n          throw new he(\"viz 'definition' should be a vizSpec object or a valid viz string.\", de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_setDefaults\",\n        value: function _setDefaults(e) {\n          return be.isUndefined(e.color) && (e.color = be.isUndefined(e.symbol) ? function DEFAULT_COLOR_EXPRESSION() {\n            return _markDefault(Ta(0, 0, 0));\n          }() : noOverrideColor()), be.isUndefined(e.width) && (e.width = function DEFAULT_WIDTH_EXPRESSION() {\n            return _markDefault(ba(1));\n          }()), be.isUndefined(e.strokeColor) && (e.strokeColor = function DEFAULT_STROKE_COLOR_EXPRESSION() {\n            return _markDefault(Ta(0, 0, 0));\n          }()), be.isUndefined(e.strokeWidth) && (e.strokeWidth = function DEFAULT_STROKE_WIDTH_EXPRESSION() {\n            return _markDefault(ba(0));\n          }()), be.isUndefined(e.order) && (e.order = function DEFAULT_ORDER_EXPRESSION() {\n            return _markDefault(xi());\n          }()), be.isUndefined(e.filter) && (e.filter = function DEFAULT_FILTER_EXPRESSION() {\n            return _markDefault(ii(1));\n          }()), be.isUndefined(e.resolution) && (e.resolution = function DEFAULT_RESOLUTION() {\n            return _markDefault(ba(1));\n          }()), be.isUndefined(e.symbol) && (e.symbol = function DEFAULT_SYMBOL_EXPRESSION() {\n            return _markDefault(new fn(un.circle));\n          }()), be.isUndefined(e.symbolPlacement) && (e.symbolPlacement = function DEFAULT_SYMBOLPLACEMENT_EXPRESSION() {\n            return _markDefault(new da(ii(0), ii(1)));\n          }()), be.isUndefined(e.transform) && (e.transform = function DEFAULT_TRANSFORM_EXPRESSION() {\n            return _markDefault(new ga(ii(0), ii(0)));\n          }()), e.variables = e.variables || {}, e;\n        }\n      }, {\n        key: \"_checkResolution\",\n        value: function _checkResolution(e) {\n          var t = e instanceof ut ? e.eval() : e;\n          if (!be.isNumber(t)) throw new he(\"'resolution' property must be a number.\", de.INCORRECT_TYPE);\n          if (e <= 0) throw new he(\"'resolution' is \".concat(e, \", must be greater than \").concat(0, \".\"), de.INCORRECT_VALUE);\n          if (e >= 256) throw new he(\"'resolution' is \".concat(e, \", must be lower than \").concat(256, \".\"), de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_applyImplitCastToNumericProperties\",\n        value: function _applyImplitCastToNumericProperties(e) {\n          e.filter = implicitCast(e.filter), e.resolution = implicitCast(e.resolution), e.strokeWidth = implicitCast(e.strokeWidth), e.symbol = implicitCast(e.symbol), e.symbolPlacement = implicitCast(e.symbolPlacement), e.transform = implicitCast(e.transform), e.width = implicitCast(e.width);\n        }\n      }, {\n        key: \"_checkVizSpec\",\n        value: function _checkVizSpec(e) {\n          for (var t in this._applyImplitCastToNumericProperties(e), this._checkResolution(e.resolution), ra.forEach(function (t) {\n            if (!(e[t] instanceof ut)) throw new he(\"'\".concat(t, \"' parameter is not a valid viz Expresion.\"), de.INCORRECT_TYPE);\n          }), e) \"variables\" !== t && -1 === ra.indexOf(t) && console.warn(\"Property '\".concat(t, \"' is not supported\"));\n        }\n      }, {\n        key: \"toString\",\n        value: function toString() {\n          var e = this,\n              t = Object.keys(this.variables).map(function (t) {\n            return \"@\".concat(t, \": \").concat(e.variables[t].toString());\n          }),\n              r = ra.map(function (t) {\n            return \"\".concat(t, \": \").concat(e[t].toString());\n          });\n          return l()(t).concat(l()(r)).join(\"\\n\");\n        }\n      }, {\n        key: \"geometryType\",\n        get: function get() {\n          return this._geomType;\n        }\n      }, {\n        key: \"colorMetaShader\",\n        get: function get() {\n          return this._compileShader(\"colorShader\", Qe.styler.colorShaderGLSL, {\n            color: this.color\n          });\n        }\n      }, {\n        key: \"widthMetaShader\",\n        get: function get() {\n          return this._compileShader(\"widthShader\", Qe.styler.widthShaderGLSL, {\n            width: this.width\n          });\n        }\n      }, {\n        key: \"strokeColorMetaShader\",\n        get: function get() {\n          return this._compileShader(\"strokeColorShader\", Qe.styler.colorShaderGLSL, {\n            color: this.strokeColor\n          });\n        }\n      }, {\n        key: \"strokeWidthMetaShader\",\n        get: function get() {\n          return this._compileShader(\"strokeWidthShader\", Qe.styler.widthShaderGLSL, {\n            width: this.strokeWidth\n          });\n        }\n      }, {\n        key: \"filterMetaShader\",\n        get: function get() {\n          return this._compileShader(\"filterShader\", Qe.styler.filterShaderGLSL, {\n            filter: this.filter\n          });\n        }\n      }, {\n        key: \"symbolMetaShader\",\n        get: function get() {\n          return this._compileShader(\"symbolShader\", Qe.symbolizer.symbolShaderGLSL, {\n            symbol: this.symbol,\n            symbolPlacement: this.symbolPlacement,\n            transform: this.transform\n          });\n        }\n      }, {\n        key: \"pointMetaShader\",\n        get: function get() {\n          return this._compileShader(\"pointShader\", {\n            vertexShader: Xo.a,\n            fragmentShader: $o.a\n          }, {\n            transform: this.transform\n          });\n        }\n      }, {\n        key: \"lineMetaShader\",\n        get: function get() {\n          return this._compileShader(\"lineShader\", {\n            vertexShader: Ko.a,\n            fragmentShader: tu.a\n          }, {\n            transform: this.transform\n          });\n        }\n      }, {\n        key: \"polygonMetaShader\",\n        get: function get() {\n          return this._compileShader(\"polygonShader\", {\n            vertexShader: nu.a,\n            fragmentShader: iu.a\n          }, {\n            transform: this.transform\n          });\n        }\n      }]), Viz;\n    }();\n\n    function _markDefault(e) {\n      return e.default = !0, e;\n    }\n\n    var uu = function mitt(e) {\n      return e = e || Object.create(null), {\n        on: function on(t, r) {\n          (e[t] || (e[t] = [])).push(r);\n        },\n        off: function off(t, r) {\n          e[t] && e[t].splice(e[t].indexOf(r) >>> 0, 1);\n        },\n        emit: function emit(t, r) {\n          (e[t] || []).slice().map(function (e) {\n            e(r);\n          }), (e[\"*\"] || []).slice().map(function (e) {\n            e(t, r);\n          });\n        }\n      };\n    },\n        su = function Base() {\n      p()(this, Base);\n    };\n\n    function runViewportAggregations(e) {\n      var t = function _getViewportExpressions(e) {\n        var t = [];\n        return e.map(function dfs(e) {\n          e._isViewport ? t.push(e) : e._getChildren().map(dfs);\n        }), t;\n      }(e.viz._getRootExpressions());\n\n      t.length && (!function ViewportAggCalculator_reset(e, t) {\n        var r = t.viz.metadata;\n        e.forEach(function (e) {\n          return e._resetViewportAgg(r, t);\n        });\n      }(t, e), function _runInActiveDataframes(e, t) {\n        var r = t.getActiveDataframes(),\n            n = function _runInDataframes(e, t, r) {\n          var n = new Set(),\n              a = t.viz,\n              i = new Set();\n          return r.forEach(function (t) {\n            !function _runInDataframe(e, t, r, n, a) {\n              for (var i = function _loop(i) {\n                var o = e.metadata.idProperty,\n                    u = r.properties[o][i],\n                    s = n.has(u);\n                if (s) return \"continue\";\n                var c = !r.inViewport(i);\n                if (c) return \"continue\";\n                n.add(u);\n                var l = r.getFeature(i),\n                    f = e.filter.eval(l) < fu;\n                if (f) return \"continue\";\n                a.add(l[o]), t.forEach(function (e) {\n                  return e.accumViewportAgg(l);\n                });\n              }, o = 0; o < r.numFeatures; o++) i(o);\n            }(a, e, t, n, i);\n          }), i;\n        }(e, t, r);\n\n        !function _runImprovedForPartialFeatures(e, t, r) {\n          if (0 === r.size) return;\n          if (t.viz.geometryType === pe.POINT) return;\n          var n = e.filter(function (e) {\n            return e.isA(aa);\n          });\n          n.length > 0 && function _runForPartialViewportFeatures(e, t, r) {\n            e.forEach(function (e) {\n              return e._resetViewportAgg(null, t);\n            });\n            var n = t.getAllPiecesPerFeature(r);\n            e.forEach(function (e) {\n              for (var t in n) e.accumViewportAgg(n[t]);\n            });\n          }(n, t, r);\n        }(e, t, n);\n      }(t, e));\n    }\n\n    var cu = Date.now(),\n        lu = cu;\n    requestAnimationFrame(function refreshClock() {\n      lu = (Date.now() - cu) / 1e3;\n      requestAnimationFrame(refreshClock);\n    });\n\n    var fu = .5,\n        hu = 1024,\n        du = 8,\n        pu = function () {\n      function Renderer(e) {\n        p()(this, Renderer), e && (this.gl = getValidWebGLContextOrThrow(e), this._initGL(this.gl)), this._center = {\n          x: 0,\n          y: 0\n        }, this._zoom = 1, this.RTT_WIDTH = hu, this.dataframes = [];\n      }\n\n      return v()(Renderer, [{\n        key: \"initialize\",\n        value: function initialize(e) {\n          e = getValidWebGLContextOrThrow(null, e), this._initGL(e);\n        }\n      }, {\n        key: \"_initGL\",\n        value: function _initGL(e) {\n          this.gl = e, this._initShaders(), this.auxFB = e.createFramebuffer(), this.bigTriangleVBO = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.bigTriangleVBO);\n          var t = new Float32Array([10, -10, 0, 10, -10, -10]);\n          e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), this.zeroTex = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.zeroTex), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(4)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), this._AATex = e.createTexture(), this._AAFB = e.createFramebuffer(), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindTexture(e.TEXTURE_2D, this.zeroTex);\n        }\n      }, {\n        key: \"_getAspect\",\n        value: function _getAspect() {\n          return this.gl ? this.gl.canvas.width / this.gl.canvas.height : 1;\n        }\n      }, {\n        key: \"renderLayer\",\n        value: function renderLayer(e, t) {\n          var r = this;\n          this.drawMetadata = t;\n          var n = e.getActiveDataframes(),\n              a = e.viz;\n\n          if (a) {\n            var i = this.gl;\n\n            if (this._updateDataframeMatrices(n), e.parseVizExpression = parser_parseVizExpression, runViewportAggregations(e), n.length) {\n              a._getRootExpressions().map(function (e) {\n                return e._dataReady();\n              }), i.enable(i.CULL_FACE), i.disable(i.BLEND), i.disable(i.DEPTH_TEST), i.disable(i.STENCIL_TEST), i.depthMask(!1), i.bindFramebuffer(i.FRAMEBUFFER, this.auxFB);\n\n              var o = function styleDataframe(e, n, a, o) {\n                var u = a.shader,\n                    s = a.textureIds;\n                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, n, 0), i.viewport(0, 0, hu, e.getSize().height), i.clear(i.COLOR_BUFFER_BIT), i.useProgram(u.program), t.freeTexUnit = Object.keys(s).length, o._setTimestamp(lu), o._preDraw(u.program, t, i), Object.keys(s).forEach(function (t, r) {\n                  i.activeTexture(i.TEXTURE0 + r), i.bindTexture(i.TEXTURE_2D, e.getPropertyTexture(t)), i.uniform1i(s[t], r);\n                }), i.enableVertexAttribArray(u.vertexAttribute), i.bindBuffer(i.ARRAY_BUFFER, r.bigTriangleVBO), i.vertexAttribPointer(u.vertexAttribute, 2, i.FLOAT, !1, 0, 0), i.drawArrays(i.TRIANGLES, 0, 3), i.disableVertexAttribArray(u.vertexAttribute);\n              };\n\n              if (n.map(function (e) {\n                return o(e, e.texColor, a.colorMetaShader, a.color);\n              }), n[0].type !== pe.POLYGON && n.map(function (e) {\n                return o(e, e.texWidth, a.widthMetaShader, a.width);\n              }), n[0].type !== pe.LINE && (n.map(function (e) {\n                return o(e, e.texStrokeColor, a.strokeColorMetaShader, a.strokeColor);\n              }), n.map(function (e) {\n                return o(e, e.texStrokeWidth, a.strokeWidthMetaShader, a.strokeWidth);\n              })), n.map(function (e) {\n                return o(e, e.texFilter, a.filterMetaShader, a.filter);\n              }), i.blendFunc(i.ONE, i.ONE_MINUS_SRC_ALPHA), i.enable(i.BLEND), e.type === pe.POINT) i.bindFramebuffer(i.FRAMEBUFFER, null), i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight);else {\n                var u = (window.devicePixelRatio || 1) >= 2 ? 1 : 2;\n                i.bindFramebuffer(i.FRAMEBUFFER, this._AAFB);\n                var s = [i.drawingBufferWidth, i.drawingBufferHeight],\n                    c = s[0],\n                    l = s[1];\n\n                if (c !== this._width || l !== this._height) {\n                  i.bindTexture(i.TEXTURE_2D, this._AATex), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, c * u, l * u, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, this._AATex, 0);\n                  var f = i.createRenderbuffer();\n                  i.bindRenderbuffer(i.RENDERBUFFER, f), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_COMPONENT16, c * u, l * u), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, f);\n                  var h = [c, l];\n                  this._width = h[0], this._height = h[1];\n                }\n\n                i.viewport(0, 0, c * u, l * u), i.clear(i.COLOR_BUFFER_BIT);\n              }\n\n              var d = function getOrderingRenderBuckets(e) {\n                var t = e.viz.order,\n                    r = [0],\n                    n = [1030];\n                t.isA(Rr) ? (r = Array.from({\n                  length: 64\n                }, function (e, t) {\n                  return 2 * (63 - t);\n                }), n = Array.from({\n                  length: 64\n                }, function (e, t) {\n                  return 0 === t ? 1030 : 2 * (63 - t + 1);\n                })) : t.isA(Fr) && (r = Array.from({\n                  length: 64\n                }, function (e, t) {\n                  return 2 * t;\n                }), n = Array.from({\n                  length: 64\n                }, function (e, t) {\n                  return 63 === t ? 1030 : 2 * (t + 1);\n                }));\n                return {\n                  orderingMins: r,\n                  orderingMaxs: n\n                };\n              }(e),\n                  p = d.orderingMins,\n                  m = d.orderingMaxs;\n\n              n[0].type !== pe.LINE && n[0].type !== pe.POLYGON || (i.clearDepth(1), i.depthRange(0, 1), i.depthFunc(i.NOTEQUAL), i.depthMask(!0), i.enable(i.DEPTH_TEST));\n              p.map(function (e, r) {\n                !function renderDrawPass(e) {\n                  n.forEach(function (r) {\n                    var n = 0,\n                        o = null,\n                        u = (o = a.symbol.default ? r.type === pe.POINT ? a.pointMetaShader : r.type === pe.LINE ? a.lineMetaShader : a.polygonMetaShader : a.symbolMetaShader).shader;\n                    if (i.useProgram(u.program), i.uniform1f(u.orderMinWidth, p[e]), i.uniform1f(u.orderMaxWidth, m[e]), i.uniform1f(u.normalScale, 1 / (512 * Math.pow(2, t.zoomLevel) * r.scale)), i.uniform2f(u.resolution, i.canvas.width / window.devicePixelRatio, i.canvas.height / window.devicePixelRatio), i.enableVertexAttribArray(u.vertexPositionAttribute), i.bindBuffer(i.ARRAY_BUFFER, r.vertexBuffer), i.vertexAttribPointer(u.vertexPositionAttribute, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(u.featureIdAttr), i.bindBuffer(i.ARRAY_BUFFER, r.featureIDBuffer), i.vertexAttribPointer(u.featureIdAttr, 2, i.FLOAT, !1, 0, 0), r.type !== pe.LINE && r.type !== pe.POLYGON || (i.enableVertexAttribArray(u.normalAttr), i.bindBuffer(i.ARRAY_BUFFER, r.normalBuffer), i.vertexAttribPointer(u.normalAttr, 2, i.FLOAT, !1, 0, 0)), i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.texColor), i.uniform1i(u.colorTexture, n), n++, i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.texFilter), i.uniform1i(u.filterTexture, n), n++, \"point\" !== r.type && \"line\" !== r.type || (i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.texWidth), i.uniform1i(u.widthTexture, n), n++), a.symbol.default) r.type !== pe.LINE && (i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.texStrokeColor), i.uniform1i(u.strokeColorTexture, n), n++, i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.texStrokeWidth), i.uniform1i(u.strokeWidthTexture, n), n++);else {\n                      var s = o.textureIds;\n                      t.freeTexUnit = n + Object.keys(s).length, a.symbol._setTimestamp(lu), a.symbol._preDraw(u.program, t, i), a.symbolPlacement._setTimestamp(lu), a.symbolPlacement._preDraw(u.program, t, i), n = t.freeTexUnit, Object.keys(s).forEach(function (e) {\n                        i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.getPropertyTexture(e)), i.uniform1i(s[e], n), n++;\n                      });\n                    }\n\n                    if (r.type !== pe.LINE && r.type !== pe.POLYGON || i.clear(i.DEPTH_BUFFER_BIT), !a.transform.default) {\n                      var c = o.textureIds;\n                      t.freeTexUnit = n + Object.keys(c).length, a.transform._setTimestamp(lu), a.transform._preDraw(u.program, t, i), n = t.freeTexUnit, Object.keys(c).forEach(function (e) {\n                        i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, r.getPropertyTexture(e)), i.uniform1i(c[e], n), n++;\n                      }), i.uniform2f(u.resolution, i.canvas.width, i.canvas.height);\n                    }\n\n                    i.uniformMatrix4fv(u.matrix, !1, r.matrix), i.drawArrays(i.TRIANGLES, 0, r.numVertex), i.disableVertexAttribArray(u.vertexPositionAttribute), i.disableVertexAttribArray(u.featureIdAttr), r.type !== pe.LINE && r.type !== pe.POLYGON || (i.disableVertexAttribArray(u.normalAttr), i.disable(i.DEPTH_TEST));\n                  });\n                }(r);\n              }), e.type !== pe.POINT && (i.bindFramebuffer(i.FRAMEBUFFER, null), i.viewport(0, 0, i.drawingBufferWidth, i.drawingBufferHeight), i.useProgram(this._aaBlendShader.program), i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, this._AATex), i.uniform1i(this._aaBlendShader.readTU, 0), i.enableVertexAttribArray(this._aaBlendShader.vertexAttribute), i.bindBuffer(i.ARRAY_BUFFER, this.bigTriangleVBO), i.vertexAttribPointer(this._aaBlendShader.vertexAttribute, 2, i.FLOAT, !1, 0, 0), i.drawArrays(i.TRIANGLES, 0, 3), i.disableVertexAttribArray(this._aaBlendShader.vertexAttribute)), i.disable(i.CULL_FACE);\n            }\n          }\n        }\n      }, {\n        key: \"_updateDataframeMatrices\",\n        value: function _updateDataframeMatrices(e) {\n          var t = this;\n          e.forEach(function (e) {\n            var r = [],\n                a = [];\n            n.copy(r, t.matrix), n.identity(a), n.translate(a, a, [.5, .5, 0]), n.scale(a, a, [.5, -.5, 1]), n.translate(a, a, [e.center.x, e.center.y, 0]), n.scale(a, a, [e.scale, e.scale, 1]), n.multiply(r, r, a), e.matrix = r;\n          });\n        }\n      }, {\n        key: \"_initShaders\",\n        value: function _initShaders() {\n          this._aaBlendShader = new Qe.AABlender(this.gl);\n        }\n      }]), Renderer;\n    }();\n\n    function getValidWebGLContextOrThrow(e, t) {\n      var r = unsupportedBrowserReasons(e, t, !0);\n      if (r.length > 0) throw r[0];\n      return t;\n    }\n\n    function isBrowserSupported(e, t) {\n      return 0 === unsupportedBrowserReasons(e, t).length;\n    }\n\n    function unsupportedBrowserReasons(e, t) {\n      var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n          n = [];\n      if (t || (e || (e = document.createElement(\"canvas\")), t = e.getContext(\"webgl\") || e.getContext(\"experimental-webgl\")), !t) return n.push(new Ae(\"WebGL 1 is unsupported\", Se.WEB_GL)), n;\n      if (!t.getExtension(\"OES_texture_float\") && (n.push(new Ae(\"WebGL extension 'OES_texture_float' is unsupported\", Se.WEB_GL)), r)) return n;\n      var a = t.getParameter(t.MAX_RENDERBUFFER_SIZE);\n      a < hu && n.push(new Ae(\"WebGL parameter 'gl.MAX_RENDERBUFFER_SIZE' is below the requirement: \".concat(a, \" < \").concat(hu), Se.WEB_GL));\n      var i = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n      return i < du && n.push(new Ae(\"WebGL parameter 'gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS' is below the requirement: \".concat(i, \" < \").concat(du), Se.WEB_GL)), n;\n    }\n\n    var mu = function () {\n      function FeatureVizProperty(e, t, r, n, a, i) {\n        p()(this, FeatureVizProperty), this._propertyName = e, this._properties = t, this._viz = r, this.blendTo = generateBlenderFunction(e, t[i], n, r, a, i, parser_parseVizExpression), this.reset = generateResetFunction(e, t[i], n, r, i);\n      }\n\n      return v()(FeatureVizProperty, [{\n        key: \"eval\",\n        value: function _eval() {\n          for (var e = this, t = [], r = arguments.length, n = new Array(r), a = 0; a < r; a++) n[a] = arguments[a];\n\n          return n.forEach(function (r) {\n            var n = {};\n            n[r] = e._properties[r], t.push(n);\n          }), this._viz[this._propertyName].eval(t);\n        }\n      }, {\n        key: \"value\",\n        get: function get() {\n          return this._viz[this._propertyName].eval(this._properties);\n        }\n      }]), FeatureVizProperty;\n    }(),\n        vu = function () {\n      function Feature(e, t) {\n        var r = t.viz,\n            n = t.customizedFeatures,\n            a = t.trackFeatureViz,\n            i = t.idProperty,\n            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];\n        p()(this, Feature), this.id = e[i], this._rawFeature = e, this._featureVizParams = {\n          rawFeature: e,\n          viz: r,\n          customizedFeatures: n,\n          trackFeatureViz: a,\n          idProperty: i\n        }, this._defineVizProperties(), this._defineVizVariables(), this._defineFeatureProperties(o);\n      }\n\n      return v()(Feature, [{\n        key: \"_defineVizProperties\",\n        value: function _defineVizProperties() {\n          var e = this;\n          ra.forEach(function (t) {\n            e[t] = e._buildFeatureVizProperty(t);\n          });\n        }\n      }, {\n        key: \"_buildFeatureVizProperty\",\n        value: function _buildFeatureVizProperty(e) {\n          var t = this._featureVizParams,\n              r = t.rawFeature,\n              n = t.viz,\n              a = t.customizedFeatures,\n              i = t.trackFeatureViz,\n              o = t.idProperty;\n          return new mu(e, r, n, a, i, o);\n        }\n      }, {\n        key: \"_defineVizVariables\",\n        value: function _defineVizVariables() {\n          var e = this,\n              t = {},\n              r = this._featureVizParams.viz.variables;\n          Object.keys(r).forEach(function (r) {\n            var n = \"__cartovl_variable_\".concat(r);\n            t[r] = e._buildFeatureVizProperty(n);\n          }), this.variables = t;\n        }\n      }, {\n        key: \"_defineFeatureProperties\",\n        value: function _defineFeatureProperties(e) {\n          var t = this;\n          e.forEach(function (e) {\n            Object.defineProperty(t, e, {\n              get: function get() {\n                return this._rawFeature[e];\n              }\n            });\n          });\n        }\n      }, {\n        key: \"blendTo\",\n        value: function blendTo(e) {\n          var t = this,\n              r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;\n          Object.keys(e).forEach(function (n) {\n            if (!ra.includes(n)) throw new he(\"Property '\".concat(n, \"' is not a valid viz property\"), de.INCORRECT_VALUE);\n            var a = e[n];\n            t[n].blendTo(a, r);\n          });\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;\n\n          for (var r in ra.forEach(function (r) {\n            e[r].reset(t);\n          }), this.variables) this.variables[r].reset(t);\n        }\n      }, {\n        key: \"getRenderedCentroid\",\n        value: function getRenderedCentroid() {\n          return this._rawFeature._dataframe.getRenderedCentroid(this._rawFeature._index);\n        }\n      }]), Feature;\n    }(),\n        yu = function () {\n      function RenderLayer() {\n        p()(this, RenderLayer), this.dataframes = [], this.renderer = null, this.viz = null, this.type = null, this.customizedFeatures = {}, this.idProperty = null;\n      }\n\n      return v()(RenderLayer, [{\n        key: \"addDataframe\",\n        value: function addDataframe(e) {\n          this.type && this._checkDataframeType(e), this.type = e.type, this.renderer && e.bindRenderer(this.renderer), this.dataframes.push(e), this.idProperty = e.metadata.idProperty;\n        }\n      }, {\n        key: \"setRenderer\",\n        value: function setRenderer(e) {\n          this.renderer = e, this.dataframes.forEach(function (t) {\n            return t.bindRenderer(e);\n          });\n        }\n      }, {\n        key: \"setViz\",\n        value: function setViz(e) {\n          this.viz = e;\n        }\n      }, {\n        key: \"getActiveDataframes\",\n        value: function getActiveDataframes() {\n          this.dataframes = this.dataframes.filter(function (e) {\n            return !e.freed;\n          });\n          var e = this.dataframes.filter(function (e) {\n            return e.active && e.numVertex;\n          });\n          return e.length && void 0 !== e[0].orderID && (e = e.sort(function (e, t) {\n            return e.orderID - t.orderID;\n          })), e;\n        }\n      }, {\n        key: \"hasDataframes\",\n        value: function hasDataframes() {\n          return this.getActiveDataframes().length > 0;\n        }\n      }, {\n        key: \"getNumFeatures\",\n        value: function getNumFeatures() {\n          return this.getActiveDataframes().map(function (e) {\n            return e.numFeatures;\n          }).reduce(function (e, t) {\n            return e + t;\n          }, 0);\n        }\n      }, {\n        key: \"_checkDataframeType\",\n        value: function _checkDataframeType(e) {\n          if (this.type !== e.type) throw new he(\"Layer dataframes must always be of the same type\", de.INCORRECT_TYPE);\n        }\n      }, {\n        key: \"getFeaturesAtPosition\",\n        value: function getFeaturesAtPosition(e) {\n          return this.viz ? this.viz.geometryType === pe.POINT ? this._getPointFeaturesAtPosition(e) : this._getPartialFeaturesAtPosition(e) : [];\n        }\n      }, {\n        key: \"_getPointFeaturesAtPosition\",\n        value: function _getPointFeaturesAtPosition(e) {\n          var t = this;\n          return this._getRawFeaturesAtPosition(e).map(function (e) {\n            return t._buildFeatureFromRaw(e);\n          });\n        }\n      }, {\n        key: \"_buildFeatureFromRaw\",\n        value: function _buildFeatureFromRaw(e) {\n          var t = this.viz,\n              r = this.customizedFeatures,\n              n = this.trackFeatureViz,\n              a = this.idProperty;\n          return new vu(e, {\n            viz: t,\n            customizedFeatures: r,\n            trackFeatureViz: n,\n            idProperty: a\n          });\n        }\n      }, {\n        key: \"_getRawFeaturesAtPosition\",\n        value: function _getRawFeaturesAtPosition(e) {\n          var t,\n              r = this;\n          return (t = []).concat.apply(t, l()(this.getActiveDataframes().map(function (t) {\n            return t.getFeaturesAtPosition(e, r.viz);\n          })));\n        }\n      }, {\n        key: \"_getPartialFeaturesAtPosition\",\n        value: function _getPartialFeaturesAtPosition(e) {\n          var t = this._getRawFeaturesAtPosition(e);\n\n          if (0 === t.length) return [];\n\n          var r = this._getPartialFeaturesFromSingle(t);\n\n          return this._getCompoundFeaturesFrom(r);\n        }\n      }, {\n        key: \"_getCompoundFeaturesFrom\",\n        value: function _getCompoundFeaturesFrom(e) {\n          var t = this,\n              r = [];\n\n          for (var n in e) {\n            var a = e[n].map(function (e) {\n              return t._buildFeatureFromRaw(e);\n            });\n            r.push(getCompoundFeature(a));\n          }\n\n          return r;\n        }\n      }, {\n        key: \"_getPartialFeaturesFromSingle\",\n        value: function _getPartialFeaturesFromSingle(e) {\n          var t = this,\n              r = new Set(e.map(function (e) {\n            return e[t.idProperty];\n          }));\n          return this.getAllPiecesPerFeature(r);\n        }\n      }, {\n        key: \"getAllPiecesPerFeature\",\n        value: function getAllPiecesPerFeature(e) {\n          var t = this,\n              r = {};\n          return e.forEach(function (e) {\n            r[e] = [];\n          }), this.getActiveDataframes().forEach(function (n) {\n            t._addPartialFeaturesIfExistIn(n, e, r);\n          }), r;\n        }\n      }, {\n        key: \"_addPartialFeaturesIfExistIn\",\n        value: function _addPartialFeaturesIfExistIn(e, t, r) {\n          for (var n = 0; n < e.numFeatures; n++) {\n            var a = e.getFeature(n),\n                i = a[this.idProperty];\n            if (t.has(i)) r[i].push(a);\n          }\n        }\n      }, {\n        key: \"trackFeatureViz\",\n        value: function trackFeatureViz(e, t, r, n) {\n          n[e] = n[e] || {}, n[e][t] = r;\n        }\n      }, {\n        key: \"freeDataframes\",\n        value: function freeDataframes() {\n          this.dataframes.map(function (e) {\n            return e.free();\n          }), this.dataframes = [], this.type = null;\n        }\n      }]), RenderLayer;\n    }(),\n        gu = function () {\n      function LayerConcurrencyHelper() {\n        p()(this, LayerConcurrencyHelper), this._majorNextUID = 0, this._majorCurrentUID = null, this._minorNextUID = 0, this._minorCurrentUID = null;\n      }\n\n      return v()(LayerConcurrencyHelper, [{\n        key: \"initMajorChange\",\n        value: function initMajorChange() {\n          return this._getChangeUID(!0);\n        }\n      }, {\n        key: \"initMinorChange\",\n        value: function initMinorChange() {\n          return this._getChangeUID(!1);\n        }\n      }, {\n        key: \"endMajorChange\",\n        value: function endMajorChange(e) {\n          this._detectConcurrentChanges(!0, e), this._setUID(e);\n        }\n      }, {\n        key: \"endMinorChange\",\n        value: function endMinorChange(e) {\n          this._detectConcurrentChanges(!1, e), this._setUID(e);\n        }\n      }, {\n        key: \"_getChangeUID\",\n        value: function _getChangeUID(e) {\n          var t;\n          return e ? (t = {\n            major: this._majorNextUID,\n            minor: 0\n          }, this._majorNextUID++, this._minorNextUID = 1) : (t = {\n            major: this._majorCurrentUID,\n            minor: this._minorNextUID\n          }, this._minorNextUID++), t;\n        }\n      }, {\n        key: \"_detectConcurrentChanges\",\n        value: function _detectConcurrentChanges(e, t) {\n          if (e) {\n            if (this._majorCurrentUID > t.major) throw new Ae(\"Another `Layer.update()` finished before this one:\\n                 Commit \".concat(t, \" overridden by commit \").concat(this._majorCurrentUID, \".\"));\n          } else {\n            if (this._majorCurrentUID > t.major || null !== this._majorCurrentUID && null === t.major) throw new Ae(\"Another `Layer.update()` finished before this viz change:\\n                 Commit \".concat(t, \" overridden by commit \").concat(this._majorCurrentUID, \".\").concat(this._minorCurrentUID));\n            if (this._minorCurrentUID > t.minor) throw new Ae(\"Another `viz change` finished before this one:\\n                 Commit \".concat(t.major, \".\").concat(t.minor, \" overridden by commit \").concat(this._majorCurrentUID, \".\").concat(this._minorCurrentUID));\n          }\n        }\n      }, {\n        key: \"_setUID\",\n        value: function _setUID(e) {\n          this._majorCurrentUID = e.major, this._minorCurrentUID = e.minor;\n        }\n      }]), LayerConcurrencyHelper;\n    }(),\n        _u = new WeakMap(),\n        bu = Object.freeze({\n      INIT: \"init\",\n      IDLE: \"idle\",\n      UPDATING: \"updating\"\n    }),\n        xu = function () {\n      function Layer(e, t, r) {\n        var a = this;\n        p()(this, Layer), this._checkId(e), this._checkSource(t), this._checkViz(r), this.id = e, this.type = \"custom\", r._boundLayer = this, this._context = new Promise(function (e) {\n          a._contextInitialize = e;\n        }), this._state = bu.INIT, this._visible = !0, this._emitter = uu(), this._renderLayer = new yu(), this.concurrencyHelper = new gu(), this._initialSource = t, this._initialViz = r, this._renderWaiters = [], this._cameraMatrix = n.identity([]), this._updateLayer = this.update(t, r);\n      }\n\n      return v()(Layer, [{\n        key: \"show\",\n        value: function show() {\n          this.visible = !0;\n        }\n      }, {\n        key: \"hide\",\n        value: function hide() {\n          this.visible = !1;\n        }\n      }, {\n        key: \"on\",\n        value: function on(e, t) {\n          return this._emitter.on(e, t);\n        }\n      }, {\n        key: \"off\",\n        value: function off(e, t) {\n          return this._emitter.off(e, t);\n        }\n      }, {\n        key: \"addTo\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee(e, t) {\n            var r,\n                n = this;\n            return tt.a.wrap(function _callee$(a) {\n              for (;;) switch (a.prev = a.next) {\n                case 0:\n                  a.prev = 0, e.once(\"error\", function (r) {\n                    console.warn(r.error.message), n._waitForMapToLoad(e, t);\n                  }), e.addLayer(this, t), a.next = 12;\n                  break;\n\n                case 5:\n                  if (a.prev = 5, a.t0 = a.catch(0), r = /Cannot read property 'addLayer' of undefined/, /Style is not done loading/.test(a.t0) || r.test(a.t0)) {\n                    a.next = 11;\n                    break;\n                  }\n\n                  throw new Ae(\"Error adding layer to map: \".concat(a.t0));\n\n                case 11:\n                  this._waitForMapToLoad(e, t);\n\n                case 12:\n                case \"end\":\n                  return a.stop();\n              }\n            }, _callee, this, [[0, 5]]);\n          }));\n          return function addTo(t, r) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_waitForMapToLoad\",\n        value: function _waitForMapToLoad(e, t) {\n          var r = this;\n          e.on(\"load\", function () {\n            e.addLayer(r, t);\n          });\n        }\n      }, {\n        key: \"remove\",\n        value: function remove() {\n          this.map && this.map.removeLayer(this.id);\n        }\n      }, {\n        key: \"update\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee2(e) {\n            var t,\n                r = arguments;\n            return tt.a.wrap(function _callee2$(n) {\n              for (;;) switch (n.prev = n.next) {\n                case 0:\n                  return t = r.length > 1 && void 0 !== r[1] ? r[1] : this._viz, n.abrupt(\"return\", this._update(e, t, !0));\n\n                case 2:\n                case \"end\":\n                  return n.stop();\n              }\n            }, _callee2, this);\n          }));\n          return function update(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_update\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee3(e, t, r) {\n            var n, a, i, o, u;\n            return tt.a.wrap(function _callee3$(s) {\n              for (;;) switch (s.prev = s.next) {\n                case 0:\n                  return this._checkSource(e), this._checkViz(t), n = this._cloneSourceIfDifferent(e), a = this._initChange(r), s.next = 6, Promise.all([t.loadImages(), n.requestMetadata(t)]);\n\n                case 6:\n                  return i = s.sent, o = g()(i, 2), u = o[1], s.next = 11, this._context;\n\n                case 11:\n                  this._endChange(r, a), this._commitSuccesfulUpdate(u, t, n);\n\n                case 13:\n                case \"end\":\n                  return s.stop();\n              }\n            }, _callee3, this);\n          }));\n          return function _update(t, r, n) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_initChange\",\n        value: function _initChange(e) {\n          return e ? this.concurrencyHelper.initMajorChange() : this.concurrencyHelper.initMinorChange();\n        }\n      }, {\n        key: \"_endChange\",\n        value: function _endChange(e, t) {\n          e ? this.concurrencyHelper.endMajorChange(t) : this.concurrencyHelper.endMinorChange(t);\n        }\n      }, {\n        key: \"_commitSuccesfulUpdate\",\n        value: function _commitSuccesfulUpdate(e, t, r) {\n          this.metadata = e, this._commitVizChange(t), this._commitSourceChange(r), this._needRefresh();\n        }\n      }, {\n        key: \"_commitVizChange\",\n        value: function _commitVizChange(e) {\n          this._viz && this._viz.onChange(null), e.setDefaultsIfRequired(this.metadata.geomType), e.setDefaultsIfRequired(this._renderLayer.type), e.onChange(this._vizChanged.bind(this)), e._bindMetadata(this.metadata), e.gl = this.gl, this._viz = e;\n        }\n      }, {\n        key: \"_commitSourceChange\",\n        value: function _commitSourceChange(e) {\n          e.bindLayer(this._onDataframeAdded.bind(this)), e !== this._source && this._freeSource(), this._source = e;\n        }\n      }, {\n        key: \"_cloneSourceIfDifferent\",\n        value: function _cloneSourceIfDifferent(e) {\n          return e !== this._source ? e._clone() : e;\n        }\n      }, {\n        key: \"blendToViz\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee4(e) {\n            var t,\n                r,\n                n = this,\n                a = arguments;\n            return tt.a.wrap(function _callee4$(i) {\n              for (;;) switch (i.prev = i.next) {\n                case 0:\n                  return t = a.length > 1 && void 0 !== a[1] ? a[1] : 400, r = a.length > 2 && void 0 !== a[2] ? a[2] : di, this._checkViz(e), i.next = 5, this._updateLayer;\n\n                case 5:\n                  return this._viz && !this._source.requiresNewMetadata(e) && (Object.keys(this._viz.variables).map(function (t) {\n                    e.variables[t] = n._viz.variables[t];\n                  }), e.color._blendFrom(this._viz.color, t, r), e.strokeColor._blendFrom(this._viz.strokeColor, t, r), e.width._blendFrom(this._viz.width, t, r), e.strokeWidth._blendFrom(this._viz.strokeWidth, t, r), e.filter._blendFrom(this._viz.filter, t, r)), i.abrupt(\"return\", this._update(this._source, e, !1));\n\n                case 7:\n                case \"end\":\n                  return i.stop();\n              }\n            }, _callee4, this);\n          }));\n          return function blendToViz(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"hasDataframes\",\n        value: function hasDataframes() {\n          return this._renderLayer.hasDataframes();\n        }\n      }, {\n        key: \"getNumFeatures\",\n        value: function getNumFeatures() {\n          return this._renderLayer.getNumFeatures();\n        }\n      }, {\n        key: \"getFeaturesAtPosition\",\n        value: function getFeaturesAtPosition(e) {\n          return this.visible ? this._renderLayer.getFeaturesAtPosition(e).map(this._addLayerIdToFeature.bind(this)) : [];\n        }\n      }, {\n        key: \"isAnimated\",\n        value: function isAnimated() {\n          return this._viz && this._viz.isAnimated();\n        }\n      }, {\n        key: \"isPlaying\",\n        value: function isPlaying() {\n          return this._viz && this._viz.isPlaying();\n        }\n      }, {\n        key: \"onAdd\",\n        value: function onAdd(e, t) {\n          this.map = e, this.gl = t, this.renderer = function _getRenderer(e, t) {\n            if (!_u.get(e)) {\n              var r = new pu();\n              r.initialize(t), _u.set(e, r);\n            }\n\n            return _u.get(e);\n          }(e, t), this._renderLayer.setRenderer(this.renderer), this._contextInitialize();\n        }\n      }, {\n        key: \"onRemove\",\n        value: function onRemove(e, t) {\n          this._fire(\"removed\", this);\n        }\n      }, {\n        key: \"prerender\",\n        value: function prerender(e, t) {\n          var r = this._detectAndSetNewMatrix(t);\n\n          this._source && this.visible && this._checkSourceRequestsAndFireEvents(r);\n        }\n      }, {\n        key: \"_detectAndSetNewMatrix\",\n        value: function _detectAndSetNewMatrix(e) {\n          var t = !n.exactEquals(e, this._cameraMatrix);\n          return t && (this._cameraMatrix = e, this.renderer.matrix = e), t;\n        }\n      }, {\n        key: \"_checkSourceRequestsAndFireEvents\",\n        value: function _checkSourceRequestsAndFireEvents(e) {\n          var t = this;\n\n          this._source.requestData(this._getZoom(), this._getViewport()).then(function (r) {\n            r ? t._needRefresh().then(function () {\n              t._state === bu.INIT && (t._state = bu.IDLE, t._fire(\"loaded\")), t._fire(\"updated\", \"different dataframes required from source\");\n            }) : e && t._fire(\"updated\", \"new camara view\");\n          });\n        }\n      }, {\n        key: \"_getViewport\",\n        value: function _getViewport() {\n          return computeViewportFromCameraMatrix(this._cameraMatrix);\n        }\n      }, {\n        key: \"render\",\n        value: function render(e, t) {\n          var r = this;\n          this._paintLayer(), this._renderWaiters.forEach(function (e) {\n            return e();\n          }), this.isAnimated() ? this.isPlaying() ? this._needRefresh().then(function () {\n            r._fire(\"updated\", \"animation is playing\");\n          }) : this._keepTimestampIfPaused() : this._state === bu.UPDATING && (this._state = bu.IDLE, this._fire(\"updated\", \"updated viz\"));\n        }\n      }, {\n        key: \"_keepTimestampIfPaused\",\n        value: function _keepTimestampIfPaused() {\n          var e = this.renderer.timestamp;\n\n          this._viz._getRootStyleExpressions().forEach(function (t) {\n            t._setTimestamp(e);\n          });\n        }\n      }, {\n        key: \"_paintLayer\",\n        value: function _paintLayer() {\n          this._renderLayer.setViz(this._viz), this.renderer.renderLayer(this._renderLayer, {\n            zoomLevel: this.map.getZoom()\n          });\n        }\n      }, {\n        key: \"_fire\",\n        value: function _fire(e, t) {\n          var r = this;\n          new Promise(function (n) {\n            r._emitter.emit(e, t), n();\n          });\n        }\n      }, {\n        key: \"_onDataframeAdded\",\n        value: function _onDataframeAdded(e) {\n          this._renderLayer.addDataframe(e), this._viz && this._viz.setDefaultsIfRequired(e.type);\n        }\n      }, {\n        key: \"_needRefresh\",\n        value: function _needRefresh() {\n          var e = this;\n          return this._state === bu.IDLE && (this._state = bu.UPDATING), new Promise(function (t) {\n            e._renderWaiters.push(t), e.map.triggerRepaint();\n          });\n        }\n      }, {\n        key: \"_addLayerIdToFeature\",\n        value: function _addLayerIdToFeature(e) {\n          return e.layerId = this.id, e;\n        }\n      }, {\n        key: \"_vizChanged\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee5(e) {\n            return tt.a.wrap(function _callee5$(t) {\n              for (;;) switch (t.prev = t.next) {\n                case 0:\n                  return t.abrupt(\"return\", this._update(this._source, e, !1));\n\n                case 1:\n                case \"end\":\n                  return t.stop();\n              }\n            }, _callee5, this);\n          }));\n          return function _vizChanged(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_checkId\",\n        value: function _checkId(e) {\n          if (void 0 === e) throw new he(\"'id'\", de.MISSING_REQUIRED);\n          if (!be.isString(e)) throw new he(\"'id' property must be a string.\", de.INCORRECT_TYPE);\n          if (\"\" === e) throw new he(\"'id' property must be not empty.\", de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_checkSource\",\n        value: function _checkSource(e) {\n          if (void 0 === e) throw new he(\"'source'\", de.MISSING_REQUIRED);\n          if (!(e instanceof su)) throw new he(\"The given object is not a valid 'source'. See \\\"carto.source\\\".\", de.INCORRECT_TYPE);\n        }\n      }, {\n        key: \"_checkViz\",\n        value: function _checkViz(e) {\n          if (be.isUndefined(e)) throw new he(\"'viz'\", de.MISSING_REQUIRED);\n          if (!(e instanceof ou)) throw new he(\"The given object is not a valid 'viz'. See \\\"carto.Viz\\\".\", de.INCORRECT_TYPE);\n          if (e._boundLayer && e._boundLayer !== this) throw new he(\"The given Viz object is already bound to another layer. Vizs cannot be shared between different layers.\", de.INCORRECT_VALUE);\n        }\n      }, {\n        key: \"_getZoom\",\n        value: function _getZoom() {\n          return this.map.getZoom();\n        }\n      }, {\n        key: \"_freeSource\",\n        value: function _freeSource() {\n          this._source && this._source.free(), this._renderLayer.freeDataframes();\n        }\n      }, {\n        key: \"visible\",\n        get: function get() {\n          return this._visible;\n        },\n        set: function set(e) {\n          var t = this._visible;\n          this.map.setLayoutProperty(this.id, \"visibility\", e ? \"visible\" : \"none\"), this._visible = e, e !== t && this._fire(\"updated\", \"visibility change\");\n        }\n      }, {\n        key: \"viz\",\n        get: function get() {\n          return this._viz;\n        }\n      }]), Layer;\n    }();\n\n    var ku = [\"featureClick\", \"featureClickOut\", \"featureEnter\", \"featureHover\", \"featureLeave\"],\n        Tu = \"idle\",\n        wu = \"moving\",\n        Cu = function () {\n      function Interactivity(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n          autoChangePointer: !0\n        };\n        p()(this, Interactivity), e instanceof xu && (e = [e]), function preCheckLayerList(e) {\n          if (!Array.isArray(e)) throw new he('Invalid layer list, parameter must be an array of \"carto.Layer\" objects.', de.INCORRECT_TYPE);\n          if (!e.length) throw new he(\"Invalid argument, layer list must not be empty.\", de.INCORRECT_VALUE);\n          if (!e.every(function (e) {\n            return e instanceof xu;\n          })) throw new he('Invalid layer, layer must be an instance of \"carto.Layer\".', de.INCORRECT_TYPE);\n        }(e), this._init(e, t);\n      }\n\n      return v()(Interactivity, [{\n        key: \"on\",\n        value: function on(e, t) {\n          checkEvent(e);\n          var r = this._numListeners[e] || 0;\n          return this._numListeners[e] = r + 1, this._emitter.on(e, t);\n        }\n      }, {\n        key: \"off\",\n        value: function off(e, t) {\n          checkEvent(e);\n          var r = this._numListeners[e];\n          return this._numListeners[e] = r - 1, this._emitter.off(e, t);\n        }\n      }, {\n        key: \"disable\",\n        value: function disable() {\n          this._enabled = !1;\n        }\n      }, {\n        key: \"enable\",\n        value: function enable() {\n          this._enabled = !0;\n        }\n      }, {\n        key: \"_init\",\n        value: function _init(e, t) {\n          var r = this;\n          this._enabled = !0, this._mapState = Tu, this._emitter = uu(), this._layerList = e, this._prevHoverFeatures = [], this._prevClickFeatures = [], this._numListeners = {}, this._isAutoChangePointerEnabled = t.autoChangePointer;\n          var n = e.map(function (e) {\n            return e._context;\n          });\n          return Promise.all(n).then(function () {\n            !function postCheckLayerList(e) {\n              if (!e.every(function (t) {\n                return t.map === e[0].map;\n              })) throw new he(\"Invalid argument, all layers must belong to the same map.\", de.INCORRECT_VALUE);\n            }(e), r._map = e[0].map, r._subscribeToLayerEvents(e), r._subscribeToMapEvents(r._map), r._isAutoChangePointerEnabled && r._setInteractiveCursor();\n          });\n        }\n      }, {\n        key: \"_setInteractiveCursor\",\n        value: function _setInteractiveCursor() {\n          var e = this;\n          this._map.__carto_interactivities || (this._map.__carto_interactivities = new Set()), this.on(\"featureHover\", function (t) {\n            return e._onFeatureHover(t, e._map);\n          });\n        }\n      }, {\n        key: \"_onFeatureHover\",\n        value: function _onFeatureHover(e, t) {\n          e.features.length ? t.__carto_interactivities.add(this) : t.__carto_interactivities.delete(this), t.getCanvas().style.cursor = t.__carto_interactivities.size > 0 ? \"pointer\" : \"\";\n        }\n      }, {\n        key: \"_subscribeToMapEvents\",\n        value: function _subscribeToMapEvents(e) {\n          this._onMouseMoveBound = this._onMouseMove.bind(this), e.on(\"mousemove\", this._onMouseMoveBound), this._onClickBound = this._onClick.bind(this), e.on(\"click\", this._onClickBound), this._disableWhileMovingMap(e);\n        }\n      }, {\n        key: \"_unsubscribeToMapEvents\",\n        value: function _unsubscribeToMapEvents(e) {\n          e.off(\"mousemove\", this._onMouseMoveBound), e.off(\"click\", this._onClickBound);\n        }\n      }, {\n        key: \"_disableWhileMovingMap\",\n        value: function _disableWhileMovingMap(e) {\n          var t = this;\n          e.on(\"movestart\", function () {\n            t._setMapState(wu);\n          }), e.on(\"moveend\", function () {\n            t._setMapState(Tu);\n          });\n        }\n      }, {\n        key: \"_setMapState\",\n        value: function _setMapState(e) {\n          this._mapState = e;\n        }\n      }, {\n        key: \"_subscribeToLayerEvents\",\n        value: function _subscribeToLayerEvents(e) {\n          var t = this;\n          e.forEach(function (e) {\n            e.on(\"updated\", t._onLayerUpdated.bind(t)), e.on(\"removed\", t._onLayerRemoved.bind(t));\n          });\n        }\n      }, {\n        key: \"_onLayerUpdated\",\n        value: function _onLayerUpdated() {\n          this._onMouseMove(this._mouseEvent, !0);\n        }\n      }, {\n        key: \"_onLayerRemoved\",\n        value: function _onLayerRemoved(e) {\n          this._removeLayerFromInteractivity(e), this._isAutoChangePointerEnabled && this._onFeatureHover({\n            features: []\n          }, this._map), this._layerList.length || this._unsubscribeToMapEvents(this._map);\n        }\n      }, {\n        key: \"_removeLayerFromInteractivity\",\n        value: function _removeLayerFromInteractivity(e) {\n          var t = this._layerList.indexOf(e);\n\n          -1 !== t && this._layerList.splice(t, 1);\n        }\n      }, {\n        key: \"_onMouseMove\",\n        value: function _onMouseMove(e, t) {\n          if (this._mouseEvent = e, this.isEnabled && e && (this._numListeners.featureEnter || this._numListeners.featureHover || this._numListeners.featureLeave)) {\n            var r = this._createFeatureEvent(e),\n                n = this._manageFeatureLeaveEvent(r),\n                a = this._manageFeatureEnterEvent(r);\n\n            this._prevHoverFeatures = r.features, this._manageFeatureHoverEvent(r, {\n              featuresLeft: n,\n              featuresEntered: a\n            }, t);\n          }\n        }\n      }, {\n        key: \"_manageFeatureLeaveEvent\",\n        value: function _manageFeatureLeaveEvent(e) {\n          var t = this._getDiffFeatures(this._prevHoverFeatures, e.features);\n\n          return this._fireEventIfFeatures(\"featureLeave\", {\n            featureEvent: e,\n            eventFeatures: t\n          }), t;\n        }\n      }, {\n        key: \"_manageFeatureEnterEvent\",\n        value: function _manageFeatureEnterEvent(e) {\n          var t = this._getDiffFeatures(e.features, this._prevHoverFeatures);\n\n          return this._fireEventIfFeatures(\"featureEnter\", {\n            featureEvent: e,\n            eventFeatures: t\n          }), t;\n        }\n      }, {\n        key: \"_manageFeatureHoverEvent\",\n        value: function _manageFeatureHoverEvent(e, t, r) {\n          var n = t.featuresLeft,\n              a = t.featuresEntered;\n          (!r || r && (n.length || a.length)) && this._fireEvent(\"featureHover\", e);\n        }\n      }, {\n        key: \"_fireEventIfFeatures\",\n        value: function _fireEventIfFeatures(e, t) {\n          var r = t.featureEvent,\n              n = t.eventFeatures;\n          n.length > 0 && this._fireEvent(e, {\n            coordinates: r.coordinates,\n            position: r.position,\n            features: n\n          });\n        }\n      }, {\n        key: \"_onClick\",\n        value: function _onClick(e) {\n          if (this.isEnabled && (this._numListeners.featureClick || this._numListeners.featureClickOut)) {\n            var t = this._createFeatureEvent(e);\n\n            this._manageClickOutEvent(t), this._prevClickFeatures = t.features, this._fireEvent(\"featureClick\", t);\n          }\n        }\n      }, {\n        key: \"_manageClickOutEvent\",\n        value: function _manageClickOutEvent(e) {\n          var t = this._getDiffFeatures(this._prevClickFeatures, e.features);\n\n          return this._fireEventIfFeatures(\"featureClickOut\", {\n            featureEvent: e,\n            eventFeatures: t\n          }), t;\n        }\n      }, {\n        key: \"_createFeatureEvent\",\n        value: function _createFeatureEvent(e) {\n          var t = this._getFeaturesAtPosition(e.point);\n\n          return {\n            coordinates: e.lngLat,\n            position: e.point,\n            features: t\n          };\n        }\n      }, {\n        key: \"_fireEvent\",\n        value: function _fireEvent(e, t) {\n          this._emitter.emit(e, t);\n        }\n      }, {\n        key: \"_getFeaturesAtPosition\",\n        value: function _getFeaturesAtPosition(e) {\n          var t;\n          return (t = []).concat.apply(t, l()(this._layerList.map(function (t) {\n            return t.getFeaturesAtPosition(e);\n          })));\n        }\n      }, {\n        key: \"_getDiffFeatures\",\n        value: function _getDiffFeatures(e, t) {\n          var r = this._getFeatureIDs(t);\n\n          return e.filter(function (e) {\n            return !r.includes(e.id);\n          });\n        }\n      }, {\n        key: \"_getFeatureIDs\",\n        value: function _getFeatureIDs(e) {\n          return e.map(function (e) {\n            return e.id;\n          });\n        }\n      }, {\n        key: \"isEnabled\",\n        get: function get() {\n          return this._enabled && this._mapState !== wu;\n        }\n      }]), Interactivity;\n    }();\n\n    function checkEvent(e) {\n      if (!ku.includes(e)) throw new he(\"Unrecognized event: '\".concat(e, \"'. Available events: \").concat(ku.join(\", \"), \".\"), de.INCORRECT_VALUE);\n    }\n\n    var Eu = r(29),\n        Mu = r.n(Eu);\n\n    function addLineString(e, t, r, n, a) {\n      var i, o, u, s, c;\n\n      if (e.length >= 4) {\n        i = [e[0], e[1]];\n\n        for (var l = 2; l <= e.length; l += 2) if (o = [e[l], e[l + 1]], i[0] !== o[0] || i[1] !== o[1]) {\n          l += 2;\n          break;\n        }\n\n        for (u = getLineNormal(i, o); l <= e.length; l += 2) {\n          c = !(a && a(l));\n          var f = void 0;\n          if (l <= e.length - 2 ? f = [e[l], e[l + 1]] : n && (f = [e[2], e[3]]), !c || i[0] === o[0] && i[1] === o[1] || (t.vertices[r] = i[0], t.normals[r++] = -u[0], t.vertices[r] = i[1], t.normals[r++] = -u[1], t.vertices[r] = i[0], t.normals[r++] = u[0], t.vertices[r] = i[1], t.normals[r++] = u[1], t.vertices[r] = o[0], t.normals[r++] = u[0], t.vertices[r] = o[1], t.normals[r++] = u[1], t.vertices[r] = i[0], t.normals[r++] = -u[0], t.vertices[r] = i[1], t.normals[r++] = -u[1], t.vertices[r] = o[0], t.normals[r++] = u[0], t.vertices[r] = o[1], t.normals[r++] = u[1], t.vertices[r] = o[0], t.normals[r++] = -u[0], t.vertices[r] = o[1], t.normals[r++] = -u[1]), !f || f[0] === o[0] && f[1] === o[1]) s = u;else if (s = getLineNormal(o, f), c) {\n            var h = getJoinNormal(u, s),\n                d = h.turnLeft,\n                p = h.joinNormal,\n                m = d ? u : neg(s),\n                v = d ? s : neg(u);\n            t.vertices[r] = o[0], t.normals[r++] = 0, t.vertices[r] = o[1], t.normals[r++] = n ? 1e-37 : 0, t.vertices[r] = o[0], t.normals[r++] = m[0], t.vertices[r] = o[1], t.normals[r++] = m[1], t.vertices[r] = o[0], t.normals[r++] = v[0], t.vertices[r] = o[1], t.normals[r++] = v[1], p && (t.vertices[r] = o[0], t.normals[r++] = p[0], t.vertices[r] = o[1], t.normals[r++] = p[1], t.vertices[r] = o[0], t.normals[r++] = v[0], t.vertices[r] = o[1], t.normals[r++] = v[1], t.vertices[r] = o[0], t.normals[r++] = m[0], t.vertices[r] = o[1], t.normals[r++] = m[1]);\n          }\n          i = o, o = f, u = s;\n        }\n      }\n\n      return r;\n    }\n\n    function resizeBuffer(e, t) {\n      var r = new Float32Array(t);\n      return r.set(e), r;\n    }\n\n    var Au = 24,\n        Su = 0,\n        Pu = {\n      vertices: new Float32Array(1048576),\n      normals: new Float32Array(1048576)\n    };\n\n    function resizeBuffers(e) {\n      var t = Su + e;\n\n      if (t > Pu.vertices.length) {\n        var r = 2 * t;\n        Pu.vertices = resizeBuffer(Pu.vertices, r), Pu.normals = resizeBuffer(Pu.normals, r);\n      }\n    }\n\n    var Iu = r(38),\n        Nu = 2,\n        Du = 24,\n        Ru = 0,\n        Fu = {\n      vertices: new Float32Array(2097152),\n      normals: new Float32Array(2097152)\n    };\n\n    function polygonDecoder_resizeBuffers(e) {\n      var t = Ru + e;\n\n      if (t > Fu.vertices.length) {\n        var r = 2 * t;\n        Fu.vertices = resizeBuffer(Fu.vertices, r), Fu.normals = resizeBuffer(Fu.normals, r);\n      }\n    }\n\n    function addVertex(e, t) {\n      Fu.vertices[Ru] = e[t], Fu.normals[Ru++] = 0, Fu.vertices[Ru] = e[t + 1], Fu.normals[Ru++] = 0;\n    }\n\n    function isClipped(e, t, r) {\n      return !!(e.clipped.includes(t) && e.clipped.includes(r) && e.clippedType[e.clipped.indexOf(t)] & e.clippedType[e.clipped.indexOf(r)]);\n    }\n\n    function decodeGeom(e, t) {\n      switch (e) {\n        case pe.POINT:\n          return function decodePoint(e) {\n            return {\n              verticesArrayBuffer: e,\n              vertices: new Float32Array(e),\n              breakpoints: []\n            };\n          }(t);\n\n        case pe.LINE:\n          return function decodeLine(e) {\n            var t = [],\n                r = new Map();\n            Su = 0;\n\n            for (var n = 0; n < e.length; n++) {\n              for (var a = e[n], i = 0; i < a.length; i++) resizeBuffers(Au * a[i].length), Su = addLineString(a[i], Pu, Su);\n\n              r.set(t.length, 0 === t.length ? {\n                start: 0,\n                end: Su\n              } : {\n                start: r.get(t.length - 1).end,\n                end: Su\n              }), t.push(Su);\n            }\n\n            for (var o = new ArrayBuffer(4 * Su), u = new ArrayBuffer(4 * Su), s = new Float32Array(o), c = new Float32Array(u), l = 0; l < Su; l++) s[l] = Pu.vertices[l], c[l] = Pu.normals[l];\n\n            return {\n              vertices: s,\n              normals: c,\n              verticesArrayBuffer: o,\n              normalsArrayBuffer: u,\n              featureIDToVertexIndex: r,\n              breakpoints: t\n            };\n          }(t);\n\n        case pe.POLYGON:\n          return function decodePolygon(e) {\n            var t = [],\n                r = new Map();\n            Ru = 0;\n\n            for (var n = 0; n < e.length; n++) {\n              for (var a = e[n], i = function _loop(e) {\n                var t = a[e],\n                    r = Iu(t.flat, t.holes);\n                polygonDecoder_resizeBuffers(Nu * r.length + Du * t.flat.length);\n\n                for (var n = 0; n < r.length; n++) addVertex(t.flat, 2 * r[n]);\n\n                Ru = addLineString(t.flat, Fu, Ru, !0, function (e) {\n                  return t.holes.includes((e - 2) / 2) || isClipped(t, e - 4, e - 2);\n                });\n              }, o = 0; o < a.length; o++) i(o);\n\n              r.set(t.length, 0 === t.length ? {\n                start: 0,\n                end: Ru\n              } : {\n                start: r.get(t.length - 1).end,\n                end: Ru\n              }), t.push(Ru);\n            }\n\n            for (var u = new ArrayBuffer(4 * Ru), s = new ArrayBuffer(4 * Ru), c = new Float32Array(u), l = new Float32Array(s), f = 0; f < Ru; f++) c[f] = Fu.vertices[f], l[f] = Fu.normals[f];\n\n            return {\n              vertices: c,\n              normals: l,\n              verticesArrayBuffer: u,\n              normalsArrayBuffer: s,\n              featureIDToVertexIndex: r,\n              breakpoints: t\n            };\n          }(t);\n\n        default:\n          throw new Ae(\"Unimplemented geometry type: '\".concat(e, \"'.\"), Se.NOT_SUPPORTED);\n      }\n    }\n\n    var Ou = function () {\n      function FeatureIdsHelper(e) {\n        p()(this, FeatureIdsHelper), this.dataframe = e;\n      }\n\n      return v()(FeatureIdsHelper, [{\n        key: \"getFeatureIds\",\n        value: function getFeatureIds() {\n          return !this.decodedGeom.breakpoints.length ? this._getFeatureIdsForPoints() : this._getFeatureIdsForLinesOrPolygons();\n        }\n      }, {\n        key: \"_getFeatureIdsForPoints\",\n        value: function _getFeatureIdsForPoints() {\n          for (var e = this.decodedGeom.vertices.length, t = this._createTablesXY(), r = t.tableX, n = t.tableY, a = new Float32Array(e), i = 0, o = 0; o < e; o += 6) a[o + 0] = r[i], a[o + 1] = n[i], 0 === a[o + 0] && (a[o + 0] += 1 / 65536), 0 === a[o + 1] && (a[o + 1] += 1 / 65536), a[o + 2] = -a[o + 0], a[o + 3] = a[o + 1], a[o + 4] = a[o + 0], a[o + 5] = -a[o + 1], i++;\n\n          return a;\n        }\n      }, {\n        key: \"_getFeatureIdsForLinesOrPolygons\",\n        value: function _getFeatureIdsForLinesOrPolygons() {\n          for (var e = this.decodedGeom.vertices.length, t = this._createTablesXY(), r = t.tableX, n = t.tableY, a = this.decodedGeom.breakpoints, i = new Float32Array(e), o = 0, u = 0; u < e; u += 2) {\n            for (; u === a[o];) o++;\n\n            i[u + 0] = r[o], i[u + 1] = n[o];\n          }\n\n          return i;\n        }\n      }, {\n        key: \"_createTablesXY\",\n        value: function _createTablesXY() {\n          for (var e = {}, t = {}, r = this.dataframe.getSize(), n = r.height, a = r.width, i = 0; i < this.numFeatures; i++) e[i] = i % a / (a - 1), t[i] = n > 1 ? Math.floor(i / a) / (n - 1) : .5;\n\n          return {\n            tableX: e,\n            tableY: t\n          };\n        }\n      }, {\n        key: \"decodedGeom\",\n        get: function get() {\n          return this.dataframe.decodedGeom;\n        }\n      }, {\n        key: \"numFeatures\",\n        get: function get() {\n          return this.dataframe.numFeatures;\n        }\n      }]), FeatureIdsHelper;\n    }(),\n        Lu = r(32),\n        Bu = \"separatingLineFound\",\n        Vu = \"separatingLineNotFound\";\n\n    function triangleCollides(e, t) {\n      return function _noArea(e) {\n        var t = g()(e, 3),\n            r = t[0],\n            n = t[1],\n            a = t[2];\n        return equalPoints(r, n) || equalPoints(n, a);\n      }(e) ? function _noAreaTriangleCollides(e, t) {\n        var r = g()(e, 3),\n            n = r[0],\n            a = r[1],\n            i = r[2],\n            o = n,\n            u = equalPoints(a, o) ? i : a,\n            s = [t.minx, t.miny, t.maxx, t.maxy];\n        return Lu([[o.x, o.y], [u.x, u.y]], s).length > 0;\n      }(e, t) : function _viewportLineSeparatesTriangle(e, t) {\n        if (t[0].x < e.minx && t[1].x < e.minx && t[2].x < e.minx) return Bu;\n        if (t[0].y < e.miny && t[1].y < e.miny && t[2].y < e.miny) return Bu;\n        if (t[0].x > e.maxx && t[1].x > e.maxx && t[2].x > e.maxx) return Bu;\n        if (t[0].y > e.maxy && t[1].y > e.maxy && t[2].y > e.maxy) return Bu;\n        return Vu;\n      }(t, e) !== Bu && function _triangleLineSeparatesViewport(e, t) {\n        for (var r = 0; r < 3; r++) for (var n = 0; n < t.length; n++) {\n          var a = halfPlaneSign(t[n], e[r], e[(r + 1) % 3]);\n          if (a > 0) break;\n          if (3 === n) return Bu;\n        }\n\n        return Vu;\n      }(e, [{\n        x: t.minx,\n        y: t.miny\n      }, {\n        x: t.minx,\n        y: t.maxy\n      }, {\n        x: t.maxx,\n        y: t.miny\n      }, {\n        x: t.maxx,\n        y: t.maxy\n      }]) !== Bu;\n    }\n\n    var Gu = function () {\n      function ProjectionHelper(e) {\n        p()(this, ProjectionHelper), this.dataframe = e;\n      }\n\n      return v()(ProjectionHelper, [{\n        key: \"toNDC\",\n        value: function toNDC(e, t) {\n          var r = this.toClipSpace(e, t),\n              n = r.ox,\n              a = r.oy,\n              i = r.ow;\n          return {\n            x: n / i,\n            y: a / i\n          };\n        }\n      }, {\n        key: \"toClipSpace\",\n        value: function toClipSpace(e, t) {\n          var r = this.matrix;\n          return {\n            ox: r[0] * e + r[4] * t + r[12],\n            oy: r[1] * e + r[5] * t + r[13],\n            ow: r[3] * e + r[7] * t + r[15]\n          };\n        }\n      }, {\n        key: \"matrix\",\n        get: function get() {\n          return this.dataframe.matrix;\n        }\n      }]), ProjectionHelper;\n    }(),\n        Uu = 1,\n        zu = -1,\n        qu = 0,\n        ju = function () {\n      function ViewportHelper(e) {\n        p()(this, ViewportHelper), this.dataframe = e, this.getFeature = e.getFeature.bind(e), this._getGL = e._getGL.bind(e), this._projection = new Gu(e);\n      }\n\n      return v()(ViewportHelper, [{\n        key: \"isPointInViewport\",\n        value: function isPointInViewport(e) {\n          var t = this.decodedGeom.vertices,\n              r = t[6 * e + 0],\n              n = t[6 * e + 1],\n              a = this._projection.toClipSpace(r, n),\n              i = a.ox,\n              o = a.oy,\n              u = a.ow;\n\n          return i > -u && i < u && o > -u && o < u;\n        }\n      }, {\n        key: \"isPolygonInViewport\",\n        value: function isPolygonInViewport(e) {\n          var t = this._aabb[e],\n              r = this._compareAABBs(t);\n\n          if (r === qu) {\n            var n = this.decodedGeom.vertices,\n                a = this.decodedGeom.normals,\n                i = this.decodedGeom.featureIDToVertexIndex.get(e);\n            return this._isPolygonCollidingViewport(n, a, i.start, i.end);\n          }\n\n          return r === Uu;\n        }\n      }, {\n        key: \"_getCanvasSizeInPixels\",\n        value: function _getCanvasSizeInPixels() {\n          var e = this._getGL().canvas;\n\n          return {\n            WIDTH: e.width / window.devicePixelRatio,\n            HEIGHT: e.height / window.devicePixelRatio\n          };\n        }\n      }, {\n        key: \"_compareAABBs\",\n        value: function _compareAABBs(e) {\n          if (null === e) return zu;\n\n          var t = this._projection.toNDC(e.minx, e.miny),\n              r = this._projection.toNDC(e.minx, e.maxy),\n              n = this._projection.toNDC(e.maxx, e.miny),\n              a = this._projection.toNDC(e.maxx, e.maxy),\n              i = {\n            minx: Math.min(t.x, r.x, n.x, a.x),\n            miny: Math.min(t.y, r.y, n.y, a.y),\n            maxx: Math.max(t.x, r.x, n.x, a.x),\n            maxy: Math.max(t.y, r.y, n.y, a.y)\n          },\n              o = {\n            minx: -1,\n            miny: -1,\n            maxx: 1,\n            maxy: 1\n          };\n\n          switch (!0) {\n            case this._isFeatureAABBInsideViewport(i, o):\n              return Uu;\n\n            case this._isFeatureAABBOutsideViewport(i, o):\n              return zu;\n\n            default:\n              return qu;\n          }\n        }\n      }, {\n        key: \"_isPolygonCollidingViewport\",\n        value: function _isPolygonCollidingViewport(e, t, r, n) {\n          if (!this.matrix) return !1;\n\n          for (var a = {\n            minx: -1,\n            miny: -1,\n            maxx: 1,\n            maxy: 1\n          }, i = r; i < n; i += 6) {\n            var o = this._projection.toNDC(e[i + 0], e[i + 1]),\n                u = this._projection.toNDC(e[i + 2], e[i + 3]),\n                s = this._projection.toNDC(e[i + 4], e[i + 5]);\n\n            if (triangleCollides([{\n              x: o.x,\n              y: o.y\n            }, {\n              x: u.x,\n              y: u.y\n            }, {\n              x: s.x,\n              y: s.y\n            }], a)) return !0;\n          }\n\n          return !1;\n        }\n      }, {\n        key: \"_isFeatureAABBInsideViewport\",\n        value: function _isFeatureAABBInsideViewport(e, t) {\n          return e.minx >= t.minx && e.maxx <= t.maxx && e.miny >= t.miny && e.maxy <= t.maxy;\n        }\n      }, {\n        key: \"_isFeatureAABBOutsideViewport\",\n        value: function _isFeatureAABBOutsideViewport(e, t) {\n          return e.minx > t.maxx || e.miny > t.maxy || e.maxx < t.minx || e.maxy < t.miny;\n        }\n      }, {\n        key: \"getPointsAtPosition\",\n        value: function getPointsAtPosition(e, t) {\n          for (var r = this.decodedGeom.vertices, n = [], a = 0; a < 6 * this.numFeatures; a += 6) {\n            var i = a / 6,\n                o = this.getFeature(i);\n\n            if (!this._isFeatureFiltered(o, t.filter)) {\n              var u = {\n                x: r[a],\n                y: r[a + 1]\n              },\n                  s = this._getCircleFor(u, o, t);\n\n              pointInCircle(e, s.center, s.radius) && n.push(o);\n            }\n          }\n\n          return n;\n        }\n      }, {\n        key: \"_isFeatureFiltered\",\n        value: function _isFeatureFiltered(e, t) {\n          return t.eval(e) < fu;\n        }\n      }, {\n        key: \"_getCircleFor\",\n        value: function _getCircleFor(e, t, r) {\n          var n = this._getCanvasSizeInPixels(),\n              a = n.WIDTH,\n              i = n.HEIGHT,\n              o = this._projection.toNDC(e.x, e.y);\n\n          o.x *= .5, o.y *= -.5, o.x += .5, o.y += .5, o.x *= a, o.y *= i;\n\n          var u = this._computePointRadius(t, r);\n\n          if (!r.symbol.default) {\n            var s = r.symbolPlacement.eval(t);\n            o.x += s[0] * u, o.y -= s[1] * u;\n          }\n\n          if (!r.transform.default) {\n            var c = r.transform.eval(t);\n            o.x += c.x, o.y -= c.y;\n          }\n\n          return {\n            center: o,\n            radius: u\n          };\n        }\n      }, {\n        key: \"getFeaturesAtPositionFromTriangles\",\n        value: function getFeaturesAtPositionFromTriangles(e, t, r) {\n          for (var n, a = this.decodedGeom.vertices, i = this.decodedGeom.normals, o = this.decodedGeom.breakpoints, u = [], s = -1, c = {\n            x: 0,\n            y: 0\n          }, l = this._getCanvasSizeInPixels(), f = l.WIDTH, h = l.HEIGHT, d = 0; d < a.length; d += 6) {\n            if (0 === d || d >= o[s]) {\n              s++;\n              var p = this.getFeature(s);\n\n              if (!r.transform.default) {\n                var m = r.transform.eval(p);\n                c.x = m[0], c.y = m[1];\n              }\n\n              if (n = e === pe.LINE ? this._computeLineWidthScale(p, r) : this._computePolygonWidthScale(p, r), this._isFeatureFiltered(p, r.filter) || !this._isPointInAABB(t, c, e === pe.LINE ? r.width.eval(p) : r.strokeWidth.eval(p), s)) {\n                d = o[s] - 6;\n                continue;\n              }\n            }\n\n            var v = this._projection.toNDC(a[d + 0] + i[d + 0] * n, a[d + 1] + i[d + 1] * n),\n                y = this._projection.toNDC(a[d + 2] + i[d + 2] * n, a[d + 3] + i[d + 3] * n),\n                g = this._projection.toNDC(a[d + 4] + i[d + 4] * n, a[d + 5] + i[d + 5] * n);\n\n            v.x *= .5, v.y *= -.5, v.x += .5, v.y += .5, y.x *= .5, y.y *= -.5, y.x += .5, y.y += .5, g.x *= .5, g.y *= -.5, g.x += .5, g.y += .5, pointInTriangle(t, {\n              x: v.x * f + c.x,\n              y: v.y * h - c.y\n            }, {\n              x: y.x * f + c.x,\n              y: y.y * h - c.y\n            }, {\n              x: g.x * f + c.x,\n              y: g.y * h - c.y\n            }) && (u.push(this.getFeature(s)), d = o[s] - 6);\n          }\n\n          return u;\n        }\n      }, {\n        key: \"_isPointInAABB\",\n        value: function _isPointInAABB(e, t, r, n) {\n          var a = this._aabb[n];\n          if (null === a || !this.matrix) return !1;\n\n          var i = this._projection.toNDC(a.minx, a.miny),\n              o = this._projection.toNDC(a.minx, a.maxy),\n              u = this._projection.toNDC(a.maxx, a.miny),\n              s = this._projection.toNDC(a.maxx, a.maxy),\n              c = {\n            minx: Math.min(i.x, o.x, u.x, s.x),\n            miny: Math.min(i.y, o.y, u.y, s.y),\n            maxx: Math.max(i.x, o.x, u.x, s.x),\n            maxy: Math.max(i.y, o.y, u.y, s.y)\n          },\n              l = this._getCanvasSizeInPixels(),\n              f = l.WIDTH,\n              h = l.HEIGHT,\n              d = 2 * t.x / f,\n              p = 2 * t.y / h,\n              m = e.x / f * 2 - 1,\n              v = -(e.y / h * 2 - 1),\n              y = {\n            minx: m + d - 2 * r / f,\n            miny: v - p - 2 * r / h,\n            maxx: m + d + 2 * r / f,\n            maxy: v - p + 2 * r / h\n          };\n\n          return !this._isFeatureAABBOutsideViewport(c, y);\n        }\n      }, {\n        key: \"_computePointRadius\",\n        value: function _computePointRadius(e, t) {\n          return (Math.min(t.width.eval(e), 1024) + Math.min(t.strokeWidth.eval(e), 1024)) / 2;\n        }\n      }, {\n        key: \"_computeLineWidthScale\",\n        value: function _computeLineWidthScale(e, t) {\n          return Math.min(t.width.eval(e), 1024) / 2 / this.scale / this._resolutionForZoomLevel();\n        }\n      }, {\n        key: \"_computePolygonWidthScale\",\n        value: function _computePolygonWidthScale(e, t) {\n          return Math.min(t.strokeWidth.eval(e), 1024) / 2 / this.scale / this._resolutionForZoomLevel();\n        }\n      }, {\n        key: \"_resolutionForZoomLevel\",\n        value: function _resolutionForZoomLevel() {\n          return 512 * Math.pow(2, this.renderer.drawMetadata.zoomLevel);\n        }\n      }, {\n        key: \"decodedGeom\",\n        get: function get() {\n          return this.dataframe.decodedGeom;\n        }\n      }, {\n        key: \"_aabb\",\n        get: function get() {\n          return this.dataframe._aabb;\n        }\n      }, {\n        key: \"numFeatures\",\n        get: function get() {\n          return this.dataframe.numFeatures;\n        }\n      }, {\n        key: \"renderer\",\n        get: function get() {\n          return this.dataframe.renderer;\n        }\n      }, {\n        key: \"matrix\",\n        get: function get() {\n          return this.dataframe.matrix;\n        }\n      }, {\n        key: \"scale\",\n        get: function get() {\n          return this.dataframe.scale;\n        }\n      }]), ViewportHelper;\n    }(),\n        Wu = new Map(),\n        Hu = function (e) {\n      function Dataframe() {\n        var e, t;\n        p()(this, Dataframe);\n\n        for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++) n[a] = arguments[a];\n\n        return (t = N()(this, (e = R()(Dataframe)).call.apply(e, [this].concat(n))))._initHelpers(), t;\n      }\n\n      return O()(Dataframe, e), v()(Dataframe, [{\n        key: \"_initHelpers\",\n        value: function _initHelpers() {\n          this._featureIdsHelper || (this._featureIdsHelper = new Ou(this)), this._viewportHelper || (this._viewportHelper = new ju(this));\n        }\n      }, {\n        key: \"bindRenderer\",\n        value: function bindRenderer(e) {\n          this.renderer = e, this._initHelpers(), this.addProperties(), this._loadVertices(), this._loadNormals(), this._loadFeatureIds(), this._createEmptyStyleTextures();\n        }\n      }, {\n        key: \"getSize\",\n        value: function getSize() {\n          var e = this.renderer.RTT_WIDTH;\n          return {\n            width: e,\n            height: Math.ceil(this.numFeatures / e)\n          };\n        }\n      }, {\n        key: \"_getGL\",\n        value: function _getGL() {\n          return this.renderer.gl;\n        }\n      }, {\n        key: \"_loadVertices\",\n        value: function _loadVertices() {\n          var e = this._getGL(),\n              t = this.decodedGeom.vertices;\n\n          this.vertexBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);\n        }\n      }, {\n        key: \"_loadNormals\",\n        value: function _loadNormals() {\n          var e = this._getGL(),\n              t = this.decodedGeom.normals;\n\n          t && (this.normalBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.normalBuffer), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW));\n        }\n      }, {\n        key: \"_loadFeatureIds\",\n        value: function _loadFeatureIds() {\n          var e = this._getGL(),\n              t = this._featureIdsHelper.getFeatureIds();\n\n          this.featureIDBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.featureIDBuffer), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);\n        }\n      }, {\n        key: \"getFeaturesAtPosition\",\n        value: function getFeaturesAtPosition(e, t) {\n          if (!this.matrix) return [];\n\n          switch (this.type) {\n            case pe.POINT:\n              return this._viewportHelper.getPointsAtPosition(e, t);\n\n            case pe.LINE:\n            case pe.POLYGON:\n              return this._viewportHelper.getFeaturesAtPositionFromTriangles(this.type, e, t);\n\n            default:\n              return [];\n          }\n        }\n      }, {\n        key: \"inViewport\",\n        value: function inViewport(e) {\n          if (!this.matrix) return !1;\n\n          switch (this.type) {\n            case pe.POINT:\n              return this._viewportHelper.isPointInViewport(e);\n\n            case pe.LINE:\n            case pe.POLYGON:\n              return this._viewportHelper.isPolygonInViewport(e);\n\n            default:\n              return !1;\n          }\n        }\n      }, {\n        key: \"getRenderedCentroid\",\n        value: function getRenderedCentroid(e) {\n          var t = Nr()({}, this._centroids[e]);\n          t.x = t.x * this.scale + this.center.x, t.y = t.y * this.scale + this.center.y;\n\n          var r = this._unprojectFromWebMercator(t);\n\n          return [r.lng, r.lat];\n        }\n      }, {\n        key: \"getPropertyTexture\",\n        value: function getPropertyTexture(e) {\n          return this.propertyTex[e] ? this.propertyTex[e] : (this._loadPropertyValuesToTexture(e), this.propertyTex[e]);\n        }\n      }, {\n        key: \"_loadPropertyValuesToTexture\",\n        value: function _loadPropertyValuesToTexture(e) {\n          var t = this._getGL(),\n              r = this.properties[e],\n              n = this.getSize(),\n              a = n.width,\n              i = n.height;\n\n          r && (this.propertyTex[e] = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.propertyTex[e]), t.texImage2D(t.TEXTURE_2D, 0, t.ALPHA, a, i, 0, t.ALPHA, t.FLOAT, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST));\n        }\n      }, {\n        key: \"free\",\n        value: function free() {\n          var e = this;\n          this._freeWebGLElements(), Object.keys(this).forEach(function (t) {\n            e[t] = null;\n          }), this.freed = !0;\n        }\n      }, {\n        key: \"_freeWebGLElements\",\n        value: function _freeWebGLElements() {\n          if (this.propertyTex) {\n            var e = this._getGL();\n\n            this.propertyTex.map(function (t) {\n              return e.deleteTexture(t);\n            }), e.deleteTexture(this.texColor), e.deleteTexture(this.texStrokeColor), e.deleteTexture(this.texWidth), e.deleteTexture(this.texStrokeWidth), e.deleteTexture(this.texFilter), e.deleteBuffer(this.vertexBuffer), e.deleteBuffer(this.featureIDBuffer);\n          }\n        }\n      }, {\n        key: \"_unprojectFromWebMercator\",\n        value: function _unprojectFromWebMercator(e) {\n          var t = e.x,\n              r = e.y,\n              n = Math.PI / 180;\n          return {\n            lng: t * ye / 6378137 / n,\n            lat: 2 * (Math.atan(Math.pow(Math.E, r * ye / 6378137)) - Math.PI / 4) / n\n          };\n        }\n      }, {\n        key: \"_genFeatureClass\",\n        value: function _genFeatureClass() {\n          if (Wu.has(this.metadata)) this._featureClass = Wu.get(this.metadata);else {\n            var e = function genViewportFeatureClass(e) {\n              var t = function ViewportFeature(e, t) {\n                p()(this, ViewportFeature), this._index = e, this._dataframe = t;\n              };\n\n              return Object.defineProperties(t.prototype, function buildGettersFrom(e) {\n                var t = {};\n                return e.propertyKeys.forEach(function (r) {\n                  var n = e.codec(r);\n\n                  if (n.isRange()) {\n                    var a = e.decodedProperties(r);\n                    t[r] = {\n                      get: function get() {\n                        var t = this,\n                            r = this._index,\n                            i = a.map(function (e) {\n                          return t._dataframe.properties[e][r];\n                        });\n                        return n.internalToExternal(e, i);\n                      }\n                    };\n                  } else t[r] = {\n                    get: function get() {\n                      var t = this._index,\n                          a = this._dataframe.properties[r][t];\n                      return n.internalToExternal(e, a);\n                    }\n                  };\n                }), t;\n              }(e)), t;\n            }(this.metadata);\n\n            Wu.set(this.metadata, e), this._featureClass = e;\n          }\n        }\n      }, {\n        key: \"getFeature\",\n        value: function getFeature(e) {\n          if (this.cachedFeatures || (this.cachedFeatures = new Array(this.numFeatures)), void 0 !== this.cachedFeatures[e]) return this.cachedFeatures[e];\n          this._featureClass || this._genFeatureClass();\n          var t = new this._featureClass(e, this);\n          return this.cachedFeatures[e] = t, t;\n        }\n      }, {\n        key: \"addProperties\",\n        value: function addProperties() {\n          for (var e = 0; e < this.metadata.propertyKeys.length; e++) {\n            var t = this.metadata.propertyKeys[e];\n\n            this._addProperty(t);\n          }\n\n          this._genFeatureClass();\n        }\n      }, {\n        key: \"_addProperty\",\n        value: function _addProperty(e) {\n          Object.keys(this.propertyTex).length < 32 && this.getPropertyTexture(e);\n        }\n      }, {\n        key: \"_createEmptyStyleTextures\",\n        value: function _createEmptyStyleTextures() {\n          this.texColor = this._createStyleDataframeTexture(), this.texWidth = this._createStyleDataframeTexture(), this.texStrokeColor = this._createStyleDataframeTexture(), this.texStrokeWidth = this._createStyleDataframeTexture(), this.texFilter = this._createStyleDataframeTexture();\n        }\n      }, {\n        key: \"_createStyleDataframeTexture\",\n        value: function _createStyleDataframeTexture() {\n          var e = this._getGL(),\n              t = this.getSize(),\n              r = t.width,\n              n = t.height,\n              a = e.createTexture();\n\n          return e.bindTexture(e.TEXTURE_2D, a), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, r, n, 0, e.RGBA, e.UNSIGNED_BYTE, null), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), a;\n        }\n      }]), Dataframe;\n    }(function DummyDataframe(e) {\n      var t = e.active,\n          r = e.center,\n          n = e.properties,\n          a = e.propertiesArrayBuffer,\n          i = e.scale,\n          o = e.type,\n          u = e.geom,\n          s = e.size,\n          c = e.metadata;\n      p()(this, DummyDataframe), this.active = t, this.center = r, this.properties = n, this.propertiesArrayBuffer = a, this.scale = i, this.type = o, this.decodedGeom = decodeGeom(o, u), this.numVertex = o === pe.POINT ? 3 * s : this.decodedGeom.vertices.length / 2, this.numFeatures = o === pe.POINT ? s : this.decodedGeom.breakpoints.length || this.numVertex, this.propertyTex = [], this.metadata = c, this.propertyCount = 0, this._aabb = function computeAABB(e, t) {\n        switch (t) {\n          case pe.POINT:\n            return [];\n\n          case pe.LINE:\n          case pe.POLYGON:\n            for (var r = [], n = 0; n < e.length; n++) {\n              for (var a = e[n], i = {\n                minx: Number.POSITIVE_INFINITY,\n                miny: Number.POSITIVE_INFINITY,\n                maxx: Number.NEGATIVE_INFINITY,\n                maxy: Number.NEGATIVE_INFINITY\n              }, o = 0; o < a.length; o++) i = _updateAABBForGeometry(a[o], i, t);\n\n              i.minx === Number.POSITIVE_INFINITY && (i = null), r.push(i);\n            }\n\n            return r;\n        }\n      }(u, o), this._centroids = computeCentroids(this.decodedGeom, o), this.t1 = [.1, .1, .1, .1], this.t2 = [.1, .1, .1, .1], this.t3 = [.1, .1, .1, .1], this.t4 = [.1, .1, .1, .1];\n    }),\n        Yu = 4096,\n        Zu = \"cartodb_id\",\n        Xu = function () {\n      function Metadata() {\n        var e = this,\n            t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {\n          properties: {}\n        },\n            r = t.properties,\n            n = t.featureCount,\n            a = t.sample,\n            i = t.geomType,\n            o = t.isAggregated,\n            u = t.idProperty,\n            s = t.extent;\n        p()(this, Metadata), this.properties = r, this.featureCount = n, this.sample = a, this.geomType = i, this.isAggregated = o, this.idProperty = u || Zu, this.properties.hasOwnProperty(this.idProperty) || (this.properties[this.idProperty] = {\n          type: \"number\"\n        }), this.categoryToID = new Map(), this.IDToCategory = new Map(), this.numCategories = 0, this.extent = s || Yu, Object.values(r).map(function (t) {\n          t.categories = t.categories || [], t.categories.map(function (r) {\n            return e.categorizeString(t, r.name, !0);\n          });\n        }), this.propertyKeys = Object.keys(r);\n      }\n\n      return v()(Metadata, [{\n        key: \"setCodecs\",\n        value: function setCodecs() {\n          throw new Ae('You must call \"setCodecs\" once you have determined the proper subclass');\n        }\n      }, {\n        key: \"categorizeString\",\n        value: function categorizeString(e, t) {\n          var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n          if (void 0 === t && (t = null), this.categoryToID.has(t)) return this.categoryToID.get(t);\n          r || null === t || this.properties[e].categories.push({\n            name: t,\n            frequency: Number.NaN\n          });\n          var n = null === t ? Wt : this.numCategories;\n          return this.categoryToID.set(t, n), this.IDToCategory.set(n, t), this.numCategories++, n;\n        }\n      }, {\n        key: \"decodedProperties\",\n        value: function decodedProperties(e) {\n          return [e];\n        }\n      }, {\n        key: \"baseName\",\n        value: function baseName(e) {\n          return e;\n        }\n      }, {\n        key: \"sourcePropertyName\",\n        value: function sourcePropertyName(e) {\n          return e;\n        }\n      }, {\n        key: \"stats\",\n        value: function stats(e) {\n          return this.properties[e];\n        }\n      }, {\n        key: \"codec\",\n        value: function codec(e) {\n          var t = this.baseName(e);\n          return this.properties[t] && this.properties[t].codec ? this.properties[t].codec : new kr();\n        }\n      }]), Metadata;\n    }(),\n        Qu = function (e) {\n      function NumberCodec() {\n        return p()(this, NumberCodec), N()(this, R()(NumberCodec).apply(this, arguments));\n      }\n\n      return O()(NumberCodec, e), v()(NumberCodec, [{\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          return (isNaN(t) || null == t) && (t = Wt), t;\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          return t === Wt && (t = null), t;\n        }\n      }, {\n        key: \"externalToInternal\",\n        value: function externalToInternal(e, t) {\n          return null === t && (t = Wt), t;\n        }\n      }]), NumberCodec;\n    }(kr),\n        $u = function (e) {\n      function MVTNumberCodec() {\n        return p()(this, MVTNumberCodec), N()(this, R()(MVTNumberCodec).apply(this, arguments));\n      }\n\n      return O()(MVTNumberCodec, e), v()(MVTNumberCodec, [{\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          var r = h()(t);\n          if (null !== t && \"undefined\" !== r && \"number\" !== r) throw new Ae(\"MVT decoding error. Metadata property '\".concat(this._baseName, \"' is of type 'number' but the MVT tile contained a feature property of type '\").concat(r, \"': '\").concat(t, \"'\"), Se.MVT);\n          return lt()(R()(MVTNumberCodec.prototype), \"sourceToInternal\", this).call(this, e, t);\n        }\n      }]), MVTNumberCodec;\n    }(Qu),\n        Ju = function (e) {\n      function CategoryCodec() {\n        return p()(this, CategoryCodec), N()(this, R()(CategoryCodec).apply(this, arguments));\n      }\n\n      return O()(CategoryCodec, e), v()(CategoryCodec, [{\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          return e.categorizeString(this._baseName, t);\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          return e.IDToCategory.get(t);\n        }\n      }, {\n        key: \"sourceToExternal\",\n        value: function sourceToExternal(e, t) {\n          return t;\n        }\n      }, {\n        key: \"externalToSource\",\n        value: function externalToSource(e, t) {\n          return t;\n        }\n      }]), CategoryCodec;\n    }(xr),\n        Ku = function (e) {\n      function MVTCategoryCodec() {\n        return p()(this, MVTCategoryCodec), N()(this, R()(MVTCategoryCodec).apply(this, arguments));\n      }\n\n      return O()(MVTCategoryCodec, e), v()(MVTCategoryCodec, [{\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          var r = h()(t);\n          if (null !== t && \"undefined\" !== r && \"string\" !== r) throw new Ae(\"MVT decoding error. Metadata property '\".concat(this._baseName, \"' is of type 'category' but the MVT tile contained a feature property of type '\").concat(r, \"': '\").concat(t, \"'\"), Se.MVT);\n          return lt()(R()(MVTCategoryCodec.prototype), \"sourceToInternal\", this).call(this, e, t);\n        }\n      }]), MVTCategoryCodec;\n    }(Ju);\n\n    var es = function (e) {\n      function MVTMetadata() {\n        return p()(this, MVTMetadata), N()(this, R()(MVTMetadata).apply(this, arguments));\n      }\n\n      return O()(MVTMetadata, e), v()(MVTMetadata, [{\n        key: \"setCodecs\",\n        value: function setCodecs() {\n          var e = this;\n          Object.keys(this.properties).forEach(function (t) {\n            var r = e.properties[t],\n                n = r.type;\n            \"geometry\" !== n && (r.codec = function MVTCodecFactory(e, t, r) {\n              switch (t) {\n                case \"number\":\n                  return new $u(e, r);\n\n                case \"category\":\n                  return new Ku(e, r);\n\n                default:\n                  throw new Ae(\"MVT decoding error. Feature property value of type '\".concat(t, \"' cannot be decoded.\"), Se.MVT);\n              }\n            }(e, n, t));\n          });\n        }\n      }]), MVTMetadata;\n    }(Xu),\n        ts = r(31),\n        rs = function () {\n      function DataframeCache() {\n        p()(this, DataframeCache);\n        this._cache = ts({\n          max: 256,\n          length: function length() {\n            return 1;\n          },\n          maxAge: 36e5,\n          dispose: function dispose(e, t) {\n            t.then(function (e) {\n              e.empty || e.free();\n            });\n          }\n        });\n      }\n\n      return v()(DataframeCache, [{\n        key: \"get\",\n        value: function get(e, t) {\n          var r = this._cache.get(e);\n\n          if (r) return r;\n          var n = t(e);\n          return this._cache.set(e, n), n;\n        }\n      }, {\n        key: \"free\",\n        value: function free() {\n          this._cache.reset();\n        }\n      }]), DataframeCache;\n    }();\n\n    function wToR(e, t, r) {\n      return {\n        x: (e - r.center.x) / r.scale,\n        y: (t - r.center.y) / r.scale\n      };\n    }\n\n    function rTiles(e, t) {\n      return function wRectangleTiles(e, t) {\n        for (var r = g()(t, 4), n = r[0], a = r[1], i = r[2], o = r[3], u = 1 << e, s = function clamp(e) {\n          return Math.min(Math.max(e, 0), u - 1);\n        }, c = s(Math.floor(u * (n + 1) * .5)), l = s(Math.ceil(u * (i + 1) * .5) - 1), f = s(Math.floor(u * (1 - o) * .5)), h = s(Math.ceil(u * (1 - a) * .5) - 1), d = [], p = c; p <= l; ++p) for (var m = f; m <= h; ++m) d.push({\n          x: p,\n          y: m,\n          z: e\n        });\n\n        return d;\n      }((arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Math.ceil)(e), t);\n    }\n\n    var ns = function () {\n      function TileClient(e) {\n        p()(this, TileClient), Array.isArray(e) || (e = [e]), this._templateURLs = e, this._nextGroupID = 0, this._currentRequestGroupID = 0, this._oldDataframes = [], this._cache = new rs();\n      }\n\n      return v()(TileClient, [{\n        key: \"bindLayer\",\n        value: function bindLayer(e) {\n          this._addDataframe = e;\n        }\n      }, {\n        key: \"requestData\",\n        value: function requestData(e, t, r) {\n          var n = rTiles(e, t, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.ceil);\n          return this._getTiles(n, r);\n        }\n      }, {\n        key: \"free\",\n        value: function free() {\n          this._cache.free(), this._cache = new rs(), this._oldDataframes = [];\n        }\n      }, {\n        key: \"_getTileUrl\",\n        value: function _getTileUrl(e, t, r) {\n          var n = this._getSubdomainIndex(e, t);\n\n          return this._templateURLs[n].replace(\"{x}\", e).replace(\"{y}\", t).replace(\"{z}\", r);\n        }\n      }, {\n        key: \"_getSubdomainIndex\",\n        value: function _getSubdomainIndex(e, t) {\n          return Math.abs(e + t) % this._templateURLs.length;\n        }\n      }, {\n        key: \"_getTiles\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee(e, t) {\n            var r,\n                n,\n                a,\n                i = this;\n            return tt.a.wrap(function _callee$(o) {\n              for (;;) switch (o.prev = o.next) {\n                case 0:\n                  return this._nextGroupID++, r = this._nextGroupID, o.next = 4, Promise.all(e.map(function (e) {\n                    var r = e.x,\n                        n = e.y,\n                        a = e.z;\n                    return i._cache.get(\"\".concat(r, \",\").concat(n, \",\").concat(a), function () {\n                      return i._requestDataframe(r, n, a, t);\n                    }).then(function (e) {\n                      return e.orderID = r + n / 1e3, e;\n                    });\n                  }));\n\n                case 4:\n                  if (n = o.sent, !(r < this._currentRequestGroupID)) {\n                    o.next = 7;\n                    break;\n                  }\n\n                  return o.abrupt(\"return\", !0);\n\n                case 7:\n                  return this._currentRequestGroupID = r, this._oldDataframes.forEach(function (e) {\n                    e.active = !1;\n                  }), n.forEach(function (e) {\n                    e.active = !0;\n                  }), a = !isSetsEqual(new Set(n), new Set(this._oldDataframes)), this._oldDataframes = n, o.abrupt(\"return\", a);\n\n                case 13:\n                case \"end\":\n                  return o.stop();\n              }\n            }, _callee, this);\n          }));\n          return function _getTiles(t, r) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_requestDataframe\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee2(e, t, r, n) {\n            var a, i;\n            return tt.a.wrap(function _callee2$(o) {\n              for (;;) switch (o.prev = o.next) {\n                case 0:\n                  return a = this._getTileUrl(e, t, r), o.next = 3, n(e, t, r, a);\n\n                case 3:\n                  return (i = o.sent).empty || this._addDataframe(i), o.abrupt(\"return\", i);\n\n                case 6:\n                case \"end\":\n                  return o.stop();\n              }\n            }, _callee2, this);\n          }));\n          return function _requestDataframe(t, r, n, a) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }]), TileClient;\n    }(),\n        as = r(39),\n        is = r.n(as),\n        os = function (e) {\n      function MVT(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new es(),\n            n = arguments.length > 2 ? arguments[2] : void 0;\n        return p()(this, MVT), (t = N()(this, R()(MVT).call(this)))._templateURL = e, t._tileClient = new ns(e), t._initMetadata(r), t._initOptions(n), t._workerDispatch = {}, t._mID = 0, t._workerName = \"MVT\", t;\n      }\n\n      return O()(MVT, e), v()(MVT, [{\n        key: \"_initMetadata\",\n        value: function _initMetadata(e) {\n          e instanceof Xu || (e = new es(e)), e.setCodecs(), this._metadata = e;\n        }\n      }, {\n        key: \"_initOptions\",\n        value: function _initOptions(e) {\n          void 0 === e && (e = {\n            layerID: void 0,\n            viewportZoomToSourceZoom: Math.ceil,\n            maxZoom: void 0\n          }), e.viewportZoomToSourceZoom = e.viewportZoomToSourceZoom || Math.ceil, this._options = e;\n        }\n      }, {\n        key: \"_receiveMessageFromWorker\",\n        value: function _receiveMessageFromWorker(e) {\n          var t = e.data,\n              r = t.mID,\n              n = t.dataframe;\n          n.empty || this._updateMetadataWith(n), this._workerDispatch[r](n);\n        }\n      }, {\n        key: \"_updateMetadataWith\",\n        value: function _updateMetadataWith(e) {\n          Object.setPrototypeOf(e, Hu.prototype);\n          var t = e.metadata;\n          this._metadata.numCategories = t.numCategories, this._metadata.categoryToID = t.categoryToID, this._metadata.IDToCategory = t.IDToCategory, this._metadata.geomType = t.geomType, e.metadata = this._metadata;\n        }\n      }, {\n        key: \"_clone\",\n        value: function _clone() {\n          return new MVT(this._templateURL, JSON.parse(JSON.stringify(this._metadata)), this._options);\n        }\n      }, {\n        key: \"bindLayer\",\n        value: function bindLayer(e) {\n          this._tileClient.bindLayer(e);\n        }\n      }, {\n        key: \"requestMetadata\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee() {\n            return tt.a.wrap(function _callee$(e) {\n              for (;;) switch (e.prev = e.next) {\n                case 0:\n                  return e.abrupt(\"return\", this._metadata);\n\n                case 1:\n                case \"end\":\n                  return e.stop();\n              }\n            }, _callee, this);\n          }));\n          return function requestMetadata() {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"requestData\",\n        value: function requestData(e, t) {\n          var r = this._urlToDataframeTransformer.bind(this),\n              n = this._viewportZoomToSourceZoom.bind(this);\n\n          return this._tileClient.requestData(e, t, r, n);\n        }\n      }, {\n        key: \"_urlToDataframeTransformer\",\n        value: function _urlToDataframeTransformer(e, t, r, n) {\n          var a = this;\n          return new Promise(function (i) {\n            var o = a._validUrlForWorker(n);\n\n            a._postMessageToWorker({\n              x: e,\n              y: t,\n              z: r\n            }, o), a._metadataSent = !0, a._workerDispatch[a._mID] = i, a._mID++;\n          });\n        }\n      }, {\n        key: \"_postMessageToWorker\",\n        value: function _postMessageToWorker(e, t) {\n          var r = e.x,\n              n = e.y,\n              a = e.z;\n\n          this._worker.postMessage({\n            x: r,\n            y: n,\n            z: a,\n            url: t,\n            layerID: this._options.layerID,\n            metadata: this._metadataSent ? void 0 : this._metadata,\n            mID: this._mID,\n            workerName: this._workerName\n          });\n        }\n      }, {\n        key: \"_viewportZoomToSourceZoom\",\n        value: function _viewportZoomToSourceZoom(e) {\n          var t = this._options.maxZoom,\n              r = this._options.viewportZoomToSourceZoom(e);\n\n          return void 0 === t ? r : Math.min(r, t);\n        }\n      }, {\n        key: \"_validUrlForWorker\",\n        value: function _validUrlForWorker(e) {\n          if (\".\" === e[0]) {\n            var t = window.location.pathname.split(\"/\");\n            t.pop();\n            var r = t.join(\"/\");\n            return \"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/\").concat(r, \"/\").concat(e);\n          }\n\n          return \"/\" === e[0] ? \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(e) : e;\n        }\n      }, {\n        key: \"free\",\n        value: function free() {\n          this._tileClient.free();\n        }\n      }, {\n        key: \"_worker\",\n        get: function get() {\n          return this._workerInstance || (this._workerInstance = new is.a(), this._workerInstance.onmessage = this._receiveMessageFromWorker.bind(this)), this._workerInstance;\n        }\n      }]), MVT;\n    }(su),\n        us = function (e) {\n      function WindshaftDateCodec(e, t) {\n        var r;\n        p()(this, WindshaftDateCodec), r = N()(this, R()(WindshaftDateCodec).call(this, e, t));\n        var n = e.stats(t).min;\n        return r._min_ms = 1e3 * n, r._min_date = msToDate(r._min_ms), r;\n      }\n\n      return O()(WindshaftDateCodec, e), v()(WindshaftDateCodec, [{\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          return msToDate(1e3 * t) - this._min_date;\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          var r = t;\n          return msToDate(r += this._min_ms);\n        }\n      }, {\n        key: \"externalToSource\",\n        value: function externalToSource(e, t) {\n          return t.getTime() / 1e3;\n        }\n      }, {\n        key: \"sourceToExternal\",\n        value: function sourceToExternal(e, t) {\n          return function asDate(e) {\n            if (e instanceof Date) return e;\n            return msToDate(1e3 * e);\n          }(t);\n        }\n      }, {\n        key: \"inlineInternalMatch\",\n        value: function inlineInternalMatch(e, t) {\n          var r = t._min_ms - this._min_ms;\n          return \"(\".concat(e, \"-\").concat(r.toFixed(20), \")\");\n        }\n      }]), WindshaftDateCodec;\n    }(xr);\n\n    var ss = function (e) {\n      function TimeRangeCodec(e, t) {\n        var r;\n        p()(this, TimeRangeCodec), r = N()(this, R()(TimeRangeCodec).call(this, e, t));\n        var n = e.stats(t),\n            a = n.min,\n            i = n.grouping && n.grouping.timezone,\n            o = util_timeRange({\n          timeZone: i,\n          iso: a\n        });\n        return r._min = o.startValue / 1e3, r._timeZone = i, r;\n      }\n\n      return O()(TimeRangeCodec, e), v()(TimeRangeCodec, [{\n        key: \"isRange\",\n        value: function isRange() {\n          return !0;\n        }\n      }, {\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          var r = this,\n              n = util_timeRange({\n            iso: t\n          });\n          return [n.startValue / 1e3, n.endValue / 1e3].map(function (e) {\n            return e - r._min;\n          });\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          var r = g()(t, 2),\n              n = r[0],\n              a = r[1];\n          return util_timeRange({\n            start: 1e3 * (n + this._min),\n            end: 1e3 * (a + this._min),\n            timeZone: this._timeZone\n          });\n        }\n      }, {\n        key: \"externalToSource\",\n        value: function externalToSource(e, t) {\n          return castTimeRange(t, this._timeZone)._iso;\n        }\n      }, {\n        key: \"sourceToExternal\",\n        value: function sourceToExternal(e, t) {\n          return util_timeRange({\n            iso: t,\n            timeZone: this._timeZone\n          });\n        }\n      }, {\n        key: \"inlineInternalMatch\",\n        value: function inlineInternalMatch(e, t) {\n          var r = t._min.getTime() - this._min.getTime();\n\n          return \"(\".concat(e, \"-\").concat(r.toFixed(20), \")\");\n        }\n      }]), TimeRangeCodec;\n    }(xr),\n        cs = function (e) {\n      function CartoMapsAPIError(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.DEFAULT;\n        return p()(this, CartoMapsAPIError), (t = N()(this, R()(CartoMapsAPIError).call(this, {\n          message: e,\n          type: r\n        }))).name = \"CartoMapsAPIError\", t;\n      }\n\n      return O()(CartoMapsAPIError, e), CartoMapsAPIError;\n    }(B),\n        ls = {\n      DEFAULT: \"[Error]\",\n      SQL: \"[SQL]\",\n      NOT_SUPPORTED: \"[Not supported]\",\n      SECURITY: \"[Security]\"\n    };\n\n    var fs = function (e) {\n      function WindshaftMetadata() {\n        var e, t;\n        p()(this, WindshaftMetadata);\n\n        for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++) n[a] = arguments[a];\n\n        return (t = N()(this, (e = R()(WindshaftMetadata)).call.apply(e, [this].concat(n)))).propertyKeys = [], t.baseNames = {}, Object.keys(t.properties).forEach(function (e) {\n          var r = t.properties[e];\n          r.aggregations ? Object.values(r.aggregations).forEach(function (r) {\n            t._addProperty(e, r);\n          }) : r.dimension ? r.dimension.range ? (r.dimension.range.forEach(function (r) {\n            t._addProperty(e, r, !1);\n          }), t._addProperty(e, r.dimension.propertyName)) : t._addProperty(e, r.dimension.propertyName) : t._addProperty(e, e);\n        }), t;\n      }\n\n      return O()(WindshaftMetadata, e), v()(WindshaftMetadata, [{\n        key: \"_addProperty\",\n        value: function _addProperty(e, t) {\n          var r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n          this.baseNames[t] = e, r && this.propertyKeys.push(t);\n        }\n      }, {\n        key: \"_dimensionInfo\",\n        value: function _dimensionInfo(e) {\n          var t = this.baseName(e) || e,\n              r = this.properties[t],\n              n = null;\n          t !== e && t !== e && r.dimension && (n = r.dimension);\n          var a = r.type,\n              i = n ? function dimensionBaseType(e) {\n            return e.type;\n          }(n) : a;\n          return {\n            baseName: t,\n            column: r,\n            dimension: n,\n            dataframeType: n ? function dimensionType(e, t) {\n              if (e.range) return \"date\";\n              return e.type;\n            }(n) : i,\n            baseType: a,\n            sourceType: i\n          };\n        }\n      }, {\n        key: \"baseName\",\n        value: function baseName(e) {\n          return this.baseNames[e];\n        }\n      }, {\n        key: \"decodedProperties\",\n        value: function decodedProperties(e) {\n          var t = this._dimensionInfo(e).dimension;\n\n          return t && t.grouping && t.range ? t.range : lt()(R()(WindshaftMetadata.prototype), \"decodedProperties\", this).call(this, e);\n        }\n      }, {\n        key: \"stats\",\n        value: function stats(e) {\n          var t = this._dimensionInfo(e).dimension;\n\n          return t && t.grouping ? t : lt()(R()(WindshaftMetadata.prototype), \"stats\", this).call(this, e);\n        }\n      }, {\n        key: \"setCodecs\",\n        value: function setCodecs() {\n          !function setMetadataCodecs(e) {\n            Object.keys(e.properties).forEach(function (t) {\n              var r = e.properties[t],\n                  n = r.type;\n\n              if (\"geometry\" !== n) {\n                var a = r.dimension ? r.dimension.type : null,\n                    i = a ? r.dimension.propertyName : t,\n                    o = \"category\" === a && r.dimension.range ? \"timerange\" : a;\n\n                r.codec = function windshaftCodecFactory(e, t, r) {\n                  switch (t) {\n                    case \"number\":\n                      return new Qu(e, r);\n\n                    case \"category\":\n                      return new Ju(e, r);\n\n                    case \"date\":\n                      return new us(e, r);\n\n                    case \"timerange\":\n                      return new ss(e, r);\n\n                    default:\n                      throw new cs(\"Windshaft MVT decoding error. Feature property value of type '\".concat(t, \"' cannot be decoded.\"), ls.NOT_SUPPORTED);\n                  }\n                }(e, o || n, i || t);\n              }\n            });\n          }(this);\n        }\n      }, {\n        key: \"sourcePropertyName\",\n        value: function sourcePropertyName(e) {\n          var t = this.baseName(e),\n              r = this.properties[t].dimension;\n          return r && r.range ? r.propertyName : e;\n        }\n      }]), WindshaftMetadata;\n    }(es);\n\n    var hs = function () {\n      function AggregationFiltering(e) {\n        p()(this, AggregationFiltering), this._onlyAggregateFilters = e.exclusive;\n      }\n\n      return v()(AggregationFiltering, [{\n        key: \"getFilters\",\n        value: function getFilters(e) {\n          var t = {},\n              r = this._and(e).filter(Boolean),\n              n = !0,\n              a = !1,\n              i = void 0;\n\n          try {\n            for (var o, u = r[Symbol.iterator](); !(n = (o = u.next()).done); n = !0) {\n              var s = o.value,\n                  c = s.property,\n                  l = t[c];\n\n              if (l) {\n                if (!this._compatibleAndFilters(l, s.filters)) return {};\n                Object.assign(l[0], s.filters[0]);\n              } else t[c] = s.filters;\n            }\n          } catch (e) {\n            a = !0, i = e;\n          } finally {\n            try {\n              n || null == u.return || u.return();\n            } finally {\n              if (a) throw i;\n            }\n          }\n\n          return t;\n        }\n      }, {\n        key: \"_and\",\n        value: function _and(e) {\n          return e.isA(wt) ? this._and(e.a).concat(this._and(e.b)).filter(Boolean) : [this._or(e)].filter(Boolean);\n        }\n      }, {\n        key: \"_or\",\n        value: function _or(e) {\n          if (e.isA(Rt)) {\n            var t = this._basicCondition(e.a),\n                r = this._basicCondition(e.b);\n\n            if (t && r && t.property === r.property) return t.filters = t.filters.concat(r.filters), t;\n          }\n\n          return this._basicCondition(e);\n        }\n      }, {\n        key: \"_removeBlend\",\n        value: function _removeBlend(e) {\n          return e.isA(Lt) && e.originalMix.isA(st) ? e.b : e;\n        }\n      }, {\n        key: \"_basicCondition\",\n        value: function _basicCondition(e) {\n          return e = this._removeBlend(e), this._between(e) || this._equals(e) || this._notEquals(e) || this._lessThan(e) || this._lessThanOrEqualTo(e) || this._greaterThan(e) || this._greaterThanOrEqualTo(e) || this._in(e) || this._notIn(e);\n        }\n      }, {\n        key: \"_value\",\n        value: function _value(e) {\n          if ((e = this._removeBlend(e)).isA(Pr) || e.isA(dr) || e.isA(Zt)) return e.value;\n        }\n      }, {\n        key: \"_between\",\n        value: function _between(e) {\n          if (e.isA(dt)) {\n            var t = this._aggregation(e.input),\n                r = t && this._value(e.lowerLimit),\n                n = t && r && this._value(e.upperLimit);\n\n            if (n) return t.filters.push({\n              greater_than_or_equal_to: r,\n              less_than_or_equal_to: n\n            }), t;\n          }\n        }\n      }, {\n        key: \"_in\",\n        value: function _in(e) {\n          var t = this;\n\n          if (e.isA(ft)) {\n            var r = this._aggregation(e.input),\n                n = e.list.elems.map(function (e) {\n              return t._value(e);\n            }).filter(function (e) {\n              return null !== e;\n            });\n\n            if (r && n.length > 0 && n.length === e.list.elems.length) return r.filters.push({\n              in: n\n            }), r;\n          }\n        }\n      }, {\n        key: \"_notIn\",\n        value: function _notIn(e) {\n          var t = this;\n\n          if (e.isA(ht)) {\n            var r = this._aggregation(e.input),\n                n = e.list.elems.map(function (e) {\n              return t._value(e);\n            }).filter(function (e) {\n              return null !== e;\n            });\n\n            if (r && n.length > 0 && n.length === e.list.elems.length) return r.filters.push({\n              not_in: n\n            }), r;\n          }\n        }\n      }, {\n        key: \"_equals\",\n        value: function _equals(e) {\n          return this._cmpOp(e, Et, \"equal\");\n        }\n      }, {\n        key: \"_notEquals\",\n        value: function _notEquals(e) {\n          return this._cmpOp(e, Dt, \"not_equal\");\n        }\n      }, {\n        key: \"_lessThan\",\n        value: function _lessThan(e) {\n          return this._cmpOp(e, St, \"less_than\", \"greater_than\");\n        }\n      }, {\n        key: \"_lessThanOrEqualTo\",\n        value: function _lessThanOrEqualTo(e) {\n          return this._cmpOp(e, Pt, \"less_than_or_equal_to\", \"greater_than_or_equal_to\");\n        }\n      }, {\n        key: \"_greaterThan\",\n        value: function _greaterThan(e) {\n          return this._cmpOp(e, Mt, \"greater_than\", \"less_than\");\n        }\n      }, {\n        key: \"_greaterThanOrEqualTo\",\n        value: function _greaterThanOrEqualTo(e) {\n          return this._cmpOp(e, At, \"greater_than_or_equal_to\", \"less_than_or_equal_to\");\n        }\n      }, {\n        key: \"_aggregation\",\n        value: function _aggregation(e) {\n          if ((e = this._removeBlend(e)).isA(rr) || e.isA(nr) || e.isA(ar) || e.isA(ir) || e.isA(ur)) {\n            var t = this._property(e.property);\n\n            if (t) return t.property = e.propertyName, t;\n          }\n\n          if (!this._onlyAggregateFilters) return this._property(e);\n        }\n      }, {\n        key: \"_property\",\n        value: function _property(e) {\n          if ((e = this._removeBlend(e)).isA(er)) return {\n            property: e.name,\n            filters: []\n          };\n        }\n      }, {\n        key: \"_cmpOp\",\n        value: function _cmpOp(e, t, r, n) {\n          if (n = n || r, e.isA(t)) {\n            var a = this._aggregation(e.a),\n                i = a && this._value(e.b),\n                o = r;\n\n            if (i || (i = (a = this._aggregation(e.b)) && this._value(e.a), o = n), i) {\n              var u = {};\n              return u[o] = i, a.filters.push(u), a;\n            }\n          }\n        }\n      }, {\n        key: \"_compatibleAndFilters\",\n        value: function _compatibleAndFilters(e, t) {\n          if (0 === e.length || 0 === t.length) return !0;\n\n          if (1 === e.length && 1 === t.length) {\n            var r = e[0],\n                n = t[0];\n\n            if (1 === Object.keys(r).length && 1 === Object.keys(n).length) {\n              var a = Object.keys(r)[0],\n                  i = Object.keys(n)[0],\n                  o = [\"less_than\", \"less_than_or_equal_to\"],\n                  u = [\"greater_than\", \"greater_than_or_equal_to\"];\n              return o.includes(a) && u.includes(i) || o.includes(i) && u.includes(a);\n            }\n          }\n\n          return !1;\n        }\n      }]), AggregationFiltering;\n    }(),\n        ds = function () {\n      function PreaggregationFiltering() {\n        p()(this, PreaggregationFiltering);\n      }\n\n      return v()(PreaggregationFiltering, [{\n        key: \"getFilter\",\n        value: function getFilter(e) {\n          return this._filter(e);\n        }\n      }, {\n        key: \"_filter\",\n        value: function _filter(e) {\n          return this._and(e) || this._or(e) || this._in(e) || this._notIn(e) || this._between(e) || this._equals(e) || this._notEquals(e) || this._lessThan(e) || this._lessThanOrEqualTo(e) || this._greaterThan(e) || this._greaterThanOrEqualTo(e) || this._blend(e) || null;\n        }\n      }, {\n        key: \"_and\",\n        value: function _and(e) {\n          if (e.isA(wt)) {\n            var t = [this._filter(e.a), this._filter(e.b)].filter(Boolean).reduce(function (e, t) {\n              return e.concat(t);\n            }, []);\n            if (t.length) return 1 === t.length ? t[0] : {\n              type: \"and\",\n              left: t[0],\n              right: t[1]\n            };\n          }\n        }\n      }, {\n        key: \"_or\",\n        value: function _or(e) {\n          if (e.isA(Rt)) {\n            var t = this._filter(e.a),\n                r = this._filter(e.b);\n\n            if (t && r) return {\n              type: \"or\",\n              left: t,\n              right: r\n            };\n          }\n        }\n      }, {\n        key: \"_lessThan\",\n        value: function _lessThan(e) {\n          return this._cmpOp(e, St, \"lessThan\");\n        }\n      }, {\n        key: \"_lessThanOrEqualTo\",\n        value: function _lessThanOrEqualTo(e) {\n          return this._cmpOp(e, Pt, \"lessThanOrEqualTo\");\n        }\n      }, {\n        key: \"_greaterThan\",\n        value: function _greaterThan(e) {\n          return this._cmpOp(e, Mt, \"greaterThan\");\n        }\n      }, {\n        key: \"_greaterThanOrEqualTo\",\n        value: function _greaterThanOrEqualTo(e) {\n          return this._cmpOp(e, At, \"greaterThanOrEqualTo\");\n        }\n      }, {\n        key: \"_equals\",\n        value: function _equals(e) {\n          return this._cmpOp(e, Et, \"equals\");\n        }\n      }, {\n        key: \"_notEquals\",\n        value: function _notEquals(e) {\n          return this._cmpOp(e, Dt, \"notEquals\");\n        }\n      }, {\n        key: \"_cmpOp\",\n        value: function _cmpOp(e, t, r) {\n          if (e.isA(t)) {\n            var n = this._property(e.a) || this._value(e.a),\n                a = this._property(e.b) || this._value(e.b);\n\n            if (n && a) return {\n              type: r,\n              left: n,\n              right: a\n            };\n          }\n        }\n      }, {\n        key: \"_blend\",\n        value: function _blend(e) {\n          if (e.isA(Lt) && e.originalMix.isA(st)) return this._filter(e.b);\n        }\n      }, {\n        key: \"_property\",\n        value: function _property(e) {\n          if (e.isA(er)) return {\n            type: \"property\",\n            property: e.name\n          };\n        }\n      }, {\n        key: \"_value\",\n        value: function _value(e) {\n          if (e.isA(Pr) || e.isA(dr) || e.isA(Zt)) return {\n            type: \"value\",\n            value: e.value\n          };\n        }\n      }, {\n        key: \"_in\",\n        value: function _in(e) {\n          var t = this;\n\n          if (e.isA(ft)) {\n            var r = this._property(e.input),\n                n = e.list.elems.map(function (e) {\n              return t._value(e);\n            });\n\n            if (r && n.length > 0 && n.length === e.list.elems.length) return {\n              type: \"in\",\n              property: r.property,\n              values: n.map(function (e) {\n                return e.value;\n              })\n            };\n          }\n        }\n      }, {\n        key: \"_notIn\",\n        value: function _notIn(e) {\n          var t = this;\n\n          if (e.isA(ht)) {\n            var r = this._property(e.input),\n                n = e.list.elems.map(function (e) {\n              return t._value(e);\n            });\n\n            if (r && n.length > 0 && n.length === e.list.elems.length) return {\n              type: \"notIn\",\n              property: r.property,\n              values: n.map(function (e) {\n                return e.value;\n              })\n            };\n          }\n        }\n      }, {\n        key: \"_between\",\n        value: function _between(e) {\n          if (e.isA(dt)) {\n            var t = this._property(e.input),\n                r = this._value(e.lowerLimit),\n                n = this._value(e.upperLimit);\n\n            if (t && r && n) return {\n              type: \"between\",\n              property: t.property,\n              lower: r.value,\n              upper: n.value\n            };\n          }\n        }\n      }]), PreaggregationFiltering;\n    }();\n\n    function getSQL(e) {\n      return e.type ? \"(\".concat(ps[e.type](e), \")\") : sqlQ(e);\n    }\n\n    function sqlQ(e) {\n      return isFinite(e) ? String(e) : \"'\".concat(e.replace(/\\'/g, \"''\"), \"'\");\n    }\n\n    function sqlId(e) {\n      return e.match(/^[a-z\\d_]+$/) || (e = '\"'.concat(e.replace(/\\\"/g, '\"\"'), '\"')), e;\n    }\n\n    function sqlSep(e) {\n      for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];\n\n      return r.map(function (e) {\n        return getSQL(e);\n      }).join(e);\n    }\n\n    var ps = {\n      and: function and(e) {\n        return sqlSep(\" AND \", e.left, e.right);\n      },\n      or: function or(e) {\n        return sqlSep(\" OR \", e.left, e.right);\n      },\n      between: function between(e) {\n        return \"\".concat(sqlId(e.property), \" BETWEEN \").concat(sqlQ(e.lower), \" AND \").concat(sqlQ(e.upper));\n      },\n      in: function _in(e) {\n        return \"\".concat(sqlId(e.property), \" IN (\").concat(sqlSep.apply(void 0, [\",\"].concat(l()(e.values))), \")\");\n      },\n      notIn: function notIn(e) {\n        return \"\".concat(sqlId(e.property), \" NOT IN (\").concat(sqlSep.apply(void 0, [\",\"].concat(l()(e.values))), \")\");\n      },\n      equals: function equals(e) {\n        return sqlSep(\" = \", e.left, e.right);\n      },\n      notEquals: function notEquals(e) {\n        return sqlSep(\" <> \", e.left, e.right);\n      },\n      lessThan: function lessThan(e) {\n        return sqlSep(\" < \", e.left, e.right);\n      },\n      lessThanOrEqualTo: function lessThanOrEqualTo(e) {\n        return sqlSep(\" <= \", e.left, e.right);\n      },\n      greaterThan: function greaterThan(e) {\n        return sqlSep(\" > \", e.left, e.right);\n      },\n      greaterThanOrEqualTo: function greaterThanOrEqualTo(e) {\n        return sqlSep(\" >= \", e.left, e.right);\n      },\n      property: function property(e) {\n        return sqlId(e.property);\n      },\n      value: function value(e) {\n        return sqlQ(e.value);\n      }\n    };\n\n    function getAggregationFilters(e) {\n      return e && e.aggregation;\n    }\n\n    var ms = r(17),\n        vs = function () {\n      function WindshaftRequestHelper(e, t) {\n        p()(this, WindshaftRequestHelper), this._conf = e, this._mapConfig = t, this._auth = this._encodeParameter(\"api_key\", this._conf.apiKey), this._client = this._encodeParameter(\"client\", \"vl-\".concat(ms.a));\n      }\n\n      return v()(WindshaftRequestHelper, [{\n        key: \"getLayerGroup\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee() {\n            var e, t;\n            return tt.a.wrap(function _callee$(r) {\n              for (;;) switch (r.prev = r.next) {\n                case 0:\n                  return r.prev = 0, r.next = 3, fetch(this._makeHttpRequest());\n\n                case 3:\n                  e = r.sent, r.next = 9;\n                  break;\n\n                case 6:\n                  throw r.prev = 6, r.t0 = r.catch(0), new cs(\"Failed to connect to Maps API with your user('\".concat(this._source._username, \"')\"));\n\n                case 9:\n                  return r.next = 11, e.json();\n\n                case 11:\n                  return t = r.sent, e.ok || this._dealWithWindshaftErrors(e, t), r.abrupt(\"return\", t);\n\n                case 14:\n                case \"end\":\n                  return r.stop();\n              }\n            }, _callee, this, [[0, 6]]);\n          }));\n          return function getLayerGroup() {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_makeHttpRequest\",\n        value: function _makeHttpRequest() {\n          var e = [this._auth, this._client, this._encodeParameter(\"config\", this._mapConfigPayload())],\n              t = this._generateUrl(this._generateMapsApiUrl(), e);\n\n          return t.length < 2048 ? this._getRequest(t) : this._postRequest();\n        }\n      }, {\n        key: \"_dealWithWindshaftErrors\",\n        value: function _dealWithWindshaftErrors(e, t) {\n          if (401 === e.status) throw new cs(\"Unauthorized access to Maps API: invalid combination of user('\".concat(this._source._username, \"') and apiKey('\").concat(this._source._apiKey, \"')\"), ls.SECURITY);\n          if (403 === e.status) throw new cs(\"Unauthorized access to dataset: the provided apiKey('\".concat(this._source._apiKey, \"') doesn't provide access to the requested data\"), ls.SECURITY);\n          throw new cs(\"\".concat(JSON.stringify(t.errors)), ls.SQL);\n        }\n      }, {\n        key: \"_mapConfigPayload\",\n        value: function _mapConfigPayload() {\n          return JSON.stringify(this._mapConfig);\n        }\n      }, {\n        key: \"_getRequest\",\n        value: function _getRequest(e) {\n          return new Request(e, {\n            method: \"GET\",\n            headers: {\n              Accept: \"application/json\"\n            }\n          });\n        }\n      }, {\n        key: \"_postRequest\",\n        value: function _postRequest() {\n          var e = [this._auth, this._client];\n          return new Request(this._generateUrl(this._generateMapsApiUrl(), e), {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\",\n              \"Content-Type\": \"application/json\"\n            },\n            body: this._mapConfigPayload()\n          });\n        }\n      }, {\n        key: \"_encodeParameter\",\n        value: function _encodeParameter(e, t) {\n          return \"\".concat(e, \"=\").concat(encodeURIComponent(t));\n        }\n      }, {\n        key: \"_generateUrl\",\n        value: function _generateUrl(e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];\n          return \"\".concat(e, \"?\").concat(t.join(\"&\"));\n        }\n      }, {\n        key: \"_generateMapsApiUrl\",\n        value: function _generateMapsApiUrl(e) {\n          var t = \"\".concat(this._conf.serverURL, \"/api/v1/map\");\n          return e && (t += e), t;\n        }\n      }]), WindshaftRequestHelper;\n    }(),\n        ys = function () {\n      function Windshaft(e) {\n        p()(this, Windshaft), this._source = e, this._exclusive = !0, this._MNS = null, this._promiseMNS = null, this.inProgressInstantiations = {};\n      }\n\n      return v()(Windshaft, [{\n        key: \"bindLayer\",\n        value: function bindLayer(e) {\n          this._addDataframe = e, this._mvtClient.bindLayer(e);\n        }\n      }, {\n        key: \"_getInstantiationID\",\n        value: function _getInstantiationID(e, t) {\n          var r = e.MNS,\n              n = e.resolution,\n              a = e.filtering;\n          return JSON.stringify({\n            MNS: Ee.simplify(r),\n            resolution: n,\n            filtering: t.backendFilters ? a : null,\n            options: t\n          });\n        }\n      }, {\n        key: \"getMetadata\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee(e) {\n            var t, r;\n            return tt.a.wrap(function _callee$(n) {\n              for (;;) switch (n.prev = n.next) {\n                case 0:\n                  if (t = this._getServerInfoFrom(e), !this._needToInstantiateMap(t)) {\n                    n.next = 6;\n                    break;\n                  }\n\n                  return n.next = 4, this._repeatableInstantiate(t);\n\n                case 4:\n                  r = n.sent, this._updateStateAfterInstantiating(r);\n\n                case 6:\n                  return n.abrupt(\"return\", this.metadata);\n\n                case 7:\n                case \"end\":\n                  return n.stop();\n              }\n            }, _callee, this);\n          }));\n          return function getMetadata(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_getServerInfoFrom\",\n        value: function _getServerInfoFrom(e) {\n          return {\n            MNS: this._getMinNeededSchemaFrom(e),\n            resolution: e.resolution.value,\n            filtering: function getFiltering(e) {\n              var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n                  r = new hs(t),\n                  n = {\n                preaggregation: new ds(t).getFilter(e.filter),\n                aggregation: r.getFilters(e.filter)\n              };\n              return n.preaggregation || n.aggregation ? n : null;\n            }(e, {\n              exclusive: this._exclusive\n            })\n          };\n        }\n      }, {\n        key: \"_getMinNeededSchemaFrom\",\n        value: function _getMinNeededSchemaFrom(e) {\n          var t = e.getMinimumNeededSchema();\n          return this._checkAcceptableMNS(t), this._forceIncludeCartodbId(t), t;\n        }\n      }, {\n        key: \"_forceIncludeCartodbId\",\n        value: function _forceIncludeCartodbId(e) {\n          e[Zu] || (e[Zu] = [{\n            type: ke\n          }]);\n        }\n      }, {\n        key: \"requiresNewMetadata\",\n        value: function requiresNewMetadata(e) {\n          var t = this._getServerInfoFrom(e);\n\n          return this._needToInstantiateMap(t);\n        }\n      }, {\n        key: \"_checkAcceptableMNS\",\n        value: function _checkAcceptableMNS(e) {\n          Object.keys(e).forEach(function (t) {\n            var r = e[t],\n                n = r.some(function (e) {\n              return e.type === xe;\n            }),\n                a = r.some(function (e) {\n              return e.type === ke;\n            });\n\n            if (n && a) {\n              var i = JSON.stringify(r.filter(function (e) {\n                return \"aggregated\" !== e.type;\n              }));\n              throw new he(\"Incompatible combination of cluster aggregation usages (\".concat(i, \") with unaggregated usage for property '\").concat(t, \"'\"), de.INCORRECT_VALUE);\n            }\n          });\n        }\n      }, {\n        key: \"getData\",\n        value: function getData(e, t) {\n          if (this._mvtClient) return this._mvtClient.requestData(e, t);\n        }\n      }, {\n        key: \"_needToInstantiateMap\",\n        value: function _needToInstantiateMap(e) {\n          var t = e.MNS,\n              r = e.resolution,\n              n = e.filtering,\n              a = Ee.notEquals(this._MNS, t),\n              i = this.resolution !== r,\n              o = JSON.stringify(this.filtering) !== JSON.stringify(n),\n              u = this.metadata && this.metadata.featureCount > 2e6;\n          return a || i || o && u;\n        }\n      }, {\n        key: \"_isInstantiated\",\n        value: function _isInstantiated() {\n          return !!this.metadata;\n        }\n      }, {\n        key: \"_instantiationChoices\",\n        value: function _instantiationChoices(e) {\n          var t = {\n            backendFilters: !0\n          };\n\n          if (e && e.featureCount >= 0) {\n            var r = e.featureCount > 2e6;\n            t.backendFilters = r || !e.backendFiltersApplied;\n          }\n\n          return t;\n        }\n      }, {\n        key: \"_instantiateUncached\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee2(e) {\n            var t,\n                r,\n                n,\n                a,\n                i,\n                o,\n                u,\n                s,\n                c,\n                l,\n                f,\n                h,\n                d,\n                p,\n                m,\n                v,\n                y = arguments;\n            return tt.a.wrap(function _callee2$(g) {\n              for (;;) switch (g.prev = g.next) {\n                case 0:\n                  return t = y.length > 1 && void 0 !== y[1] ? y[1] : {\n                    backendFilters: !0\n                  }, r = y.length > 2 && void 0 !== y[2] ? y[2] : null, n = e.MNS, a = e.resolution, i = e.filtering, g.next = 5, this._generateAggregation(n, a);\n\n                case 5:\n                  return o = g.sent, u = this._buildSelectClause(n), s = this._buildQuery(u), c = \"(\".concat(s, \") AS tmp\"), l = t.backendFilters ? i : null, f = !1, l && this._requiresAggregation(n) && (o.filters = getAggregationFilters(l), o.filters && (f = !0), this._exclusive || (l = null)), l && (h = this._buildQuery(u, l), f = f || h !== s, s = h), d = this._getConfig(), g.next = 16, this._getInstantiationPromise(c, d, o, s, u, r, n);\n\n                case 16:\n                  return p = g.sent, m = p.urlTemplates, (v = p.metadata).backendFiltersApplied = f, g.abrupt(\"return\", {\n                    MNS: n,\n                    resolution: a,\n                    filtering: i,\n                    metadata: v,\n                    urlTemplates: m\n                  });\n\n                case 21:\n                case \"end\":\n                  return g.stop();\n              }\n            }, _callee2, this);\n          }));\n          return function _instantiateUncached(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_updateStateAfterInstantiating\",\n        value: function _updateStateAfterInstantiating(e) {\n          var t = e.MNS,\n              r = e.resolution,\n              n = e.filtering,\n              a = e.metadata,\n              i = e.urlTemplates;\n          this._mvtClient && this._mvtClient.free(), a.extent = 2048, this._mvtClient = new os(i, a), this._mvtClient._workerName = \"windshaft\", this._mvtClient.bindLayer(this._addDataframe), this.urlTemplates = i, this.metadata = a, this._MNS = t, this.filtering = n, this.resolution = r, this._checkLayerMeta(t);\n        }\n      }, {\n        key: \"_instantiate\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee3(e, t, r) {\n            var n, a;\n            return tt.a.wrap(function _callee3$(i) {\n              for (;;) switch (i.prev = i.next) {\n                case 0:\n                  if (n = this._getInstantiationID(e, t), !this.inProgressInstantiations[n]) {\n                    i.next = 3;\n                    break;\n                  }\n\n                  return i.abrupt(\"return\", this.inProgressInstantiations[n]);\n\n                case 3:\n                  return a = this._instantiateUncached(e, t, r), this.inProgressInstantiations[n] = a, i.abrupt(\"return\", a);\n\n                case 6:\n                case \"end\":\n                  return i.stop();\n              }\n            }, _callee3, this);\n          }));\n          return function _instantiate(t, r, n) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_repeatableInstantiate\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee4(e) {\n            var t,\n                r,\n                n,\n                a = this;\n            return tt.a.wrap(function _callee4$(i) {\n              for (;;) switch (i.prev = i.next) {\n                case 0:\n                  return t = null, r = this._instantiationChoices(this.metadata), n = function finalChoices(e) {\n                    return t = e.metadata, a._instantiationChoices(e.metadata);\n                  }, i.abrupt(\"return\", repeatablePromise(r, n, function (r) {\n                    return a._instantiate(e, r, t);\n                  }));\n\n                case 4:\n                case \"end\":\n                  return i.stop();\n              }\n            }, _callee4, this);\n          }));\n          return function _repeatableInstantiate(t) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_checkLayerMeta\",\n        value: function _checkLayerMeta(e) {\n          if (!this._isAggregated() && this._requiresAggregation(e)) throw new cs(\"Aggregation not supported for this dataset\", ls.NOT_SUPPORTED);\n        }\n      }, {\n        key: \"_isAggregated\",\n        value: function _isAggregated() {\n          return this.metadata && this.metadata.isAggregated;\n        }\n      }, {\n        key: \"_requiresAggregation\",\n        value: function _requiresAggregation(e) {\n          return Object.values(e).some(function (e) {\n            return e.some(function (e) {\n              return e.type === xe;\n            });\n          });\n        }\n      }, {\n        key: \"_generateAggregation\",\n        value: function _generateAggregation(e, t) {\n          var r = {\n            columns: {},\n            dimensions: {},\n            placement: \"centroid\",\n            resolution: t,\n            threshold: 1\n          };\n          return Object.keys(e).forEach(function (t) {\n            t !== Zu && e[t].forEach(function (e) {\n              if (\"aggregated\" === e.type) r.columns[Ee.column.aggColumn(t, e.op)] = {\n                aggregate_function: e.op,\n                aggregated_column: t\n              };else if (\"dimension\" === e.type) {\n                var n = e.dimension,\n                    a = n.group,\n                    i = n.format,\n                    o = {\n                  column: t,\n                  group: a,\n                  format: i\n                };\n                r.dimensions[n.propertyName] = o;\n              } else r.dimensions[t] = {\n                column: t\n              };\n            });\n          }), r;\n        }\n      }, {\n        key: \"_buildSelectClause\",\n        value: function _buildSelectClause(e) {\n          var t = Object.keys(e).concat([\"the_geom_webmercator\", Zu]);\n          return t.filter(function (e, r) {\n            return t.indexOf(e) === r;\n          });\n        }\n      }, {\n        key: \"_buildQuery\",\n        value: function _buildQuery(e, t) {\n          var r = e.map(function (e) {\n            return '\"'.concat(e, '\"');\n          }).join(),\n              n = t ? function getSQLWhere(e) {\n            var t;\n            return (e = e && e.preaggregation) && Object.keys(e).length > 0 && (t = getSQL(e)), t ? \"WHERE \" + t : \"\";\n          }(t) : \"\";\n          return \"SELECT \".concat(r, \" FROM \").concat(this._source._getFromClause(), \" \").concat(n);\n        }\n      }, {\n        key: \"_getConfig\",\n        value: function _getConfig() {\n          return {\n            apiKey: this._source._apiKey,\n            username: this._source._username,\n            serverURL: this._source._serverURL\n          };\n        }\n      }, {\n        key: \"free\",\n        value: function free() {\n          this._mvtClient && this._mvtClient.free();\n        }\n      }, {\n        key: \"_getInstantiationPromise\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee5(e, t, r, n, a, i, o) {\n            var u, s;\n            return tt.a.wrap(function _callee5$(e) {\n              for (;;) switch (e.prev = e.next) {\n                case 0:\n                  return u = this._getMapConfigAgg(r, n), i || this._completeMapConfigWithColumns(u, a), e.next = 4, this._getLayerGroupFromWindshaft(t, u);\n\n                case 4:\n                  return s = e.sent, e.abrupt(\"return\", {\n                    urlTemplates: s.metadata.tilejson.vector.tiles,\n                    metadata: i || this._adaptMetadata(s.metadata.layers[0].meta, r, o)\n                  });\n\n                case 6:\n                case \"end\":\n                  return e.stop();\n              }\n            }, _callee5, this);\n          }));\n          return function _getInstantiationPromise(t, r, n, a, i, o, u) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_getMapConfigAgg\",\n        value: function _getMapConfigAgg(e, t) {\n          return {\n            buffersize: {\n              mvt: 1\n            },\n            layers: [{\n              type: \"mapnik\",\n              options: {\n                sql: t,\n                aggregation: e,\n                vector_extent: 2048,\n                vector_simplify_extent: 2048,\n                dates_as_numbers: !0\n              }\n            }]\n          };\n        }\n      }, {\n        key: \"_completeMapConfigWithColumns\",\n        value: function _completeMapConfigWithColumns(e, t) {\n          var r = [\"the_geom\", \"the_geom_webmercator\"],\n              n = t.filter(function (e) {\n            return !r.includes(e);\n          });\n          e.layers[0].options.metadata = {\n            geometryType: !0,\n            columnStats: {\n              topCategories: 32768,\n              includeNulls: !0\n            },\n            dimensions: !0,\n            sample: {\n              num_rows: 1e3,\n              include_columns: n\n            }\n          };\n        }\n      }, {\n        key: \"_getLayerGroupFromWindshaft\",\n        value: function () {\n          var e = nt()(tt.a.mark(function _callee6(e, t) {\n            var r;\n            return tt.a.wrap(function _callee6$(n) {\n              for (;;) switch (n.prev = n.next) {\n                case 0:\n                  return r = new vs(e, t), n.abrupt(\"return\", r.getLayerGroup());\n\n                case 2:\n                case \"end\":\n                  return n.stop();\n              }\n            }, _callee6, this);\n          }));\n          return function _getLayerGroupFromWindshaft(t, r) {\n            return e.apply(this, arguments);\n          };\n        }()\n      }, {\n        key: \"_adaptMetadata\",\n        value: function _adaptMetadata(e, t, r) {\n          e.datesAsNumbers = e.dates_as_numbers;\n\n          var n = e.stats,\n              a = e.aggregation,\n              i = e.datesAsNumbers,\n              o = n.hasOwnProperty(\"featureCount\") ? n.featureCount : n.estimatedFeatureCount,\n              u = n.geometryType && function adaptGeometryType(e) {\n            switch (e) {\n              case \"ST_MultiPolygon\":\n              case \"ST_Polygon\":\n                return pe.POLYGON;\n\n              case \"ST_Point\":\n                return pe.POINT;\n\n              case \"ST_MultiLineString\":\n              case \"ST_LineString\":\n                return pe.LINE;\n\n              default:\n                throw new cs(\"Unimplemented geometry type '\".concat(e, \"'.\"), ls.NOT_SUPPORTED);\n            }\n          }(n.geometryType),\n              s = n.columns;\n\n          return Object.keys(t.columns).forEach(function (e) {\n            var r = t.columns[e].aggregated_column,\n                n = t.columns[e].aggregate_function;\n            s[r].aggregations || (s[r].aggregations = {}), s[r].aggregations[n] = e, r !== e && (s[e] = JSON.parse(JSON.stringify(s[r])));\n          }), Object.keys(t.dimensions).forEach(function (e) {\n            var a = t.dimensions[e];\n\n            if (n.dimensions && n.dimensions[e].type) {\n              var i = n.dimensions[e],\n                  o = adaptColumnType(i.type),\n                  u = a.column,\n                  c = Mu()(a, [\"column\"]);\n              if (s[u].dimension) throw new cs(\"Multiple dimensions based on same column '\".concat(u, \"'.\"), ls.NOT_SUPPORTED);\n              s[u].dimension = {\n                propertyName: e,\n                grouping: 0 === Object.keys(c).length ? void 0 : i.params,\n                type: o,\n                min: i.min,\n                max: i.max\n              }, r[u].some(function (e) {\n                return e.range;\n              }) > 0 && (s[u].dimension.range = [\"start\", \"end\"].map(function (t) {\n                return \"\".concat(e, \"_\").concat(t);\n              }));\n            }\n          }), Object.values(s).map(function (e) {\n            e.type = adaptColumnType(e.type);\n          }), Object.keys(s).forEach(function (e) {\n            var t = s[e];\n            \"category\" === t.type && t.categories ? t.categories.forEach(function (e) {\n              e.name = e.category, delete e.category;\n            }) : i && i.includes(e) && (t.type = \"date\");\n          }), u === pe.POINT && (s._cdb_feature_count = {\n            type: \"number\"\n          }), new fs({\n            properties: s,\n            featureCount: o,\n            sample: n.sample,\n            geomType: u,\n            isAggregated: a.mvt,\n            idProperty: Zu\n          });\n        }\n      }]), Windshaft;\n    }();\n\n    function adaptColumnType(e) {\n      return \"string\" === e ? \"category\" : e;\n    }\n\n    function repeatablePromise(e, t, r) {\n      return _repeatablePromise.apply(this, arguments);\n    }\n\n    function _repeatablePromise() {\n      return (_repeatablePromise = nt()(tt.a.mark(function _callee7(e, t, r) {\n        var n, a, i;\n        return tt.a.wrap(function _callee7$(o) {\n          for (;;) switch (o.prev = o.next) {\n            case 0:\n              return n = r(e), o.next = 3, n;\n\n            case 3:\n              if (a = o.sent, i = t(a), JSON.stringify(e) !== JSON.stringify(i)) {\n                o.next = 9;\n                break;\n              }\n\n              return o.abrupt(\"return\", n);\n\n            case 9:\n              return o.abrupt(\"return\", r(i));\n\n            case 10:\n            case \"end\":\n              return o.stop();\n          }\n        }, _callee7, this);\n      }))).apply(this, arguments);\n    }\n\n    var gs = function (e) {\n      function BaseWindshaft() {\n        var e;\n        return p()(this, BaseWindshaft), (e = N()(this, R()(BaseWindshaft).call(this)))._client = new ys(Vt()(Vt()(e))), e;\n      }\n\n      return O()(BaseWindshaft, e), v()(BaseWindshaft, [{\n        key: \"initialize\",\n        value: function initialize(e, t) {\n          this._initializeAuth(e), this._initializeConfig(t), this._initializeServerURL();\n        }\n      }, {\n        key: \"_initializeAuth\",\n        value: function _initializeAuth(e) {\n          this._auth = e || function getDefaultAuth() {\n            return ge;\n          }(), checkAuth(this._auth), this._apiKey = this._auth.apiKey, this._username = this._auth.username;\n        }\n      }, {\n        key: \"_initializeConfig\",\n        value: function _initializeConfig(e) {\n          this._config = e || function getDefaultConfig() {\n            return _e;\n          }(), checkConfig(this._config);\n        }\n      }, {\n        key: \"_initializeServerURL\",\n        value: function _initializeServerURL() {\n          var e = this._config && this._config.serverURL || \"https://{user}.carto.com\";\n          e = e.replace(/{user}/, this._username), this._serverURL = e;\n        }\n      }, {\n        key: \"bindLayer\",\n        value: function bindLayer(e) {\n          this._client.bindLayer(e);\n        }\n      }, {\n        key: \"requiresNewMetadata\",\n        value: function requiresNewMetadata(e) {\n          return this._client.requiresNewMetadata(e);\n        }\n      }, {\n        key: \"requestMetadata\",\n        value: function requestMetadata(e) {\n          return this._client.getMetadata(e);\n        }\n      }, {\n        key: \"requestData\",\n        value: function requestData(e, t) {\n          return this._client.getData(e, t);\n        }\n      }, {\n        key: \"free\",\n        value: function free() {\n          this._client.free();\n        }\n      }]), BaseWindshaft;\n    }(su),\n        _s = function (e) {\n      function Dataset(e, t, r) {\n        var n;\n        return p()(this, Dataset), (n = N()(this, R()(Dataset).call(this)))._checkTableName(e), n._tableName = e, n.initialize(t, r), n;\n      }\n\n      return O()(Dataset, e), v()(Dataset, [{\n        key: \"_getFromClause\",\n        value: function _getFromClause() {\n          return this._tableName;\n        }\n      }, {\n        key: \"_clone\",\n        value: function _clone() {\n          return new Dataset(this._tableName, this._auth, this._config);\n        }\n      }, {\n        key: \"_checkTableName\",\n        value: function _checkTableName(e) {\n          if (be.isUndefined(e)) throw new he(\"'tableName'\", de.MISSING_REQUIRED);\n          if (!be.isString(e)) throw new he(\"'tableName' property must be a string.\", de.INCORRECT_TYPE);\n          if (\"\" === e) throw new he(\"'tableName' property must be not empty.\", de.INCORRECT_VALUE);\n        }\n      }]), Dataset;\n    }(gs),\n        bs = function () {\n      function GeoJSONGeometryTransformer(e) {\n        p()(this, GeoJSONGeometryTransformer), this._center = e;\n      }\n\n      return v()(GeoJSONGeometryTransformer, [{\n        key: \"computePoint\",\n        value: function computePoint(e) {\n          var t = e[1],\n              r = e[0],\n              n = be.projectToWebMercator({\n            lat: t,\n            lng: r\n          }),\n              a = {\n            scale: be.WM_R,\n            center: this._center\n          };\n          return wToR(n.x, n.y, a);\n        }\n      }, {\n        key: \"computeLineString\",\n        value: function computeLineString(e, t) {\n          for (var r = [], n = 0; n < e.length; n++) {\n            var a = this.computePoint(e[t ? e.length - n - 1 : n]);\n            r.push(a.x, a.y);\n          }\n\n          return r;\n        }\n      }, {\n        key: \"computeMultiLineString\",\n        value: function computeMultiLineString(e) {\n          for (var t = [], r = 0; r < e.length; r++) {\n            var n = this.computeLineString(e[r]);\n            n.length > 0 && t.push(n);\n          }\n\n          return t;\n        }\n      }, {\n        key: \"computePolygon\",\n        value: function computePolygon(e) {\n          var t = {\n            flat: [],\n            holes: [],\n            clipped: []\n          },\n              r = 0,\n              n = !1;\n\n          if (e.length) {\n            n = this._isReversed(e[0]);\n            var a = this.computeLineString(e[0], n);\n            t.flat = t.flat.concat(a);\n          }\n\n          for (var i = 1; i < e.length; i++) {\n            n !== this._isReversed(e[i]) && (r += e[i - 1].length, t.holes.push(r));\n            var o = this.computeLineString(e[i], n);\n            t.flat = t.flat.concat(o);\n          }\n\n          return t;\n        }\n      }, {\n        key: \"computeMultiPolygon\",\n        value: function computeMultiPolygon(e) {\n          for (var t = [], r = 0; r < e.length; r++) {\n            var n = this.computePolygon(e[r]);\n            n.flat.length > 0 && t.push(n);\n          }\n\n          return t;\n        }\n      }, {\n        key: \"_isReversed\",\n        value: function _isReversed(e) {\n          for (var t, r = 0, n = e[0], a = 0; a < e.length - 1; a++) r += ((t = e[a + 1])[1] - n[1]) * (t[0] + n[0]), n = t;\n\n          return r >= 0;\n        }\n      }]), GeoJSONGeometryTransformer;\n    }(),\n        xs = Object.freeze({\n      POINT: \"Point\",\n      LINE_STRING: \"LineString\",\n      MULTI_LINE_STRING: \"MultiLineString\",\n      POLYGON: \"Polygon\",\n      MULTI_POLYGON: \"MultiPolygon\"\n    });\n\n    function dataframeGeometryType(e) {\n      switch (e) {\n        case xs.POINT:\n          return pe.POINT;\n\n        case xs.LINE_STRING:\n        case xs.MULTI_LINE_STRING:\n          return pe.LINE;\n\n        case xs.POLYGON:\n        case xs.MULTI_POLYGON:\n          return pe.POLYGON;\n\n        default:\n          return \"\";\n      }\n    }\n\n    var ks = function (e) {\n      function DateCodec(e, t) {\n        var r;\n        p()(this, DateCodec), r = N()(this, R()(DateCodec).call(this, e, t));\n        var n = e.stats(t).min;\n        return r._min_date = castDate(n), r._min_ms = r._min_date.getTime(), r;\n      }\n\n      return O()(DateCodec, e), v()(DateCodec, [{\n        key: \"sourceToInternal\",\n        value: function sourceToInternal(e, t) {\n          return castDate(t).getTime() - this._min_ms;\n        }\n      }, {\n        key: \"internalToExternal\",\n        value: function internalToExternal(e, t) {\n          var r = t;\n          return msToDate(r += this._min_ms);\n        }\n      }, {\n        key: \"externalToSource\",\n        value: function externalToSource(e, t) {\n          return t.getTime();\n        }\n      }, {\n        key: \"sourceToExternal\",\n        value: function sourceToExternal(e, t) {\n          return castDate(t);\n        }\n      }, {\n        key: \"inlineInternalMatch\",\n        value: function inlineInternalMatch(e, t) {\n          var r = t._min_ms - this._min_ms;\n          return \"(\".concat(e, \"-\").concat(r.toFixed(20), \")\");\n        }\n      }]), DateCodec;\n    }(xr);\n\n    var Ts = function (e) {\n      function GeoJSONMetadata() {\n        return p()(this, GeoJSONMetadata), N()(this, R()(GeoJSONMetadata).apply(this, arguments));\n      }\n\n      return O()(GeoJSONMetadata, e), v()(GeoJSONMetadata, [{\n        key: \"setCodecs\",\n        value: function setCodecs() {\n          var e = this;\n          Object.keys(this.properties).forEach(function (t) {\n            var r = e.properties[t],\n                n = r.type;\n            \"geometry\" !== n && (r.codec = function codecFactory(e, t, r) {\n              switch (t) {\n                case \"number\":\n                  return new Qu(e, r);\n\n                case \"category\":\n                  return new Ju(e, r);\n\n                case \"date\":\n                  return new ks(e, r);\n\n                default:\n                  throw new Ae(\"Feature property value of type '\".concat(t, \"' cannot be decoded.\"), Se.NOT_SUPPORTED);\n              }\n            }(e, n, t));\n          });\n        }\n      }]), GeoJSONMetadata;\n    }(Xu),\n        ws = function () {\n      function GeoJSONMetadataBuilder(e, t) {\n        p()(this, GeoJSONMetadataBuilder), this._providedDateColumns = e, this._boundColumns = t, this._numFields = new Set(), this._catFields = new Set(), this._dateFields = new Set(), this._properties = {};\n      }\n\n      return v()(GeoJSONMetadataBuilder, [{\n        key: \"buildFrom\",\n        value: function buildFrom(e, t) {\n          this._addNumericColumnField(Zu);\n\n          for (var r = [], n = this._requiredColumnsIn(e), a = 0; a < t.length; a++) {\n            var i = t[a].properties;\n            this._addPropertiesToMetadata(i, n), this._sampleFeatureOnMetadata(i, r, t.length);\n          }\n\n          this._calculateAvgForNumericFields();\n\n          var o = new Ts({\n            properties: this._properties,\n            featureCount: t.length,\n            sample: r,\n            geomType: this._dataframeGeomTypeFrom(t),\n            idProperty: Zu\n          });\n          return o.setCodecs(), o;\n        }\n      }, {\n        key: \"getCurrentFields\",\n        value: function getCurrentFields() {\n          return l()(this._numFields).concat(l()(this._catFields)).concat(l()(this._dateFields));\n        }\n      }, {\n        key: \"_requiredColumnsIn\",\n        value: function _requiredColumnsIn(e) {\n          return new Set(Object.keys(Ee.simplify(e.getMinimumNeededSchema())));\n        }\n      }, {\n        key: \"_addPropertiesToMetadata\",\n        value: function _addPropertiesToMetadata(e, t) {\n          for (var r = Object.keys(e), n = 0, a = r.length; n < a; n++) {\n            var i = r[n];\n\n            if (t.has(i) && !this._boundColumns.has(i)) {\n              var o = e[i];\n\n              this._addPropertyToMetadata(i, o);\n            }\n          }\n        }\n      }, {\n        key: \"_calculateAvgForNumericFields\",\n        value: function _calculateAvgForNumericFields() {\n          var e = this;\n\n          this._numFields.forEach(function (t) {\n            var r = e._properties[t];\n            r.avg = r.sum / r.count;\n          });\n        }\n      }, {\n        key: \"_dataframeGeomTypeFrom\",\n        value: function _dataframeGeomTypeFrom(e) {\n          var t = \"\";\n          return e.length > 0 && (t = dataframeGeometryType(e[0].geometry.type)), t;\n        }\n      }, {\n        key: \"_sampleFeatureOnMetadata\",\n        value: function _sampleFeatureOnMetadata(e, t, r) {\n          if (r > 1e3) {\n            var n = 1e3 / r;\n            if (Math.random() > n) return;\n          }\n\n          t.push(e);\n        }\n      }, {\n        key: \"_addNumericPropertyToMetadata\",\n        value: function _addNumericPropertyToMetadata(e, t) {\n          if (this._catFields.has(e) || this._dateFields.has(e)) throw new he(\"Unsupported GeoJSON: the property '\".concat(e, \"' has different types in different features.\"), de.INCORRECT_TYPE);\n\n          this._addNumericColumnField(e);\n\n          var r = this._properties[e];\n          r.min = Math.min(r.min, t), r.max = Math.max(r.max, t), r.sum += t;\n        }\n      }, {\n        key: \"_addNumericColumnField\",\n        value: function _addNumericColumnField(e) {\n          this._numFields.has(e) || (this._numFields.add(e), this._properties[e] = {\n            type: \"number\",\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY,\n            avg: Number.NaN,\n            sum: 0,\n            count: 0\n          });\n        }\n      }, {\n        key: \"_addDatePropertyToMetadata\",\n        value: function _addDatePropertyToMetadata(e, t) {\n          if (this._catFields.has(e) || this._numFields.has(e)) throw new Ae(\"Unsupported GeoJSON: the property '\".concat(e, \"' has different types in different features.\"), Se.NOT_SUPPORTED);\n\n          this._addDateColumnField(e);\n\n          var r = this._properties[e],\n              n = be.castDate(t);\n          r.min = r.min ? be.castDate(Math.min(r.min, n)) : n, r.max = r.max ? be.castDate(Math.max(r.max, n)) : n, r.sum += t, r.count++;\n        }\n      }, {\n        key: \"_addDateColumnField\",\n        value: function _addDateColumnField(e) {\n          this._dateFields.has(e) || (this._dateFields.add(e), this._properties[e] = {\n            type: \"date\",\n            min: null,\n            max: null,\n            avg: null,\n            sum: 0,\n            count: 0\n          });\n        }\n      }, {\n        key: \"_addPropertyToMetadata\",\n        value: function _addPropertyToMetadata(e, t) {\n          return this._providedDateColumns.has(e) ? this._addDatePropertyToMetadata(e, t) : Number.isFinite(t) ? this._addNumericPropertyToMetadata(e, t) : void (null !== t && this._addCategoryPropertyToMetadata(e, t));\n        }\n      }, {\n        key: \"_addCategoryPropertyToMetadata\",\n        value: function _addCategoryPropertyToMetadata(e, t) {\n          if (this._numFields.has(e) || this._dateFields.has(e)) throw new Ae(\"Unsupported GeoJSON: the property '\".concat(e, \"' has different types in different features.\"), Se.NOT_SUPPORTED);\n          this._catFields.has(e) || (this._catFields.add(e), this._properties[e] = {\n            type: \"category\",\n            categories: []\n          });\n          var r = this._properties[e],\n              n = r.categories.find(function (e) {\n            return e.name === t;\n          });\n          n ? n.frequency++ : r.categories.push({\n            name: t,\n            frequency: 1\n          });\n        }\n      }]), GeoJSONMetadataBuilder;\n    }(),\n        Cs = function (e) {\n      function GeoJSON(e) {\n        var t,\n            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        return p()(this, GeoJSON), (t = N()(this, R()(GeoJSON).call(this)))._initializeData(e), t._initializeMetadataHelpers(r), t;\n      }\n\n      return O()(GeoJSON, e), v()(GeoJSON, [{\n        key: \"_initializeData\",\n        value: function _initializeData(e) {\n          this._checkData(e), this._data = e, this._features = this._featuresFromData(), this._geomType = this._getGeomType(), this._webMercatorCenter = this._getWebMercatorCoordsCenter(), this._geometryTransformer = new bs(this._webMercatorCenter);\n        }\n      }, {\n        key: \"_initializeMetadataHelpers\",\n        value: function _initializeMetadataHelpers(e) {\n          this._providedDateColumns = new Set(e.dateColumns), this._boundColumns = new Set(), this._metadataBuilder = new ws(this._providedDateColumns, this._boundColumns);\n        }\n      }, {\n        key: \"_checkData\",\n        value: function _checkData(e) {\n          if (be.isUndefined(e)) throw new he(\"'data'\", de.MISSING_REQUIRED);\n          if (!be.isObject(e)) throw new he(\"'data' property must be an object.\", de.INCORRECT_TYPE);\n        }\n      }, {\n        key: \"_featuresFromData\",\n        value: function _featuresFromData() {\n          var e,\n              t = this._data.type;\n          if (\"FeatureCollection\" === t) e = this._data.features;else {\n            if (\"Feature\" !== t) throw new he(\"'data' property must be a GeoJSON object.\", de.INCORRECT_VALUE);\n            e = [this._data];\n          }\n          return this._initializePropertiesIn(e), e;\n        }\n      }, {\n        key: \"_getGeomType\",\n        value: function _getGeomType() {\n          return this._features[0].geometry.type;\n        }\n      }, {\n        key: \"_getWebMercatorCoordsCenter\",\n        value: function _getWebMercatorCoordsCenter() {\n          var e = this,\n              t = 0,\n              r = 0,\n              n = 0;\n          return this._fetchFeatureGeometry({\n            sample: 10\n          }, function (a, i) {\n            var o = e._samplePoint(i),\n                u = be.projectToWebMercator({\n              lng: o[0],\n              lat: o[1]\n            });\n\n            t += u.x, r += u.y, n += 1;\n          }), n > 1 && (t /= n, r /= n), {\n            x: t,\n            y: r\n          };\n        }\n      }, {\n        key: \"_getDataframeCenter\",\n        value: function _getDataframeCenter() {\n          var e = {\n            scale: be.WM_R,\n            center: {\n              x: 0,\n              y: 0\n            }\n          },\n              t = this._webMercatorCenter;\n          return wToR(t.x, t.y, e);\n        }\n      }, {\n        key: \"bindLayer\",\n        value: function bindLayer(e) {\n          this._addDataframe = e;\n        }\n      }, {\n        key: \"requestMetadata\",\n        value: function requestMetadata(e) {\n          return Promise.resolve(this._computeMetadata(e));\n        }\n      }, {\n        key: \"requestData\",\n        value: function requestData() {\n          var e = this;\n\n          if (this._dataframe) {\n            var t = this._decodeUnboundProperties();\n\n            this._dataframe.addProperties();\n\n            var r = Object.keys(t);\n            return r.forEach(function (t) {\n              e._boundColumns.add(t);\n            }), Promise.resolve(r.length > 0);\n          }\n\n          return this._dataframe = this._createNewDataframe(), Promise.resolve(!0);\n        }\n      }, {\n        key: \"_createNewDataframe\",\n        value: function _createNewDataframe() {\n          var e = new Hu({\n            active: !0,\n            center: this._getDataframeCenter(),\n            geom: this._decodeGeometry(),\n            properties: this._decodeUnboundProperties(),\n            scale: 1,\n            size: this._features.length,\n            type: dataframeGeometryType(this._geomType),\n            metadata: this._metadata\n          });\n          return this._boundColumns = new Set(Object.keys(e.properties)), this._addDataframe && this._addDataframe(e), e;\n        }\n      }, {\n        key: \"requiresNewMetadata\",\n        value: function requiresNewMetadata() {\n          return !1;\n        }\n      }, {\n        key: \"_clone\",\n        value: function _clone() {\n          return new GeoJSON(this._data, {\n            dateColumns: Array.from(this._providedDateColumns)\n          });\n        }\n      }, {\n        key: \"_initializePropertiesIn\",\n        value: function _initializePropertiesIn(e) {\n          for (var t = 0; t < e.length; t++) e[t].properties = e[t].properties || {};\n        }\n      }, {\n        key: \"_computeMetadata\",\n        value: function _computeMetadata(e) {\n          return this._metadata = this._metadataBuilder.buildFrom(e, this._features), this._metadata;\n        }\n      }, {\n        key: \"_decodeUnboundProperties\",\n        value: function _decodeUnboundProperties() {\n          for (var e = this, t = this._getUnboundProperties(), r = Object.keys(t), n = function _loop(n) {\n            var a = e._features[n];\n            r.forEach(function (r) {\n              r !== Zu || Number.isFinite(a.properties[Zu]) || (a.properties[Zu] = -n), t[r][n] = e._metadata.codec(r).sourceToInternal(e._metadata, a.properties[r]);\n            });\n          }, a = 0; a < this._features.length; a++) n(a);\n\n          return t;\n        }\n      }, {\n        key: \"_getUnboundProperties\",\n        value: function _getUnboundProperties() {\n          var e = this,\n              t = {};\n          return this._metadataBuilder.getCurrentFields().forEach(function (r) {\n            e._boundColumns.has(r) || (t[r] = new Float32Array(e._features.length + 1024));\n          }), t;\n        }\n      }, {\n        key: \"_fetchFeatureGeometry\",\n        value: function _fetchFeatureGeometry() {\n          for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, r = this._features.length, n = e.sample ? Math.max(1, Math.floor(r / e.sample)) : 1, a = 0; a < r; a += n) {\n            var i = this._features[a];\n            \"Feature\" === i.type && t(a, i.geometry);\n          }\n\n          return null;\n        }\n      }, {\n        key: \"_allocGeometry\",\n        value: function _allocGeometry() {\n          return \"Point\" === this._geomType ? new Float32Array(6 * this._features.length) : [];\n        }\n      }, {\n        key: \"_decodeGeometry\",\n        value: function _decodeGeometry() {\n          var e = this,\n              t = this._allocGeometry();\n\n          return this._fetchFeatureGeometry({}, function (r, n) {\n            var a = n.type,\n                i = n.coordinates,\n                o = dataframeGeometryType(a),\n                u = dataframeGeometryType(e._geomType);\n            if (o !== u) throw new he(\"multiple geometry types not supported: found '\".concat(o, \"' instead of '\").concat(u, \"'.\"), de.INCORRECT_TYPE);\n\n            if (a === xs.POINT) {\n              var s = e._geometryTransformer.computePoint(i);\n\n              t[6 * r + 0] = s.x, t[6 * r + 1] = s.y, t[6 * r + 2] = s.x, t[6 * r + 3] = s.y, t[6 * r + 4] = s.x, t[6 * r + 5] = s.y;\n            } else if (a === xs.LINE_STRING) {\n              var c = e._geometryTransformer.computeLineString(i);\n\n              t.push([c]);\n            } else if (a === xs.MULTI_LINE_STRING) {\n              var l = e._geometryTransformer.computeMultiLineString(i);\n\n              t.push(l);\n            } else if (a === xs.POLYGON) {\n              var f = e._geometryTransformer.computePolygon(i);\n\n              t.push([f]);\n            } else if (a === xs.MULTI_POLYGON) {\n              var h = e._geometryTransformer.computeMultiPolygon(i);\n\n              t.push(h);\n            }\n          }), t;\n        }\n      }, {\n        key: \"_samplePoint\",\n        value: function _samplePoint(e) {\n          var t = e.type,\n              r = e.coordinates;\n          return t === xs.POINT ? r : t === xs.LINE_STRING ? r[0] : t === xs.MULTI_LINE_STRING || t === xs.POLYGON ? r[0][0] : t === xs.MULTI_POLYGON ? r[0][0][0] : void 0;\n        }\n      }, {\n        key: \"free\",\n        value: function free() {}\n      }]), GeoJSON;\n    }(su),\n        Es = function (e) {\n      function SQL(e, t, r) {\n        var n;\n        return p()(this, SQL), (n = N()(this, R()(SQL).call(this)))._checkQuery(e), n._query = e, n.initialize(t, r), n;\n      }\n\n      return O()(SQL, e), v()(SQL, [{\n        key: \"_getFromClause\",\n        value: function _getFromClause() {\n          return \"(\".concat(this._query, \") as _cdb_query_wrapper\");\n        }\n      }, {\n        key: \"_clone\",\n        value: function _clone() {\n          return new SQL(this._query, this._auth, this._config);\n        }\n      }, {\n        key: \"_checkQuery\",\n        value: function _checkQuery(e) {\n          if (be.isUndefined(e)) throw new he(\"'query'\", de.MISSING_REQUIRED);\n          if (!be.isString(e)) throw new he(\"'query' property must be a string.\", de.INCORRECT_TYPE);\n          if (\"\" === e) throw new he(\"'query' property must be not empty.\", de.INCORRECT_VALUE);\n          if (!e.match(/\\bSELECT\\b/i)) throw new he(\"'query' property must be a SQL query.\", de.INCORRECT_VALUE);\n        }\n      }]), SQL;\n    }(gs),\n        Ms = [];\n\n    function on(e, t, r) {\n      var n = [];\n\n      if (\"loaded\" === e) {\n        var a = new Set(t);\n        t.forEach(function (e) {\n          var t = function internalCallback() {\n            a.delete(e), 0 === a.size && r();\n          };\n\n          e.on(\"loaded\", t), n.push(t);\n        });\n      } else {\n        if (\"updated\" !== e) throw new he(\"Event name '\".concat(e, \"' is not supported by \\\"carto.on\\\". Supported event names are: 'loaded' and 'updated'.\"), de.INCORRECT_VALUE);\n        var i = !1;\n        t.forEach(function (e) {\n          var t = function internalCallback() {\n            i || window.requestAnimationFrame(function () {\n              i = !1, r();\n            });\n          };\n\n          e.on(\"updated\", t), n.push(t);\n        });\n      }\n\n      Ms.push({\n        eventName: e,\n        layerList: t,\n        callback: r,\n        internalCallbacks: n\n      });\n    }\n\n    function off(e, t, r) {\n      Ms.forEach(function (n) {\n        n.eventName === e && n.layerList.every(function (e) {\n          return t.includes(e);\n        }) && n.callback === r && n.layerList.forEach(function (t) {\n          n.internalCallbacks.forEach(function (r) {\n            t.off(e, r);\n          });\n        });\n      }), Ms = Ms.filter(function (n) {\n        return !(n.eventName === e && n.layerList.every(function (e) {\n          return t.includes(e);\n        }) && n.callback === r);\n      });\n    }\n\n    var As = \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n        Ss = \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n        Ps = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\";\n    r.d(t, \"source\", function () {\n      return Is;\n    }), r.d(t, \"version\", function () {\n      return ms.a;\n    }), r.d(t, \"on\", function () {\n      return on;\n    }), r.d(t, \"off\", function () {\n      return off;\n    }), r.d(t, \"isBrowserSupported\", function () {\n      return isBrowserSupported;\n    }), r.d(t, \"unsupportedBrowserReasons\", function () {\n      return unsupportedBrowserReasons;\n    }), r.d(t, \"setDefaultAuth\", function () {\n      return setDefaultAuth;\n    }), r.d(t, \"setDefaultConfig\", function () {\n      return setDefaultConfig;\n    }), r.d(t, \"expressions\", function () {\n      return u;\n    }), r.d(t, \"Layer\", function () {\n      return xu;\n    }), r.d(t, \"Viz\", function () {\n      return ou;\n    }), r.d(t, \"Interactivity\", function () {\n      return Cu;\n    }), r.d(t, \"basemaps\", function () {\n      return s;\n    });\n    var Is = {\n      Dataset: _s,\n      SQL: Es,\n      GeoJSON: Cs,\n      MVT: os\n    };\n    t.default = {\n      version: ms.a,\n      on: on,\n      off: off,\n      setDefaultAuth: setDefaultAuth,\n      setDefaultConfig: setDefaultConfig,\n      source: Is,\n      expressions: u,\n      Layer: xu,\n      Viz: ou,\n      Interactivity: Cu,\n      basemaps: s\n    };\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}